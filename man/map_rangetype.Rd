% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map_rangetype.R
\name{map_rangetype}
\alias{map_rangetype}
\title{Interval classification.}
\usage{
map_rangetype(
  map,
  type = "percent",
  ss = NULL,
  min_loop_width = 4,
  intervals = list(start = 1:5, mid = 45:55, end = 95:100),
  N_include = FALSE
)
}
\arguments{
\item{map}{PAC_map (generated by \code{\link{PAC_mapper}}) or a Reanno object
(generated by \code{\link{map_reanno}}), containing mapping coordinates
against a reference fasta file.}

\item{type}{Character indicating what type of intervals that is provided.

  If type="nucleotides", then the interval list is given as ranges of
  nucleotide positions. For example, if interval=list(start=1:3, end=1:3) the
  function will classify sequences starting within the first three
  nucleotides of the reference as 'type_start_nuc' and sequences ending in
  within the last three nucleotides of the reference as 'type_end_nuc'.

  If type="percent", then intervals needs to be provided as percent ranges.
  For example, if intervals=list(start=1:5, mid=45:50, end=95:100) then the
  function will classify sequences starting within the 5% first nucleotides
  in the references as 'type_start_per', and sequences ending within the 5%
  last nucleotides of the references as "type_end_nuc". It will also,
  classify sequences starting within 45-50% of the references as
  "type_mid_start_per" and sequences ending within 45-50% of the references
  as 'type_mid_end_per'.

  If type="ss", then intevals is obtain from an ss file, obtained for example
  from tRNAscan-SE (\url{http://lowelab.ucsc.edu/tRNAscan-SE/}) or at GtRNAdb
  \url{http://gtrnadb.ucsc.edu/}.

  Important, the intervals list is name senstive. If type="nuclotides"
  intervals can only contain two intervals named 'start' and 'end', while if
  type="percent" then intervals needs to contain three intervals named
  'start', 'mid' and 'end'.

  Hint, for classifying 5' and 3' half tsRNA you need to run the function
  twice. First, classify each sequence as 5'-start or 3'-end tsRNA using
  type="nucleotides", and then rerun the the map object using type="percent"
  specifying the 'mid' region as the half interval.}

\item{ss}{File path to ss file (character), readLines vector of ss file
(character) or ss list. If character, the function will attempt to read a
file from the path given in the character string. If this fails, the
function assumes that the ss file has already been read using
\code{readLines}, and will attempt to split that character vector into a
list of unique sequences by splitting at the empty lines. Empty line
normally delimits each sequence entery in the ss file. Such a list can also
be parsed directly to the function, making it easy to change for example
sequence names using \code{\link{lapply}} prior to running the function.}

\item{min_loop_width}{Integer setting the minimum number of nucleotides for a
loop. Only applicable when type="ss". Loops in ss-files are defined by ">"
followed by x number of "." ending with "<". For example:\cr 
\code{GCATCGGTGGTTCAGTGGTAGAATGCTCGCCTCGCGGGCGGCCCGGGTTCGATTCCCGGCCGATGCA}\cr 
\code{>>>>>>>..>>>>.......<<<<.>>>>>...<<<<<....>>>>>.......<<<<<<<<<<<<.}\cr 
Here are three possible loops: "AGTGGTA", "CTC", "TTCGATT". If
min_loop_width=3, the middle loop (">...<"="CTC") will be classified as a
loop. If min_loop_width=4 (default), the middle loop will not be classified
as a loop because it is too short.}

\item{intervals}{A named list with integer intervals.}

\item{N_include}{Logical whether or not N "wild card" nucleotides should be
counted in the terminals. This conveniently controls the N_up and N_down
arguments in the \code{\link{PAC_mapper}} function. If N_include=FALSE
(default), start and end of tRNA will be measured from the first and last
canonical nucleotides (A, T, C, G). Thus, if fragments align to an
NNN-terminal, it will recieve a netagitve value. If N_include=TRUE, N
wild-cards will be treated as any other nucleotide.}
}
\value{
Map list object containing reference sequence (Ref_seq) as
  Biostrings::DNAStringSet and the new classifications embedded with the
  alignments (Alignments) in a dataframe.
}
\description{
\code{map_rangetype} Classifies sequences based on interval mapping against a
reference.
}
\details{
Given a PAC_map object (\code{\link{PAC_mapper}}) and an interval list this
function will attempt to classify mapped sequences based on where these
sequences starts and ends in reference. This function can for example be used
for 5' and 3' tRNA classification.
}
\examples{


 \dontrun{
# More details on the examples can be found in the vignette.

library(seqpac)
load(system.file("extdata", "drosophila_sRNA_pac_filt_anno.Rdata", 
                 package = "seqpac", mustWork = TRUE))

###########################################################
### tRNA analysis in seqpac 
##----------------------------------------

# First create an annotation blanc PAC with group means
pac$Anno <- pac$Anno[,1, drop=FALSE]
pac_trna <- PAC_summary(pac, norm = "cpm", type = "means", 
                        pheno_target=list("stage"), merge_pac = TRUE)

# Then reannotate only tRNA using the PAC_mapper function
ref <- "/some/path/to/trna.fa"
map_object <- PAC_mapper(pac_trna, ref=ref, N_up = "NNN", N_down = "NNN", 
                         mapper="reanno", mismatches=0, threads=8, 
                         report_string=TRUE)


###########################################################
## Coverage plot of tRNA using PAC_covplot

# Single tRNA targeting a summary dataframe 
PAC_covplot(pac_trna, map=map_object, summary_target= list("cpmMeans_stage"), 
            map_target="tRNA-Ala-AGC-1-1_chr3R:17657145-17657217_(+)")

# Find tRNAs with many fragments
n_tRFs <- unlist(lapply(map_object, function(x){nrow(x[[2]])}))
selct <- (names(map_object)[n_tRFs>1])[c(1, 16, 25, 43)]
cov_plt <- PAC_covplot(pac_trna, map=map_object, 
                       summary_target= list("cpmMeans_stage"), 
                       map_target=selct)
cowplot::plot_grid(plotlist=cov_plt, nrow=2, ncol=2)


###########################################################
## Analyze range types with map_rangetype and PAC_trna functions

# Download ss object from GtRNAdb 
dest_path <- file.path("/some/path/to/destination/file/trna.tar.gz")
web_path <- "http://gtrnadb.ucsc.edu/genomes/eukaryota/Dmela6/dm6-tRNAs.tar.gz"
download.file(url=web_path, destfile=dest_path)
untar(dest_path, exdir= dirname(dest_path), files = "dm6-tRNAs-confidence-set.ss")
ss_file <- "/some/path/to/dm6-tRNAs-confidence-set.ss"

# Classify fragments according to loop cleavage (small loops are omitted)       
map_object_ss <- map_rangetype(map_object, type="ss", 
                               ss=ss_file, min_loop_width=4)          

# Remove reference tRNAs with no hits
map_object_ss <-  map_object_ss[!unlist(lapply(map_object_ss, function(x){
                     x[[2]][1,1] == "no_hits"
                     }))]
map_object_ss[[2]]



###########################################################
# Function classifying 5'-tRF, 5'halves, i-tRF, 3'-tRF, 3'halves

# Set tolerance for classification as a terminal tRF
tolerance <- 5  # 2 nucleotides from start or end of full-length tRNA)

# Apply the tRNA_class function and make a tRNA type column
pac_trna <- tRNA_class(pac_trna, map=map_object_ss, terminal=tolerance)
head(pac_trna$Anno)

# Now use PAC_trna to generate some graphs based on grand means
trna_result <- PAC_trna(pac_trna, norm="cpm", filter = NULL,
  join = TRUE, top = 15, log2fc = TRUE,
  pheno_target = list("stage", c("Stage1", "Stage3")), 
  anno_target_1 = list("type"),
  anno_target_2 = list("class"))

cowplot::plot_grid(trna_result$plots$Expression_Anno_1$Grand_means,
                   trna_result$plots$Log2FC_Anno_1,
                   trna_result$plots$Percent_bars$Grand_means,
                   nrow=1, ncol=3)

# By setting join = FALSE you will get group means
trna_result <- PAC_trna(pac_trna, norm="cpm", filter = NULL,
  join = FALSE, top = 15, log2fc = TRUE,
  pheno_target = list("stage", c("Stage1", "Stage3")), 
  anno_target_1 = list("type"),
  anno_target_2 = list("class"))

cowplot::plot_grid(trna_result$plots$Expression_Anno_1$Stage1,
                   trna_result$plots$Expression_Anno_1$Stage3,
                   trna_result$plots$Log2FC_Anno_1,
                   trna_result$plots$Percent_bars$Stage1,
                   trna_result$plots$Percent_bars$Stage3,
                   nrow=1, ncol=5)
      
   
}                    

}
\seealso{
\url{https://github.com/Danis102} for updates on the current
  package.

Other PAC analysis: 
\code{\link{PAC_covplot}()},
\code{\link{PAC_deseq}()},
\code{\link{PAC_filter}()},
\code{\link{PAC_filtsep}()},
\code{\link{PAC_gtf}()},
\code{\link{PAC_jitter}()},
\code{\link{PAC_mapper}()},
\code{\link{PAC_mismap}()},
\code{\link{PAC_nbias}()},
\code{\link{PAC_norm}()},
\code{\link{PAC_pca}()},
\code{\link{PAC_pie}()},
\code{\link{PAC_saturation}()},
\code{\link{PAC_sizedist}()},
\code{\link{PAC_stackbar}()},
\code{\link{PAC_summary}()},
\code{\link{PAC_trna}()},
\code{\link{as.PAC}()},
\code{\link{filtsep_bin}()},
\code{\link{tRNA_class}()}
}
\concept{PAC analysis}
