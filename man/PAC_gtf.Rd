% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PAC_gtf.R
\name{PAC_gtf}
\alias{PAC_gtf}
\title{Annotate against a GTF file}
\usage{
PAC_gtf(
  PAC,
  genome = NULL,
  mismatches = 3,
  return = "simplify",
  stranded = FALSE,
  gtf = NULL,
  targets = NULL,
  threads = 1
)
}
\arguments{
\item{PAC}{PAC-list object. The Anno object needs to contain genome
coordinates in the following columns: "chr","start","end", and "strand".
These coordinates are eaisly obtained by using \code{PAC_genome}}

\item{genome}{Character indicating the path to a reference genome file in
fasta format. Note that a bowtie index, created by for example
Rbowtie::bowtie-build,  must be contained in the same folder and having the
same basename as the fasta.}

\item{mismatches}{Integer indicating the number of allowed mismatches for the
genome mapping.}

\item{return}{Character indicating what information to return. 

   If return="simplify" (default), a table containing with one unique
   sequence per row will be returned. Multiple hits between genomic
   coordinates and gtf coordinates will be merged and only unique annotations
   will be reported.
   
   If return="full", a list will be returned containing 1 table reporting all
   annotations for each genomic coordinate of each unique sequence.
   
   If return="all", both a simplified table and a full annotation list will
   be returned as a list.
   
   If return="merge", a simplified table will be merged with the Anno table
   of the provided PAC object, and an updated PAC object containing the new
   annotations will be returned.}

\item{stranded}{Logical whether mapping should be strand specific. If
stranded=TRUE, then hits between feature and PAC read sequence will not be
reported if the feature is located on opposite strand. If
stranded=FALSE (default), then both sense and anti-sense overlaps will be
reported. Note, stranded=FALSE is recommended since PAC_gtf will report on
which strand each feature/sequence is mapping. Thus, strand specific
analysis can be done in hindsight.}

\item{gtf}{Named list of characters, indicating file path(s) to other
gtf files with differing formats. Can also directly be provided as a tibble
dataframe in a named list.}

\item{targets}{Named list of character vectors indicating target columns
in the listed gtf files in \emph{gtf_other}. Important, the listed objects
must have the same length and names as in \emph{gtf}. The vector
indicates the column names as if imported by rtracklayer::readGFF.}

\item{threads}{Integer indicating the number of parallel processes.}
}
\value{
List, tibble dataframe or updated PAC object. See \emph{return} for
  more information.
}
\description{
This function will annotate a PAC object using input from a GTF/GFF file.
}
\details{
Given a PAC object and a gtf formated annotation file(s), this function will
attempt to annotate sequences mapped to a reference genome against genomic
coordinates in the gtf file(s). In case no genomic mapping coordinates are
available in the PAC object, the function provides a backdoor into the
\emph{PAC reannotation} workflow, where genome mapping is performed using
Bowtie.
}
\examples{


\dontrun{

library(seqpac)
load(system.file("extdata", "drosophila_sRNA_pac_filt_anno.Rdata", 
                 package = "seqpac", mustWork = TRUE))

##############################################################
## Simple repeatmasker annotation with genomic mapping

# Specify genome fasta and repeatMasker gtf:      
genome <- "/some/path/to/genome.fa"
gtf <- list(repeatMasker="/some/path/to/repeatMasker.gtf")

# Target columns in gtf file:
targets <- list(gtf=c("gene_name", "repClass", "repFamily")) 

# Run PAC_gtf
repeat_simple <- PAC_gtf(pac, genome=genome, return="simplify", 
                         gtf=gtf, threads=10)


##############################################################
## Fix different chromosome names in gtf file?

# First download reference sequences from Ensembl, UCSC and NCBI (refSeq)
# Then make a conversion table:

ref_path_A <- "/some/path/to/ensembl.fa"
ref_path_B <- "/some/path/to/ucsc.fa"
ref_path_C <- "/some/path/to/refseq.fa"
reference_list <- list(ensembl=ref_path_A, UCSC=ref_path_B, NCBI=ref_path_C)
conv_table <- make_conv(reference_list=reference_list, skip_after=" ") 

# Read gtf with rtracklayer:
gtf <- "/some/path/to/repeatMasker.gtf"
gtf <- "/data/Data_analysis/Genomes/Drosophila/dm6/RepeatMasker/dm6/repeatMasker_dm6_ucsc_2019.gtf"
rm <- rtracklayer::readGFF(gtf)

# Identify what type of names:
table(rm$seqid)
table(conv_table$name_UCSC)
table(unique(rm$seqid) \%in\% unique(conv_table$name_UCSC))

# Ensembl conversion for USCS gtf by matching conv_table: 
ensembl_conv  <- conv_table$name_ensembl[match(rm$seqid,
                                                conv_table$name_UCSC)]
# Visually inspect conversion vector                                                         
head(cbind(unique(ensembl_conv), unique(as.character(rm$seqid)))) 
table(head(unique(paste(ensembl_conv, rm$seqid, sep="|"))))

# Exchange and export new gtf
rm$seqid <- ensembl_conv
gr <- GenomicRanges::GRanges(seqnames=rm$seqid, 
                             IRanges::IRanges(rm$start, 
                                              rm$end), 
                             strand=rm$strand)
GenomicRanges::mcols(gr) <- data.frame(type="repeat", 
                                       source="repeatMasker_dm6_ucsc",
                                       repName = rm$gene_name, 
                                       repClass = rm$repClass,
                                       repFamily = rm$repFamily)
                                       
rtracklayer::export(gr, "/some/path/to/repeatMasker_ensembl.gtf", format="gtf")


##############################################################
### Full output previously mapped columns up to 3 mismatches

## Generates an error because genome mapping was done
## with add_reanno(genome_max=10):

# Target genome columns in PAC  
genome_col <- colnames(
  pac$Anno)[grepl("chromosomes_genome", colnames(pac$Anno))]


# Read converted gtf and pinpoint to target columns in gtf file:
gtf <- list(repeatMasker="/some/path/to/repeatMasker_ensembl.gtf") 
targets <- list(repeatMasker=c("repName", "repClass", "repFamily"))


repeat_full <- PAC_gtf(pac, genome=genome_col, return="full", 
                       gtf=gtf, targets=targets, threads=10) 

# Works because PAC_gtf automatically maps the 
# genome with add_reanno(genome_max="all")
genome_col <- colnames(pac_merge$Anno)[grepl("^genome|mis\\\\d_genome", 
                                              colnames(pac_merge$Anno))]
repeat_full <- PAC_gtf(pac, genome=genome, return="full", 
                       gtf=gtf, targets=targets, threads=10)

# return="full" returns all annotation for all each coordinate
repeat_full[800:820]
head(repeat_full["TGCGGAAGGATCATTA_mis0"])
     

###############################################################
### With additional gtfs including custom other

gtf_repeat <- "/some/path/to/repeatMasker.gtf"
gtf_protein <- "/some/path/to/reference.genome.gtf" # e.g. from ensembl ftp 

# Note, target_other points to columns in each gtf listed in gtf_other 
# and the list objects must therefore have the same names:
gtf_other=list(rep=gtf_repeat, prot=gtf_protein)
target_other=list(rep="repFamily", prot=c("type", "gene_id")) 

genome_col <- colnames(pac_merge$Anno)[grepl("^genome|mis\\\\d_genome", 
                                              colnames(pac_merge$Anno))]
many_simply <- PAC_gtf(pac_merge, genome=genome_col, return="simplify", 
                       mismatches=3, gtf_repeat=gtf_repeat, 
                       gtf_protein=gtf_protein,gtf_other=gtf_other, 
                       target_other=target_other, threads=10)

# With perfect alignments (0 mismatches)
many_simply <- PAC_gtf(pac_merge, genome=genome_col, return="simplify", 
                       mismatches=0, gtf_repeat=gtf_repeat, 
                       gtf_protein=gtf_protein, threads=10)

}

}
\seealso{
\url{https://github.com/Danis102} for updates.

Other PAC analysis: 
\code{\link{PAC_covplot}()},
\code{\link{PAC_deseq}()},
\code{\link{PAC_filter}()},
\code{\link{PAC_filtsep}()},
\code{\link{PAC_jitter}()},
\code{\link{PAC_mapper}()},
\code{\link{PAC_nbias}()},
\code{\link{PAC_norm}()},
\code{\link{PAC_pca}()},
\code{\link{PAC_pie}()},
\code{\link{PAC_saturation}()},
\code{\link{PAC_sizedist}()},
\code{\link{PAC_stackbar}()},
\code{\link{PAC_summary}()},
\code{\link{PAC_trna}()},
\code{\link{as.PAC}()},
\code{\link{filtsep_bin}()},
\code{\link{map_rangetype}()},
\code{\link{tRNA_class}()}
}
\concept{PAC analysis}
