% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convert_seqnames.R
\name{convert_seqnames}
\alias{convert_seqnames}
\title{Create reference genome conversion table}
\usage{
convert_seqnames(
  reference_list = NULL,
  ref_path_A = NULL,
  ref_path_B = NULL,
  ref_path_C = NULL,
  output = "tibble"
)
}
\arguments{
\item{reference_list}{List containing 2-3 file paths (character strings) to
references in fasta format. The names of the list items will be imported
into the final conversion table. The function may also take each reference
path as single character strings (ref_path_A, ref_path_B, ref_path_C), but
then any user-defined reference name will be lost (see example below).}

\item{output}{Character indicating what type of output. As default
output="tibble" will result in a table in the tibble format as described in
tibble/tidyverse packages. Anything else will result in a data frame.}
}
\value{
A name conversion table either as a tibble or a data frame (see
  output)
}
\description{
Generates a table that can be used for converting seqnames across referens
genomes.
}
\details{
Given the file paths to 2-3 fasta reference genomes, this function will
quickly match the the sequences between these reference genomes and return
seqnames of each matching sequence. Thus, given the paths to the fasta for
the Ensembl, UCSC and NCBI assemblies of a given genome version (e.g. hg38 or
dm6), will result in a name conversion table between these databases. 

Only perfect matches or no matches will be reported. Thus, in case an entire
sequence is missing (e.g. a sex chromosomes), a table will be returned with a
warning, but if a sequence is partly missing (e.g. only half a chromosome),
then an error is returned. 

Sequence matching is done using md5 hashes, which dramatically increases the
speed for perfect matches. Matching will always be done from reference A
against the other references). Thus, if reference A (=1st reference in
reference_list) contains less sequences than the other references, only the
reference A sequences will be reported in the output, having the same order
as in reference A.
}
\examples{

#library(seqpac)
#load(system.file("extdata", "drosophila_sRNA_pac_anno.Rdata", 
#                 package = "seqpac", mustWork = TRUE))

#ref_path_A <- "/data/Data_analysis/Genomes/Drosophila/dm6/Ensembl/dm6_ensembl_release_101/fasta/Drosophila_melanogaster.BDGP6.28.dna.toplevel.fa"
#ref_path_B <- "/data/Data_analysis/Genomes/Drosophila/dm6/UCSC/dm6.fa.gz"
#ref_path_C <- "/data/Data_analysis/Genomes/Drosophila/dm6/NCBI/GCF_000001215.4_Release_6_plus_ISO1_MT_genomic.fna.gz"

#reference_list <- list(ensembl=ref_path_A, UCSC=ref_path_B, NCBI=ref_path_C)

## Best (user defined names):
#conv_table <- convert_seqnames(reference_list=reference_list) 

## But also (no names)
#conv_table <- convert_seqnames(ref_path_A, ref_path_B, ref_path_C)
#conv_table <- convert_seqnames(ref_path_A, ref_path_C)





#export
}
\seealso{
\url{https://github.com/Danis102} for updates.

Other PAC reannotation: 
\code{\link{add_reanno}()},
\code{\link{check_reanno}()},
\code{\link{import_reanno}()},
\code{\link{make_reanno}()},
\code{\link{map_reanno}()},
\code{\link{simplify_reanno}()}
}
\concept{PAC reannotation}
