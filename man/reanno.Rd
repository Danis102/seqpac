% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/seqpac_S4classes.R
\docType{class}
\name{reanno-class}
\alias{reanno-class}
\alias{reanno}
\title{S4 object for reanno output}
\usage{
reanno(Overview, Full_anno)
}
\value{
Contains two slots:  1. Overview: A table holding a summary of the
mapping. 2. Full_anno: Lists of tables holding the full imports per mismatch
cycle (mis0, mis1 etc) and reference (mi0-ref1, mis0-ref2, mis1-ref1,
mis1-ref2 etc).
}
\description{
Holds the imported information from mapping using the map_reanno function.
All information are held in tibble class (tbl/tbl_df) tables from the tibble
package.
}
\examples{

 library(seqpac)

# load data
 load(system.file("extdata", "drosophila_sRNA_pac_filt.Rdata", 
                  package = "seqpac", mustWork = TRUE))
 pac = pac_cpm_filt
 
 ## Genome example
 # setup temporary output folder depending on windows or linux 
 
 if(grepl("windows", .Platform$OS.type)){
   output <- paste0(tempdir(), "\\\\seqpac\\\\test")
 }else{
   output <- paste0(tempdir(), "/seqpac/test")
 }
 
# Empty temp output folder
 out_fls  <- list.files(output, recursive=TRUE, full.names = TRUE)
 suppressWarnings(file.remove(out_fls))
 
# Run reanno workflow loading test genome fasta
 mycoplasma_path <- paste0(getwd(), "/tests/testthat/data_for_tests/mycoplasma_genome")
 ref_paths <- list(genome1= list.files(mycoplasma_path, pattern=".fa", 
                                       full.names = TRUE),
                   genome2= list.files(mycoplasma_path, pattern=".fa", 
                                       full.names = TRUE))
 
 map_reanno(PAC=pac, ref_paths=ref_paths, output_path=output,
                type="internal", mismatches=3, import="genome", 
                threads=8, keep_temp=FALSE)

 reanno_genome <- make_reanno(output, PAC=pac, mis_fasta_check = TRUE, 
                                output="list")
                                
 pac <- add_reanno(reanno_genome, type="genome", genome_max=10, 
                     mismatches=1, merge_pac=pac)

class(pac)
isS4(pac)                        
 
class(reanno_genome)
isS4(reanno_genome)
names(reanno_genome)   
 
# Turns S3 reanno object into a S4                                    
reanno_s4 <- as.reanno(reanno_genome)
class(reanno_s4)
isS4(reanno_s4) 
 
# Similar turns S3 PAC object into a S4                                    
pac_s4 <- as.PAC(pac)
class(pac_s4)
isS4(pac_s4)   

# Turns S3 reanno object back into a S4 using specific S4 coercion:                               
reanno_s3 <- as(reanno_s4, "list")
class(reanno_s3)
isS4(reanno_s3)

# Turns S3 PAC object into a S4                                    
pac_s3 <- as(pac_s4, "list")

# Don't forget that in the slots of S4 lies regular S3 objects. Thus,
# to receive these tables from an S4  you need to combine both S4 and S3
# receivers:

pac_s4 <- PAC_norm(pac_s4, norm = "cpm")
pac_s4 <- PAC_summary(pac_s4, norm = "cpm", type = "means", 
                   pheno_target=list("stage"), merge_pac=TRUE)

pac_s4 
head(pac_s4@norm$cpm)
head(pac_s4@summary$cpmMeans_stage)

}
