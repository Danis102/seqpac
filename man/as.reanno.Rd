% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/seqpac_S4classes.R
\name{as.reanno}
\alias{as.reanno}
\title{Converts an S3 reanno into a S4 reanno}
\usage{
as.reanno(from)
}
\arguments{
\item{from}{S3 reanno object.}
}
\value{
An S4 reanno object.
}
\description{
\code{as.reanno} Converts an S3 reanno object (list) to an S4 reanno object
}
\details{
Seqpac comes with two versions of the reanno object, either S4 or S3. The S3 
is simply a list where each object can be received using the $-sign. The S4
version is a newer type of R object with predefined slots, that is received
using the @-sign. This function converts an S3 reanno object (list) to an S4 
object. You can also use the S4 coercion method "as" to turn an S4 into
an S3. See examples below.
}
\examples{

 library(seqpac)

## load data
 load(system.file("extdata", "drosophila_sRNA_pac_filt.Rdata", 
                  package = "seqpac", mustWork = TRUE))
 pac = pac_cpm_filt
 
 ## Genome example
 # setup temporary output folder depending on windows or linux 
 
 if(grepl("windows", .Platform$OS.type)){
   output <- paste0(tempdir(), "\\\\seqpac\\\\test")
 }else{
   output <- paste0(tempdir(), "/seqpac/test")
 }
 
# Empty temp output folder
 out_fls  <- list.files(output, recursive=TRUE, full.names = TRUE)
 suppressWarnings(file.remove(out_fls))
 
 
# Run reanno workflow loading test genome fasta
 mycoplasma_path <- paste0(getwd(), "/tests/testthat/data_for_tests/mycoplasma_genome")
 ref_paths <- list(genome1= list.files(mycoplasma_path, pattern=".fa", 
                                       full.names = TRUE),
                   genome2= list.files(mycoplasma_path, pattern=".fa", 
                                       full.names = TRUE))
 
 

 map_reanno(PAC=pac, ref_paths=ref_paths, output_path=output,
                type="internal", mismatches=3, import="genome", 
                threads=8, keep_temp=FALSE)

 reanno_genome <- make_reanno(output, PAC=pac, mis_fasta_check = TRUE, 
                                output="list")
                                
                                
 pac <- add_reanno(reanno_genome, type="genome", genome_max=10, 
                     mismatches=1, merge_pac=pac)


class(pac)
isS4(pac)                        
 
class(reanno_genome)
isS4(reanno_genome)
names(reanno_genome)   
 
# Turns S3 reanno object into a S4                                    
reanno_s4 <- as.reanno(reanno_genome)
class(reanno_s4)
isS4(reanno_s4) 
 
# Similar, turns S3 PAC object into a S4                                    
pac_s4 <- as.PAC(pac)
class(pac_s4)
isS4(pac_s4)   


# Turns S3 reanno object back into a S4 using specific S4 coercion:                               
reanno_s3 <- as(reanno_s4, "list")
class(reanno_s3)
isS4(reanno_s3)

# Turns S3 PAC object into a S4                                    
pac_s3 <- as(pac_s4, "list")

# Don't forget that in the slots of S4 lies regular S3 objects. Thus,
# to receive these tables from an S4  you need to combine both S4 and S3
# receivers:

pac_s4 <- PAC_norm(pac_s4, norm = "cpm")
pac_s4 <- PAC_summary(pac_s4, norm = "cpm", type = "means", 
                   pheno_target=list("stage"), merge_pac=TRUE)

pac_s4 
head(pac_s4@norm$cpm)
head(pac_s4@summary$cpmMeans_stage)

}
\seealso{
\url{https://github.com/Danis102} for updates on the current
  package.

Other PAC reannotation: 
\code{\link{add_reanno}()},
\code{\link{check_reanno}()},
\code{\link{import_reanno}()},
\code{\link{make_conv}()},
\code{\link{make_reanno}()},
\code{\link{map_reanno}()},
\code{\link{simplify_reanno}()}
}
\concept{PAC reannotation}
