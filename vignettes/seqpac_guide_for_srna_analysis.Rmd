---
title: "seqpac - Guide for sRNA analysis"
author: "Daniel NÃ¤tt"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{seqpac - Guide for sRNA analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
## 1.1 Introduction

Seqpac contains a complete toolbox for the analysis of short sequenced reads.
The package was originally developed for small RNA (sRNA) analysis, but can be
applied on any type of data generated by large scale nucleotide sequencing,
where the user wish to maintain sequence integrity during the whole analysis.
This involves, for example, regular RNA-seq with long RNA.

To perserve sequence integrity, seqpac applies sequence-based counting. This can
be contrasted against feature-based counting, where reads are counted over known
genomic features, such a protein coding gene or sRNA. This will result in a
count table where a count is made per feature (e.g. number of read counts
mapping to a gene). In seqpac, such annotations are initially disregarded, as a
count table is generated solely by counting unique sequences in the raw sequence
files. Annotation against known refereces (such as databases containing miRNA,
tRNA, or protein coding genes) are done after the count table has been
generated.

The big advantage of using sequence-based counting, compared to feature-based
counting, is that mismatches in the classification of reads, can be applied
anytime during the analysis. In feature-based counting, allowing a mismatch in
the mapping will result in a loss of information (loss of sequence integrity).

For example, say that you have 506 read counts for miR-185 (a miRNA) when
allowing 3 mismatches against the reference. In feature-based analysis this will
result in 1 entery in the count table. Unless you have saved the the exact
alignments elsewhare, you have lost the information about what sequences that
are included in that count. The only thing you know is that the sequence may
differ from the reference sequence by any 3 mismaches. In sequence-based
counting, reads are counted as uniques sequences and each unique sequence is
then mapped againts the target reference databases. Information about whether a
sequence was mapped against a reference is maintained in an a linked annotation
table that can contain both perfect alignments and alignments allowing
mismatches. Thus in any stage of the analysis mismatches and classification into
features can be dynamically controlled, meaning that you can easily observe the
effect of allowing mismatches and changes in hierarchical classifications (often
applied in sRNA analysis when a sequence align with multiple classes of sRNA).


## 1.2 The seqpac workflow
The input file format for seqpac is .fastq, which can be generated from most
sequencing platforms. Two types of objects sustain the core of the seqpac
workflow:

    The PAC object 
    The Targeting objects


The PAC object stores the Phenotypic information (P), Annotations (A) and Counts
(C) needed for all downstream analysis, while the targeting object is used for
accessing specific subsets of data within the PAC object. To keep things simple,
both these objects are lists. The PAC object is in its simplest for a list of 3
dataframes (P, A and C), while the Targeting object is a list of 2 character
vectors.

The workflow is roughly divided into three steps: 

    i. Generate a PAC object from fastq-files
    ii. Preprocess the PAC object
    iii. Annotate the PAC object
    iv. Analyze the PAC object.


## 2.1 Example dataset
Contained within this package are six example fastq files. These files were
originally generated from extracting sRNA from fruit fly ovaries and sperm
(three each). The files were downsampled from original fastq-files aquired by
Illumina NextSeq 500 sequencer using a High Output 75 cycles flowcell (product
no: 20024906). 

## 2.2 Generate a PAC object from fastq-files

### 2.2.1 make_counts
The first step depends on two external softwares, cutadapt and
fastq_quality_filter, which will trim the adapter sequence and remove low
quality reads prior of making a count table (C).

Important, cutadapt (stand alone) and fastq_quality_filter (part of FASTX-Toolkit) are only
available on Linux: 
    https://cutadapt.readthedocs.io/en/stable/installation.html
    http://hannonlab.cshl.edu/fastx_toolkit/commandline.html
    
<br>
For convenience we provide an aready trimmed and quality filtered count table here:
```{r}
library(seqpac)
load(system.file("extdata", "drosophila_sRNA_counts.Rdata", package = "seqpac", mustWork = TRUE))
```

<br>
For linux users with all dependencies installed:
```{r, eval = FALSE}
###--------------------------------------------------------------------- 
# Generate counts using setting path to fastq files and parse commands to cutadapt
# (Note, the cutadapt parse argument is specifcly designed for sRNA trimming.) 
path_to_fastq <- system.file("extdata", package = "seqpac", mustWork = TRUE)

parse_to_cutadapt <- "cutadapt -j 1 -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCACAT --discard-untrimmed --nextseq-trim=20 -O 5 -m 5"

counts <- make_counts(path_to_fastq, type="fastq", threads=4, cutadpt=TRUE, parse=parse_to_cutadapt)

```

Note that *counts* contains both a count table and the logs generated by
cutadapt/fastq_quality_filter. For other platforms, you may load already trimmed
and quality filtered fastq files by setting `cutadapt=FALSE`.

Also note that seqpac uses an intital noise filter. The `make_counts` function
will remove sequences that fail to appear in two independent fastq files. In
most studies, this will only remove noise since it is questionable if sequences
with evidence from only one single sample truely exists and should be analyzed
together with sequences that have better evidence. Since seqpac focuses on group
analysis evidence from at least two independent samples is a minimum inclusion
criteria.

### 2.2.2 make_anno
Next, generate a simple Anno table (A):
```{r, results = "hide"}
###--------------------------------------------------------------------- 
## Generate a annotation table from the counts table 
anno <- make_anno(input=counts$counts, type="counts")

```

### 2.2.3 make_pheno
Now, generate a Pheno table (P) and add a report from the logs in *counts*: 
```{r, results = "hide"}
###--------------------------------------------------------------------- 
## Generate a progress report from the cutadapt/fastq_quality_filter logs in counts
prog <- progress_report(counts)
```
```{r, results = "hide"}
###--------------------------------------------------------------------- 
## Generate Pheno table from file names and add report
path_to_fastq <- system.file("extdata", package = "seqpac")
pheno <- as.data.frame(do.call("rbind", strsplit(list.files(path_to_fastq, pattern="*.fastq.gz"), "_|\\."))[,c(2,4,5)]) 
colnames(pheno) <- c("sample", "type", "replicate"); rownames(pheno) <- colnames(counts$counts)
pheno <- make_pheno(pheno_input=pheno, progress_report=prog, counts=counts$counts)

```

### 2.2.4 make_PAC
<br>
Finally, put everything together as a master PAC object:
```{r}
###--------------------------------------------------------------------- 
## Generate PAC object
pac_master <- make_PAC(pheno_input=pheno, anno_input=anno, counts_input=counts$counts)
names(pac_master)

## If TRUE the PAC object is ok 
PAC_check(pac_master)
```

<br>
## 2.3 Preprocessing

### 2.3.1 Targeting objects
Seqpac uses a simple targeting system for dividing and focusing the analysis of
a PAC object to certain sample groups (Pheno) or specific sequences (Anno). If
not specified otherwise in the function help, a targetting object is always a
two item list, where the first object is a column name and the second object tells
the which categories in that column that should be targeted. 

    pheno_target: extracts sample groups from a column in PAC$Pheno
    anno_target: extracts sequences from a column in PAC$Anno

While pheno_target and anno_target are the most common targeting objects, as you
will see there are other targeting object. In common for all is that they target
a specific subtable stored in PAC.

<br>
Example, extract the the first columns in Pheno table and the first lines of the
Anno table found in master PAC object that was generated in 2.1.3.

```{r}
pac_master$Pheno[,1:3]
head(pac_master$Anno)

```

A pheno_target object that will target replicate 1 and 2 would look like this:
`pheno_target=list("replicate", c("test1", "test2"))`

While an anno_target that will target sequences of 22 nt in length would look like this:
`anno_target=list("Length", "22")`

Notice that both target objects is a list of two character vectors, one
targeting a specific column and one targeting specific groups within that
column.

Important, if the second object is set to NULL or is empty this will
automatically target all samples in a given column. If the anno_target is a
character vector (not a list) some function will attempt extract matches in the
rownames of either Pheno or Anno (see example with `PAC_filtsep` below).


### 2.3.2 Filtering
A master PAC object will contain sequences in your original fastq files that
past the cutadapt/quality filters and have at least two evidence in two
independent samples. Now, in most analysis this still involves millions of
unique sequences, making the master PAC difficult to work with. Thus it is often
wise to further reduce noise prior to normalization and annotation.

Seqpac contains two functions for this purpose:

    PAC_filter
    PAC_filtsep

While `PAC_filter` gives a variety of choices to subset the PAC file according
to for example sequence size or minimum counts in a certain proportion of the
samples,`PAC_filtsep` extracts lists of top.

Here are some examples:
```{r}
###--------------------------------------------------------------------- 
## Extracts all sequences between 5-80 nt in length with at least 5 counts in 20% of all samples. 
pac_lowfilt <- PAC_filter(pac_master, size=c(10,80), threshold=5, coverage=20, type="counts",  
                          pheno_target=NULL, anno_target=NULL)

###--------------------------------------------------------------------- 
## Extracts all sequences with 22 nt size and the samples test1 and test2 replicates. 
pac_subset <- PAC_filter(pac_master, subset_only = TRUE,
                         pheno_target=list("replicate", c("test1", "test2")), 
                         anno_target=list("Length", "22"))

###--------------------------------------------------------------------- 
## Extracts all sequences with >=10 counts in 100% of samples within each category of the 'type' column in Pheno.
filtsep <- PAC_filtsep(pac_master, type="counts", threshold=10, coverage=100, pheno_target= list("type"))

pac_filt <- PAC_filter(pac_master, subset_only = TRUE,
                       anno_target= unique(do.call("c", as.list(filtsep))))

```

Notice that PAC_filtsep only extracts the sequence names and store them in a
dataframe. Converted into a character vector with unique names (using `unique` +
`do.call`) they can be applied as a anno_target that targets sequence names in
Anno. 

Hint, the dataframe output of PAC_filtsep has been designed for the purpose of
generating Venn diagrams that visualize top overlaps across groups:
```{r}
olap <- reshape2::melt(filtsep, measure.vars = c("Ovaries", "Sperm"), na.rm=TRUE)
plot(venneuler::venneuler(data.frame(olap[,2], olap[,1])))

```

### 2.3.3 Storage of processed data in PAC
While the master PAC only contains three different tables (P, A and C), during
analysis additional 'folders' will be stored in the PAC object. In fact, you may
choose to store any number of objects in your PAC as long as they do not
conflict with the names of the standard objects at the top level, which are:

    Pheno (P):   dataframe
    Anno (A):    dataframe
    Couns (C):   dataframe
    norm:        list of dataframes
    summary:     list of dataframes

The *norm* folder will be used to store Counts that have been normalized in
different ways, while the *summary* folder will contain the data that has been
summerized across groups of samples. In both cases, applying a filter using
`PAC_filter` will automatically subset not only P, A, and C, but also all tables
stored in *norm* and *summary*.


### 2.3.4 Normalization
The built in normalization methods in seqpac are handled by the `PAC_norm`
function. In the current version only three methods are available: 

    1. Reads Per Million (rpm) 
    2. Variance-Stabalizing Transformation (vst)
    3. Regularized log Transformation (rlog)

More specifically, rpm normalize the dataset by dividing the counts with total
number of counts within a sample, while vst and rlog are wrappers to the
`rlogTransformation` and `varianceStabilizingTransformation` functions in
DESeq2. Note that vst and rlog specific settings (blind=TRUE, fitType="mean").

It is easy to generate your own normalized count table using your
method of choice, and import it as a dataframe to the *norm* folder in the PAC
object. Just remember that row and column names must be identical to the
original Counts table. Use `PAC_check` to verify that this is the case.

<br>
Lets generate a few normalized count tables and compare them:
```{r, fig.width = 6, fig.height = 3}
###--------------------------------------------------------------------- 
## Since the example pac_master is small to begin with we use this as start:
## (You may wish to use a low-filtered PAC for normalization to get rid of noise)

pac_rpm <- PAC_norm(pac_master, type="rpm")                 # Returned as a dataframe in the PAC$norm folder
df_vst <- PAC_norm(pac_master, type="vst", PAC_merge=FALSE) # Returned as a dataframe 
df_rlog <- PAC_norm(pac_master, type="rlog", PAC_merge=FALSE) 

cowplot::plot_grid(nrow=1, ncol=2,
            ggplot2::ggplot(data.frame(log2_mean_rpm=log2(rowMeans(pac_rpm$norm$rpm)), mean_vst=rowMeans(df_vst)), aes(x=log2_mean_rpm, y=mean_vst)) + geom_point(),
            ggplot2::ggplot(data.frame(log2_mean_rpm=log2(rowMeans(pac_rpm$norm$rpm)), mean_rlog=rowMeans(df_rlog)), aes(x=log2_mean_rpm, y=mean_rlog)) + geom_point())

```

<br>
As you probably noticed we only stored the rpm values in the PAC. Lets now apply
a deeper filter that are based on rpm thresholds:

```{r}
###--------------------------------------------------------------------- 
## Extracts all sequences with >=10 counts in 100% of samples within each category of the 'type' column in Pheno.
filtsep <- PAC_filtsep(pac_rpm, type="rpm", threshold=10, coverage=100, pheno_target= list("type"))

pac_hifilt <- PAC_filter(pac_rpm, subset_only = TRUE,
                       anno_target= unique(do.call("c", as.list(filtsep))))

PAC_check(pac_hifilt)

ls.str(pac_hifilt)
```

<br>
## 2.4 Annotation
So far we have not bothered about what type of RNA species (or biotype) that we have in our data, but have   
