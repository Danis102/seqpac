---
title: "seqpac - Guide for sRNA analysis"
author: "Daniel Nätt"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{seqpac - Guide for sRNA analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
<br>
<br>

---

## 1.1 Introduction

Seqpac contains a complete toolbox for the analysis of short sequenced reads.
The package was originally developed for small RNA (sRNA) analysis, but can be
applied on any type of data generated by large scale nucleotide sequencing,
where the user wish to maintain sequence integrity during the whole analysis.
This involves, for example, regular RNA-seq with long RNA.

To perserve sequence integrity, seqpac applies sequence-based counting. This can
be contrasted against feature-based counting, where reads are counted over known
genomic features, such a protein coding genes or sRNA. This will result in a
count table where a count is made per feature (e.g. number of read counts
mapping to a gene). In seqpac, such annotations are initially disregarded, as a
count table is generated solely by counting unique sequences in the raw sequence
files. Annotation against known refereces (such as databases containing genome,
miRNA, tRNA, or protein coding genes) are done after the count table has been
generated.

The big advantage of using sequence-based counting, compared to feature-based
counting, is that mismatches in the classification of reads, can be applied
anytime during the analysis. In feature-based counting, allowing a mismatch in
the mapping will result in a loss of information (loss of sequence integrity).

For example, say that you have 506 read counts for miR-185 (a miRNA) when
allowing 3 mismatches against the reference. In feature-based analysis this will
result in 1 entry in the count table. Unless you have saved the the exact
alignments elsewhere, you have lost the information about what sequences that
are included in that count. The only thing you know is that the sequence may
differ from the reference sequence by any 3 mismaches. In sequence-based
counting, reads are counted as unique sequences and each unique sequence is
then mapped againts the target reference databases. Information about whether a
sequence was mapped against a reference is maintained in a linked annotation
table that can contain both perfect alignments and alignments allowing
mismatches. Thus, in any stage of the analysis mismatches and classification into
features can be dynamically controlled, meaning that you can easily observe the
effect of allowing mismatches and changes in hierarchical classifications (often
applied in sRNA analysis when a sequence align with multiple classes of sRNA).


## 1.2 The seqpac workflow
The input file format for seqpac is .fastq, which can be generated from most
sequencing platforms. Two types of objects sustain the core of the seqpac
workflow:

- The PAC object 
- The Targeting objects


The PAC object stores the Phenotypic information (P), Annotations (A) and Counts
(C) needed for all downstream analysis, while the targeting object is used for
accessing specific subsets of data within the PAC object. To keep things simple,
both of these objects are lists. The PAC object is in its simplest form a list of 3
dataframes (P, A and C), while the Targeting object is a list of 2 character
vectors.

The workflow is roughly divided into four steps: 

- Generate a PAC object from fastq-files
- Preprocess the PAC object
- Annotate the PAC object
- Analyze the PAC object.

<br>
<br>

---

# 2 Running the seqpac workflow 

## 2.1 Example dataset

Contained within this package are six example fastq files. These files were
originally generated from extracting sRNA from fruit fly ovaries and sperm
(three each). The files were downsampled from original fastq-files aquired by
Illumina NextSeq 500 sequencer using a High Output 75 cycles flowcell (product
no: 20024906). 

## 2.2 Generate a PAC object from fastq-files

### 2.2.1 make_counts
The first step depends on two external softwares, cutadapt and
fastq_quality_filter, which will trim the adapter sequence and remove low
quality reads prior of making a count table (C).

Important, cutadapt (stand alone) and fastq_quality_filter (part of FASTX-Toolkit) are only
available on Linux: 
    https://cutadapt.readthedocs.io/en/stable/installation.html
    http://hannonlab.cshl.edu/fastx_toolkit/commandline.html
    
<br>
For convenience we provide an aready trimmed and quality filtered count table here:
```{r}
library(seqpac)
load(system.file("extdata", "drosophila_sRNA_counts.Rdata", package = "seqpac", mustWork = TRUE))
```

<br>
For linux users with all dependencies installed:
```{r, eval = FALSE}
###--------------------------------------------------------------------- 
# Generate counts using setting path to fastq files and parse commands to cutadapt
# (Note, the cutadapt parse argument is specifcly designed for sRNA trimming
# with a NebNext smallRNA Library Prep Set For Illumina (E7330) adapter.) 
path_to_fastq <- system.file("extdata", package = "seqpac", mustWork = TRUE)

parse_to_cutadapt <- "cutadapt -j 1 -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCACAT --discard-untrimmed --nextseq-trim=20 -O 5 -m 5"

counts <- make_counts(path_to_fastq, type="fastq", threads=4, cutadpt=TRUE, parse=parse_to_cutadapt)

```

Note that *counts* contains both a count table and the logs generated by
cutadapt/fastq_quality_filter. For other platforms, you may load already trimmed
and quality filtered fastq files by setting `cutadapt=FALSE`.

Also note that seqpac uses an intital noise filter. The `make_counts` function
will remove sequences that fail to appear in two independent fastq files. In
most studies, this will only remove noise since it is questionable if sequences
with evidence from only one single sample truly exists and should be analyzed
together with sequences that have better evidence. As seqpac focuses on group
analysis evidence from at least two independent samples, this is a minimum inclusion
criteria.

### 2.2.2 make_anno
Next, generate a simple Anno table (A):
```{r, results = "hide"}
###--------------------------------------------------------------------- 
## Generate a annotation table from the counts table 
anno <- make_anno(input=counts$counts, type="counts")

```


<br>

### 2.2.3 make_pheno
Now, generate a Pheno table (P) and add a report from the logs in *counts*. 
The Pheno table contains sample specific information such as sample name and possible interventions,
with each sample as a row. Pheno may be added manually (see ?make_pheno), or produced autoamtically,
such as in this case: 
```{r, results = "hide"}
###--------------------------------------------------------------------- 
## Generate a progress report from the cutadapt/fastq_quality_filter logs in counts
prog <- progress_report(counts)
```
```{r, results = "hide"}
###--------------------------------------------------------------------- 
## Generate Pheno table from file names and add report
path_to_fastq <- system.file("extdata", package = "seqpac")
pheno <- as.data.frame(do.call("rbind", strsplit(list.files(path_to_fastq, pattern="*.fastq.gz"), "_|\\."))[,c(2,4,5)]) 
colnames(pheno) <- c("sample", "type", "replicate"); rownames(pheno) <- colnames(counts$counts)
pheno <- make_pheno(pheno_input=pheno, progress_report=prog, counts=counts$counts)

```

### 2.2.4 make_PAC
<br>
Finally, put everything together as a master PAC object:
```{r}
###--------------------------------------------------------------------- 
## Generate PAC object
pac_master <- make_PAC(pheno_input=pheno, anno_input=anno, counts_input=counts$counts)
names(pac_master)

## If TRUE the PAC object is ok 
PAC_check(pac_master)
```

<br>

## 2.3 Preprocess the PAC object

### 2.3.1 Targeting objects
Seqpac uses a simple targeting system for dividing and focusing the analysis of
a PAC object to certain sample groups (Pheno) or specific sequences (Anno). If
not specified otherwise in the function help, a targeting object is always a
two item list, where the first object is a column name and the second object tells
the function which categories in that column that should be targeted. 

    pheno_target: extracts sample groups from a column in PAC$Pheno
    anno_target: extracts sequences from a column in PAC$Anno

While pheno_target and anno_target are the most common targeting objects, there 
are other targeting object. Common for all is that they target
a specific subtable stored in PAC.

<br>
For example, extracting the first columns in Pheno table and the first lines of the
Anno table found in master PAC object that was generated in 2.2.3 would be implemented
as such:

```{r}
pac_master$Pheno[,1:3]
head(pac_master$Anno)

```

A pheno_target object that will target replicate 1 and 2 would look like this:
`pheno_target=list("replicate", c("test1", "test2"))`

While an anno_target that will target sequences of 22 nt in length would look like this:
`anno_target=list("Length", "22")`

Notice that both target objects are a list of two character vectors, one
targeting a specific column and one targeting specific groups within that
column.

Important, if the second object is set to NULL or is empty this will
automatically target all samples in a given column. If the anno_target is a
character vector (not a list) some function will attempt to extract matches in the
rownames of either Pheno or Anno (see example with `PAC_filtsep` below).


### 2.3.2 Filtering
A master PAC object will contain sequences in your original fastq files that
passed the cutadapt/quality filters and have at least two evidence in two
independent samples. Now, in most analysis this still involves millions of
unique sequences, making the master PAC difficult to work with. Thus it is often
wise to further reduce noise prior to normalization and annotation.

Seqpac contains two functions for this purpose:

    PAC_filter
    PAC_filtsep

While `PAC_filter` gives a variety of choices to subset the PAC file according
to for example sequence size or minimum counts in a certain proportion of the
samples.`PAC_filtsep` extracts lists of top.

Here are some examples:
```{r}
###--------------------------------------------------------------------- 
## Extracts all sequences between 5-80 nt in length with at least 5 counts in 20% of all samples. 
pac_lowfilt <- PAC_filter(pac_master, size=c(10,80), threshold=5, coverage=20, type="counts",  
                          pheno_target=NULL, anno_target=NULL)

###--------------------------------------------------------------------- 
## Extracts all sequences with 22 nt size and the samples test1 and test2 replicates. 
pac_subset <- PAC_filter(pac_master, subset_only = TRUE,
                         pheno_target=list("replicate", c("test1", "test2")), 
                         anno_target=list("Length", "22"))

###--------------------------------------------------------------------- 
## Extracts all sequences with >=10 counts in 100% of samples within each category of the 'type' column in Pheno.
filtsep <- PAC_filtsep(pac_master, type="counts", threshold=10, coverage=100, pheno_target= list("type"))

pac_filt <- PAC_filter(pac_master, subset_only = TRUE,
                       anno_target= unique(do.call("c", as.list(filtsep))))
                       
                      

```

Notice that PAC_filtsep only extracts the sequence names and store them in a
dataframe. Converted into a character vector with unique names (using `unique` +
`do.call`) they can be applied as an anno_target that targets sequence names in
Anno. 

Hint, the dataframe output of PAC_filtsep has been designed for the purpose of
generating Venn diagrams that visualize top overlaps across groups:
```{r}
olap <- reshape2::melt(filtsep, measure.vars = c("Ovaries", "Sperm"), na.rm=TRUE)
plot(venneuler::venneuler(data.frame(olap[,2], olap[,1])))

```

### 2.3.3 Storage of processed data in PAC
While the master PAC only contains three different dataframe objects (P, A and
C), additional 'folders' will be stored in the PAC object as the analysis progresses. In
fact, you may choose to store any number of objects in your PAC as long as they
do not conflict with the names of the standard folders which are:

    Pheno (P):   dataframe
    Anno (A):    dataframe
    Counts (C):   dataframe
    norm:        list of dataframes
    summary:     list of dataframes

The *norm* folder will be used to store Counts that have been normalized in
different ways, while the *summary* folder will contain the data that has been
summerized across groups of samples. In both cases, applying a filter using
`PAC_filter` will automatically subset not only P, A, and C, but also all tables
stored in *norm* and *summary*.


### 2.3.4 Normalization
The built in normalization methods in seqpac are handled by the `PAC_norm`
function. In the current version only three methods are available: 

    1. Reads Per Million (rpm) 
    2. Variance-Stabalizing Transformation (vst)
    3. Regularized log Transformation (rlog)

Nonetheless, it is easy to generate your own normalized count table using your
method of choice, and import it as a dataframe to the *norm* folder in the PAC
object. Just remember that row and column names must be identical to the original Counts
table. Use `PAC_check` to verify that this is the case.

More specifically, rpm normalize the dataset according to the total number of reads, while vst 
uses both mean dispersion and size factor to produce homoskedastic values with functions avalable in the DESeq2 package. 


It is easy to generate your own normalized count table using your
method of choice, and import it as a dataframe to the *norm* folder in the PAC
object. Just remember that row and column names must be identical to the
original Counts table. Use `PAC_check` to verify that this is the case.

Lets generate two normalized count tables with rpm and vst:
```{r}
# Since pac_master is small to begin with we use thi

pac_rpm <- PAC_norm(pac_master, type="rpm")
pac_vst <- PAC_norm(pac_master, type="vst")

``` 

From this, it may be wise to run a further filtering step to remove reads with low 
RPM values. 

```{r}

pac_rpm_filt <- PAC_filter(pac_rpm, type="rpm", threshold = 10, coverage = 100)

``` 



## 2.4 Generate annotations
From the start a PAC object only contains a very limited Anno table.

```{r}

library(seqpac)
load(system.file("extdata", "drosophila_sRNA_pac.Rdata", package = "seqpac", mustWork = TRUE))
head(pac_master$Anno)

``` 

To facilitate easy adoption of seqpac to any species, we provide a fast and
comprahensive workflow for mapping PAC sequences against user defined reference
databases. We call this reannotation, since we map the sequences in Anno object
sequentially over one or multiple references.

*Important*, seqpac relies on the popular bowtie aligner for mapping:
http://bowtie-bio.sourceforge.net/manual.shtml. This means that references must
be indexed using \code{bowtie-build} before they are compatible with the
reannotation workflow (see below).

<br>

### 2.4.1 Fasta references
Most databases provide their references in the fasta file format. Seqpac can
use any correctly formated fasta file as input in the reannotation workflow.
However, we destiguish two kinds of fasta references:

1. Reference genomes.
2. Other specialized references.

You can download the files manually from the source database. Below are some
helpful example links where to retreive useful fasta references. Note that all
compressed files must be uncompressed to work with the bowtie aligner.

<br>
**Reference genomes:**
[Ensembl Animals](https://www.ensembl.org/info/data/ftp/index.html) <br>
[Ensembl Plants](https://plants.ensembl.org/info/data/ftp/index.html) <br>
[UCSC](http://hgdownload.cse.ucsc.edu/downloads.html) <br>
[iGenomes](https://emea.support.illumina.com/sequencing/sequencing_software/igenome.html?langsel=/se/) <br>

Hint: Unmasked top level fasta files are best for most purposes, e.g. Ensembl
file name *.dna.toplevel.fa.gz.

**Other specialized references:**
[miRNA (mirbase)](http://www.mirbase.org/ftp.shtml) <br>
[miRNA (mirgenedb)](https://mirgenedb.org/download) <br>
[piRNA (piRBase)](http://www.regulatoryrna.org/database/piRNA/download.html) <br>
[Different ncRNA (Ensembl Animals)](https://www.ensembl.org/info/data/ftp/index.html) <br>
[Different ncRNA (Ensembl Plants)](https://plants.ensembl.org/info/data/ftp/index.html) <br>
[tRNA (GtRNAbd)](http://gtrnadb.ucsc.edu/) <br>
[repeats (repeatMasker)](http://repeatmasker.org/genomicDatasets/RMGenomicDatasets.html) <br>


There are also several packages in R that allows you to download reference
genomes. Here are two examples using the BSgenome and biomartr packages.

```{r, eval=FALSE}

## First specify where to store all the fasta file
ref_path <- "/home/danis31/Desktop/Temp_docs/fasta"

###################################
####---- BSgenome ------------ ####
dest_path <- file.path(ref_path, "/uscs_genome/dm6_ucsc.fa")
BSgenome::available.genomes()
BiocInstaller::biocLite("BSgenome.Dmelanogaster.UCSC.dm6") # Only once
dm6 <- BSgenome::getBSgenome("BSgenome.Dmelanogaster.UCSC.dm6", masked=FALSE)
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
Biostrings::writeXStringSet(getSeq(dm6), filepath=dest_path, format="fasta")

``` 

```{r}
###################################
####---- biomartr ------------ ####
dest_path <- file.path(ref_path, "/biomartr_genome/") # Only dir
biomartr::is.genome.available(db = "ensembl", organism = "Drosophila melanogaster", details = TRUE)
file_path <- biomartr::getGenome(db="ensembl", organism = "Drosophila melanogaster", path=dest_path, gunzip=TRUE) # Bowtie don't take gzip
genome <- Biostrings::readDNAStringSet(filepath=list.files(dest_path, pattern=".fa$", full.names=TRUE), format="fasta")

``` 

<br>

Similar to full genomes, some specilized references may be available for direct
download using specific packages. Here is an example for ensembl ncRNA (animals)
using the biomartr package.

```{r}

###################################
####---- biomartr ncRNA ------ ####
dest_path <- file.path(ref_path, "/ensembl_ncRNA/") # Only dir
ncrna_path <- biomartr::getRNA(db="ensembl", organism = "Drosophila melanogaster", path=dest_path)
R.utils::gunzip(ncrna_path, destname=paste0(dest_path, "/ncrna.fa"), remove=TRUE, skip=TRUE) # Unzip to prepare for bowtie
ncrna <-  biomartr::read_rna(file = paste0(dest_path, "/ncrna.fa"))

```

Using the \code{download.file} function makes all urls (https/http/ftp etc)
available for download. Here an example for drosophila tRNA and miRNA
fasta:
```{r, eval=TRUE}

###################################
####---- Download GtRNAdb ---- ####
dest_path <- file.path(ref_path, "/GtRNAdb/trna.fa")
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
download.file(url="http://gtrnadb.ucsc.edu/genomes/eukaryota/Dmela6/dm6-tRNAs.fa", destfile=dest_path)
trna <- Biostrings::readDNAStringSet(filepath=dest_path, format="fasta")
```

```{r, eval=FALSE}
###################################
####---- Download mirbase ---- ####
# 1. Download pre-miRNA data
# 2. Extract compressed fasta
# 3. Read as RNA
# 4. Extract species D. melanogaster 
# 4. Convert to DNA
# 5. Overwrite RNA fasta with DNA fasta
# (sequenced reads are always in DNA)
# (we use pre-miRNA to catch all miRNA)
dest_path <- file.path(ref_path, "/mirbase/mirna.fa.gz")
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
download.file(url="ftp://mirbase.org/pub/mirbase/CURRENT/hairpin.fa.gz", destfile=dest_path)
R.utils::gunzip(dest_path, remove=TRUE, skip=TRUE)
mirna <- Biostrings::readRNAStringSet(filepath=gsub(".gz", "", dest_path), format="fasta")
mirna <- mirna[grepl("Drosophila melanogaster", names(mirna)),]
mirna <- Biostrings::DNAStringSet(mirna)
Biostrings::writeXStringSet(mirna, filepath=gsub(".gz", "", dest_path), format="fasta")

```

```{r, eval=TRUE}
###################################
####- Similar but MirGeneDB -- ####
# Since mirBase is no longer updated you might want to use MirGeneDB
dest_path <- file.path(ref_path, "/mirgenedb/mirna_pre_mirbase.fa.gz")
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
download.file(url="https://www.mirgenedb.org/static/data/dme/dme-pre.fas", destfile=dest_path)
mirna2 <- Biostrings::readRNAStringSet(filepath=dest_path, format="fasta")
mirna2 <- Biostrings::DNAStringSet(mirna2)
Biostrings::writeXStringSet(mirna2, filepath=dest_path, format="fasta")

## There are some overlaps 
table(paste0(mirna2) %in% paste0(mirna)) # Not much perfect overlap
table(grepl(paste(paste0(mirna2), collapse="|"), paste0(mirna))) # Non-perfect overlaps better 

``` 

<br>
Custom fasta files can also be used, and you can easily merge, add and remove
features to the database references by functions in the Biostrings package, such
as \code{readDNAStringSet}.


You may for some reason want to remove all haplotype or scaffold 'chromosomes'
from your top level reference genome.

```{r, eval=TRUE}
## Extract scaffold in genome files
file_path <- list.files(paste0(ref_path, "/biomartr_genome/"), pattern=".fa", full.names=TRUE)
genome <- Biostrings::readDNAStringSet(filepath=file_path[1], format="fasta")
chrom <- genome[!grepl("scaffold", names(genome)),] # Remove scaffolds
Biostrings::writeXStringSet(chrom, filepath=paste0(dirname(file_path), "/chromsomes.fa") , format="fasta")
scaff <- genome[!grepl("scaffold", names(genome)),] # Keep scaffolds
Biostrings::writeXStringSet(scaff, filepath=paste0(dirname(file_path), "/scaffolds.fa"), format="fasta")


``` 

As default, bowtie only reports the names up to the first white space. Sometime
the sequence names need to be rearranged for the bowtie aligner to best report
the names in the mapping output.  This can easily be done using the Biostrings
package:

```{r}
## Fixing the trna names
file_path <- paste0(ref_path, "/GtRNAdb/trna.fa")
trna <- Biostrings::readDNAStringSet(filepath=file_path, format="fasta")
names(trna) <- gsub("Drosophila_melanogaster_", "", names(trna)) # Remove species 
mat <- do.call("rbind", strsplit(names(trna), " ")) # Make a matrix the names 
names(trna) <-  paste(mat[,1], mat[,ncol(mat)-1], mat[,ncol(mat)], sep="_") # Save the important as one single string

``` 

You may also want to add tRNAs from the mitochrondrial genome to your
tRNA reference, which is not always provided in the GtRNAdb fasta. This can be
done by moving them from Ensembl ncRNA fasta or scan the mitochondrial genome
manually at [tRNAscan-SE](http://lowelab.ucsc.edu/tRNAscan-SE/). The
mitochonridal genome is found in the reference genome fasta.


```{r, eval=TRUE}
## Rearrange the ncRNA fasta names
file_path <- list.files(paste0(ref_path, "/ensembl_ncRNA/"), pattern=".fa", full.names=TRUE)
ncrna <- Biostrings::readDNAStringSet(filepath=file_path, format="fasta")
mat <- do.call("rbind", strsplit(names(ncrna), " ")) # Make a matrix the names
col_bio <- grepl("gene_biotype:", mat[1,])  # Locate gene biotype column
col_coord <- grepl("chromosome:", mat[1,])  # Locate coordinate column
new_names <- paste(mat[,ncol(mat)], mat[,1], mat[,col_bio], mat[,col_coord], sep="_") 
names(ncrna) <- gsub("gene_symbol:|chromosome:BDGP6.28:|gene_biotype:", "",  new_names) # Clean up
Biostrings::writeXStringSet(ncrna, filepath=file_path, format="fasta")

## Locate and add mito tRNA
trna_logi <- grepl("tRNA_mitochondrion_genome", names(ncrna)) # Locate mito tRNA
table(trna_logi)                                              # Should be 22
trna <- c(trna, ncrna[trna_logi,])
Biostrings::writeXStringSet(trna, filepath=paste0(ref_path, "/GtRNAdb/trna.fa"), format="fasta")

``` 


<br>

### 2.4.2 Indexing the fasta references 
Before we can use the fasta references we need to index them for bowtie mapping.
You can do this by using the \code{bowtie_build} function in the Rbowtie package
or by running bowtie externally, outside R. For more information see
?Rbowtie::bowtie, Rbowtie::bowtie_build_usage()
http://bowtie-bio.sourceforge.net/manual.shtml.

*Important*, the bowtie prefix must have the same basename (\code{prefix=}) and
the indexes must be saved in the same directory (\code{outdir=}) as the original
fasta file.

Building indexes may take some time for large fasta, such as a reference genome.
You only need to generate the index once for every fasta reference. Lets create
bowtie indexes for a few of the fasta references we downloaded:
```{r, eval = FALSE}

ref_path <- "/home/danis31/Desktop/Temp_docs/fasta"
Rbowtie::bowtie_build(paste0(ref_path, "/biomartr_genome/chromsomes.fa"), outdir=paste0(ref_path, "/biomartr_genome/"), prefix="chromosomes", force=TRUE)
Rbowtie::bowtie_build(paste0(ref_path, "/GtRNAdb/trna.fa"), outdir=paste0(ref_path, "/GtRNAdb/"), prefix="trna", force=TRUE)
Rbowtie::bowtie_build(paste0(ref_path, "/ensembl_ncRNA/ncrna.fa"), outdir=paste0(ref_path, "/ensembl_ncRNA/"), prefix="ncrna", force=TRUE)
Rbowtie::bowtie_build(paste0(ref_path, "/mirbase/mirna.fa"), outdir=paste0(ref_path, "/mirbase/"), prefix="mirna", force=TRUE)


``` 

<br>

### 2.4.3 GTF feature coordinates
After the sequences has been mapped against a reference genome they can also
aquire annotations from genomic feature files, such as the gtf and gff formates.
These files contains the coordinates for different genomic features associated
with a specific reference genome, such as repetitative regions, exons and CpG
islands etc. Some functions in seqpac will require gtf files. Thus it is
important to know how to handle them.

GTF files can often be aquired at the same places as the fasta reference files
(see above). The biomartr package also have functions for downloading some gtf
files and you can create your own by downloading different tables, for example
using rtracklayer. Here are some examples:

```{r, eval = FALSE}
## Get gene gtf using biomartr
dest_path <- file.path(ref_path, "/gtf/") # Only dir
gtf_path <- biomartr::getGTF(db="ensembl", organism = "Drosophila melanogaster", path=dest_path)
gtf <- data.table::setDT(rtracklayer::readGFF(gtf_path))

## Get repeatMasker gtf using biomartr (doesn't work for all species)
dest_path <- file.path(ref_path, "/repeatMasker/") # Only dir
rm_path <- biomartr::getRepeatMasker(db="refseq", organism = "Drosophila melanogaster", path=dest_path)
gtf <- data.table::setDT(rtracklayer::readGFF(gtf_path))

## Get repeatMasker table and manually turn it into gtf using rtracklayer
# Table names can be found at:
# https://genome.ucsc.edu/cgi-bin/hgTables
dest_path <- file.path(ref_path, "/repeatMasker/repeatMasker.gtf") # Full file path
session <- rtracklayer::browserSession("UCSC")
rtracklayer::genome(session) <- "dm6"
rm_tab <- data.table::setDT(rtracklayer::getTable(rtracklayer::ucscTableQuery(session, track="RepeatMasker", table="rmsk")))
gr <- GenomicRanges::GRanges(seqnames=rm_tab$genoName, IRanges(rm_tab$genoStart, rm_tab$genoEnd), strand=rm_tab$strand)
mcols(gr)$type <- "repeat"
mcols(gr)$source <- "repeatMasker_dm6"
mcols(gr)$exon_name <- rm_tab$repName
mcols(gr)$transcript_name <- rm_tab$repClass
mcols(gr)$gene_name <- rm_tab$repFamily  
rtracklayer::export(gr, dest_path, format="gtf")

``` 

<br>

### 2.4.4 The reannotation workflow
Here we present the details on how seqpac generates annotations you can skip
forward to the next section. There, user-friendly wrappers for generating
different kinds of annotations are presented.

The PAC reannotation family of functions carry out the following tasks:
- Mapping sequences against fasta references.
- Storing the output on hard drive.
- Importing specific parts into R.
- Reorganizing the import into a suitable table.
- Merging the table with an existing PAC$Anno table.

This is done by four functions map_reanno, import_reanno, make_reanno and
add_reanno.

<br>

**map_reanno**<br>
To accommodate most users on most platforms, seqpac provides two alternatives
for calling bowtie: internally from within R \code{type="internal"} or
externally from outside R (\code{type="external"}). In the internal mode, seqpac
uses the bowtie function in the Rbowtie package, while in the external mode
bowtie is called by a system command to a locally installed version of bowtie.
Both options gives identical results, but since the internal Rbowtie package is
rarely updated, we provide the external option.

Since the input commands for external bowtie and internal Rbowtie differs
slightly, map_reanno has two parse options (\code{parse_internal} and
\code{parse_external}). These can be used to control the two versions of bowtie
as if they were run from the console or command line, respectively.

While bowtie has its own way to handle mismatches in the alignments,
seqpac runs bowtie sequentially, increasing the number of mismatches for each
round. After each round all sequences that recieved a match in any of the
provided references will be subtracted. Therefore, in the next round only
sequences without a match will be reapplied but allowing one additional
mismatch. The map_reanno function controls this by sequentially increasing the
the number of mismatches after substracting the matches.

<br>

**import_reanno**<br>
This is the function that is called by \code{map_reanno} to import the bowtie
results after each sequential run. If you would run \code{import_reanno}
seperatly it simply provides you with options on how to import bowtie results
into R. For example, when aligning against a reference genome the mapping
coordinates is important, while mapping against other references 'hit' or 'no
hit' might be enough, and will be a much faster option.

<br>

**make_reanno**<br>
This function will search for the Full_reanno_mis0/1/2/3/4/5.Rdata files that were generated by
\code{map_reanno} and extract annotations in a format that fits the Anno table
in a PAC object.

**add_reanno**<br>


Lets observe the fucntions in action:

```{r}
library(seqpac)
load(system.file("extdata", "drosophila_sRNA_pac.Rdata", package = "seqpac", mustWork = TRUE))
##########################################
### Genome mapping using internal bowtie
##----------------------------------------
ref_paths <- list(genome="/home/danis31/Desktop/Temp_docs/fasta/biomartr_genome/chromosomes.fa")
outpath_genome <- "/home/danis31/Desktop/Temp_docs/reanno_genome"
import <- list(coord=TRUE, report="full", reduce=NULL)

map_reanno(PAC=pac_master, ref_paths=ref_paths, output_path=outpath_genome, 
            type="internal", mismatches=3, import=import, threads=8)

##########################################
### sRNA mapping using external bowtie
## (will also work with type="internal")
##----------------------------------------
# Paths to indexed fasta files as list
ref_paths <- list(miRNA="/home/danis31/Desktop/Temp_docs/fasta/mirbase/mirna.fa",
                   Ensembl="/home/danis31/Desktop/Temp_docs/fasta/ensembl_ncRNA/ncrna.fa",
                   tRNA="/home/danis31/Desktop/Temp_docs/fasta/GtRNAdb/trna.fa")
outpath_srna <- "/home/danis31/Desktop/Temp_docs/reanno_srna"
import <- list(coord=FALSE, report="full", reduce=NULL)

map_reanno(pac_master, ref_paths=ref_paths, output_path=outpath_srna, 
            type="external", mismatches=3,  import=import, threads=8)


##########################################
### Running make_reanno 
##----------------------------------------
anno_genome <- make_reanno(outpath_genome, PAC=pac_master, mis_fasta_check = TRUE, threads=8)
anno_srna <- make_reanno(outpath_srna, PAC=pac_master, mis_fasta_check = TRUE, threads=8)

ls.str(anno_genome)
ls.str(anno_srna)

pie(table(anno_genome$Overview$genome))
pie(table(anno_srna$Overview$Any_hit))


##########################################
### Running add_reanno 
##----------------------------------------


!!!!!!!!! HÄR ÄR JAG



bio_search = list(
anno_genome <-add_reanno(anno_genome, mismatches = 0, threads=8)


``` 



generate annotations in seqpac is easy.

PAC_genome 




<!-- ### 2.3.6 Differential Expression In RNA-sequencing it is common to look for -->
<!-- differnetially expressed transcripts and there are several ways to study this. -->
<!-- In addition to RPM, seqpac offers a function integrating DESeq2 differential -->
<!-- expression with the PAC dataset, PAC_deseq. DESeq2 uses a negative binomial -->
<!-- generailzed linear model to find differentially expressed transcripts in the -->
<!-- data. When running PAC_deseq, it is important to formulate a correct model. For -->
<!-- more information about designs and DESeq2 in general, please see -->
<!-- https://github.com/mikelove/DESeq2 . -->
<!-- ```{r} -->
<!-- model= ~Tissue+Exp pac_deseq <- PAC_deseq(pac_rpm_filt, model=model, -->
<!-- main_factor="Testis", norm=TRUE, histogram=TRUE, threads=4, pheno_target=NULL, -->
<!-- anno_target=NULL) -->
<!-- ``` -->
<!-- ### 2.3.7 Plotting Data seqpac offers several ways to plot your data. -->
<!-- -PAC_covplot -PAC_jitter -PAC_pie -PAC_stackbar -PAC_sizedist -->
<!-- <br> Lets generate a few normalized count tables and compare them: ```{r, -->
<!-- fig.width = 6, fig.height = 3} -->
<!-- ###--------------------------------------------------------------------- ## -->
<!-- Since the example pac_master is small to begin with we use this as start: ## -->
<!-- (You may wish to use a low-filtered PAC for normalization to get rid of noise) -->
<!-- pac_rpm <- PAC_norm(pac_master, type="rpm")                 # Returned as a -->
<!-- dataframe in the PAC$norm folder df_vst <- PAC_norm(pac_master, type="vst", -->
<!-- PAC_merge=FALSE) # Returned as a dataframe df_rlog <- PAC_norm(pac_master, -->
<!-- type="rlog", PAC_merge=FALSE) -->
<!-- cowplot::plot_grid(nrow=1, ncol=2, -->
<!-- ggplot2::ggplot(data.frame(log2_mean_rpm=log2(rowMeans(pac_rpm$norm$rpm)), -->
<!-- mean_vst=rowMeans(df_vst)), aes(x=log2_mean_rpm, y=mean_vst)) + geom_point(), -->
<!-- ggplot2::ggplot(data.frame(log2_mean_rpm=log2(rowMeans(pac_rpm$norm$rpm)), -->
<!-- mean_rlog=rowMeans(df_rlog)), aes(x=log2_mean_rpm, y=mean_rlog)) + geom_point()) -->
<!-- ``` -->
<!-- <br> As you probably noticed we only stored the rpm values in the PAC. Lets now -->
<!-- apply a deeper filter that are based on rpm thresholds: -->
<!-- ```{r} ###--------------------------------------------------------------------- -->
<!-- ## Extracts all sequences with >=10 counts in 100% of samples within each -->
<!-- category of the 'type' column in Pheno. filtsep <- PAC_filtsep(pac_rpm, -->
<!-- type="rpm", threshold=10, coverage=100, pheno_target= list("type")) -->
<!-- pac_hifilt <- PAC_filter(pac_rpm, subset_only = TRUE, anno_target= -->
<!-- unique(do.call("c", as.list(filtsep)))) -->
<!-- PAC_check(pac_hifilt) -->
<!-- ls.str(pac_hifilt) ``` -->
<!-- <br> -->
<!-- ## 2.5 Data Visualization One excellent tool for studying the structure of the -->
<!-- data is to study the relationship of its principal components. This can be done -->
<!-- with a PCA plot, where the distance of datapoints are calculated and presented -->
<!-- in a figure. A principal component analysis (PCA) can only show how the data -->
<!-- relates to one another, not why it behaves this way. To produce a PCA plot with -->
<!-- seqpac, use PAC_pca: -->


