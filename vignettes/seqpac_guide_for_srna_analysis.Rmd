---
title: "seqpac - Guide for sRNA analysis"
author: "Daniel NÃ¤tt"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{seqpac - Guide for sRNA analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
## 1.1 Introduction

Seqpac contains a complete toolbox for the analysis of short sequenced reads.
The package was originally developed for small RNA (sRNA) analysis, but can be
applied on any type of data generated by large scale nucleotide sequencing,
where the user wish to maintain sequence integrity during the whole analysis.
This involves, for example, regular RNA-seq with long RNA.

To perserve sequence integrity, seqpac applies sequence-based counting. This can
be contrasted against feature-based counting, where reads are counted over known
genomic features, such a protein coding gene or sRNA. This will result in a
count table where a count is made per feature (e.g. number of read counts
mapping to a gene). In seqpac, such annotations are initially disregarded, as a
count table is generated solely by counting unique sequences in the raw sequence
files. Annotation against known refereces (such as databases containing miRNA,
tRNA, or protein coding genes) are done after the count table has been
generated.

The big advantage of using sequence-based counting, compared to feature-based
counting, is that mismatches in the classification of reads, can be applied
anytime during the analysis. In feature-based counting, allowing a mismatch in
the mapping will result in a loss of information (loss of sequence integrity).

For example, say that you have 506 read counts for miR-185 (a miRNA) when
allowing 3 mismatches against the reference. In feature-based analysis this will
result in 1 entry in the count table. Unless you have saved the the exact
alignments elsewhere, you have lost the information about what sequences that
are included in that count. The only thing you know is that the sequence may
differ from the reference sequence by any 3 mismaches. In sequence-based
counting, reads are counted as unique sequences and each unique sequence is
then mapped againts the target reference databases. Information about whether a
sequence was mapped against a reference is maintained in a linked annotation
table that can contain both perfect alignments and alignments allowing
mismatches. Thus, in any stage of the analysis mismatches and classification into
features can be dynamically controlled, meaning that you can easily observe the
effect of allowing mismatches and changes in hierarchical classifications (often
applied in sRNA analysis when a sequence align with multiple classes of sRNA).


## 1.2 The seqpac workflow
The input file format for seqpac is .fastq, which can be generated from most
sequencing platforms. Two types of objects sustain the core of the seqpac
workflow:

    The PAC object 
    The Targeting objects


The PAC object stores the Phenotypic information (P), Annotations (A) and Counts
(C) needed for all downstream analysis, while the targeting object is used for
accessing specific subsets of data within the PAC object. To keep things simple,
both of these objects are lists. The PAC object is in its simplest form a list of 3
dataframes (P, A and C), while the Targeting object is a list of 2 character
vectors.

The workflow is roughly divided into three steps: 

    i. Generate a PAC object from fastq-files
    ii. Preprocess the PAC object
    iii. Annotate the PAC object
    iv. Analyze the PAC object.


# 2 Running the seqpac workflow 

## 2.1 Example dataset

Contained within this package are six example fastq files. These files were
originally generated from extracting sRNA from fruit fly ovaries and sperm
(three each). The files were downsampled from original fastq-files aquired by
Illumina NextSeq 500 sequencer using a High Output 75 cycles flowcell (product
no: 20024906). 

## 2.2 Generate a PAC object from fastq-files

### 2.2.1 make_counts
The first step depends on two external softwares, cutadapt and
fastq_quality_filter, which will trim the adapter sequence and remove low
quality reads prior of making a count table (C).

Important, cutadapt (stand alone) and fastq_quality_filter (part of FASTX-Toolkit) are only
available on Linux: 
    https://cutadapt.readthedocs.io/en/stable/installation.html
    http://hannonlab.cshl.edu/fastx_toolkit/commandline.html
    
<br>
For convenience we provide an aready trimmed and quality filtered count table here:
```{r}
library(seqpac)
load(system.file("extdata", "drosophila_sRNA_counts.Rdata", package = "seqpac", mustWork = TRUE))
```

<br>
For linux users with all dependencies installed:
```{r, eval = FALSE}
###--------------------------------------------------------------------- 
# Generate counts using setting path to fastq files and parse commands to cutadapt
# (Note, the cutadapt parse argument is specifcly designed for sRNA trimming
# with a NebNext smallRNA Library Prep Set For Illumina (E7330) adapter.) 
path_to_fastq <- system.file("extdata", package = "seqpac", mustWork = TRUE)

parse_to_cutadapt <- "cutadapt -j 1 -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCACAT --discard-untrimmed --nextseq-trim=20 -O 5 -m 5"

counts <- make_counts(path_to_fastq, type="fastq", threads=4, cutadpt=TRUE, parse=parse_to_cutadapt)

```

Note that *counts* contains both a count table and the logs generated by
cutadapt/fastq_quality_filter. For other platforms, you may load already trimmed
and quality filtered fastq files by setting `cutadapt=FALSE`.

Also note that seqpac uses an intital noise filter. The `make_counts` function
will remove sequences that fail to appear in two independent fastq files. In
most studies, this will only remove noise since it is questionable if sequences
with evidence from only one single sample truly exists and should be analyzed
together with sequences that have better evidence. As seqpac focuses on group
analysis evidence from at least two independent samples, this is a minimum inclusion
criteria.

### 2.2.2 make_anno
Next, generate a simple Anno table (A):
```{r, results = "hide"}
###--------------------------------------------------------------------- 
## Generate a annotation table from the counts table 
anno <- make_anno(input=counts$counts, type="counts")

```


<br>
### 2.2.3 make_pheno
Now, generate a Pheno table (P) and add a report from the logs in *counts*. 
The Pheno table contains sample specific information such as sample name and possible interventions,
with each sample as a row. Pheno may be added manually (see ?make_pheno), or produced autoamtically,
such as in this case: 
```{r, results = "hide"}
###--------------------------------------------------------------------- 
## Generate a progress report from the cutadapt/fastq_quality_filter logs in counts
prog <- progress_report(counts)
```
```{r, results = "hide"}
###--------------------------------------------------------------------- 
## Generate Pheno table from file names and add report
path_to_fastq <- system.file("extdata", package = "seqpac")
pheno <- as.data.frame(do.call("rbind", strsplit(list.files(path_to_fastq, pattern="*.fastq.gz"), "_|\\."))[,c(2,4,5)]) 
colnames(pheno) <- c("sample", "type", "replicate"); rownames(pheno) <- colnames(counts$counts)
pheno <- make_pheno(pheno_input=pheno, progress_report=prog, counts=counts$counts)

```

### 2.2.4 make_PAC
<br>
Finally, put everything together as a master PAC object:
```{r}
###--------------------------------------------------------------------- 
## Generate PAC object
pac_master <- make_PAC(pheno_input=pheno, anno_input=anno, counts_input=counts$counts)
names(pac_master)

## If TRUE the PAC object is ok 
PAC_check(pac_master)
```

<br>
## 2.3 Preprocess the PAC object

### 2.3.1 Targeting objects
Seqpac uses a simple targeting system for dividing and focusing the analysis of
a PAC object to certain sample groups (Pheno) or specific sequences (Anno). If
not specified otherwise in the function help, a targeting object is always a
two item list, where the first object is a column name and the second object tells
the function which categories in that column that should be targeted. 

    pheno_target: extracts sample groups from a column in PAC$Pheno
    anno_target: extracts sequences from a column in PAC$Anno

While pheno_target and anno_target are the most common targeting objects, there 
are other targeting object. Common for all is that they target
a specific subtable stored in PAC.

<br>
For example, extracting the first columns in Pheno table and the first lines of the
Anno table found in master PAC object that was generated in 2.2.3 would be implemented
as such:

```{r}
pac_master$Pheno[,1:3]
head(pac_master$Anno)

```

A pheno_target object that will target replicate 1 and 2 would look like this:
`pheno_target=list("replicate", c("test1", "test2"))`

While an anno_target that will target sequences of 22 nt in length would look like this:
`anno_target=list("Length", "22")`

Notice that both target objects are a list of two character vectors, one
targeting a specific column and one targeting specific groups within that
column.

Important, if the second object is set to NULL or is empty this will
automatically target all samples in a given column. If the anno_target is a
character vector (not a list) some function will attempt to extract matches in the
rownames of either Pheno or Anno (see example with `PAC_filtsep` below).


### 2.3.2 Filtering
A master PAC object will contain sequences in your original fastq files that
passed the cutadapt/quality filters and have at least two evidence in two
independent samples. Now, in most analysis this still involves millions of
unique sequences, making the master PAC difficult to work with. Thus it is often
wise to further reduce noise prior to normalization and annotation.

Seqpac contains two functions for this purpose:

    PAC_filter
    PAC_filtsep

While `PAC_filter` gives a variety of choices to subset the PAC file according
to for example sequence size or minimum counts in a certain proportion of the
samples.`PAC_filtsep` extracts lists of top.

Here are some examples:
```{r}
###--------------------------------------------------------------------- 
## Extracts all sequences between 5-80 nt in length with at least 5 counts in 20% of all samples. 
pac_lowfilt <- PAC_filter(pac_master, size=c(10,80), threshold=5, coverage=20, type="counts",  
                          pheno_target=NULL, anno_target=NULL)

###--------------------------------------------------------------------- 
## Extracts all sequences with 22 nt size and the samples test1 and test2 replicates. 
pac_subset <- PAC_filter(pac_master, subset_only = TRUE,
                         pheno_target=list("replicate", c("test1", "test2")), 
                         anno_target=list("Length", "22"))

###--------------------------------------------------------------------- 
## Extracts all sequences with >=10 counts in 100% of samples within each category of the 'type' column in Pheno.
filtsep <- PAC_filtsep(pac_master, type="counts", threshold=10, coverage=100, pheno_target= list("type"))

pac_filt <- PAC_filter(pac_master, subset_only = TRUE,
                       anno_target= unique(do.call("c", as.list(filtsep))))
                       
                      

```

Notice that PAC_filtsep only extracts the sequence names and store them in a
dataframe. Converted into a character vector with unique names (using `unique` +
`do.call`) they can be applied as an anno_target that targets sequence names in
Anno. 

Hint, the dataframe output of PAC_filtsep has been designed for the purpose of
generating Venn diagrams that visualize top overlaps across groups:
```{r}
olap <- reshape2::melt(filtsep, measure.vars = c("Ovaries", "Sperm"), na.rm=TRUE)
plot(venneuler::venneuler(data.frame(olap[,2], olap[,1])))

```

### 2.3.3 Storage of processed data in PAC
While the master PAC only contains three different dataframe objects (P, A and
C), additional 'folders' will be stored in the PAC object as the analysis progresses. In
fact, you may choose to store any number of objects in your PAC as long as they
do not conflict with the names of the standard folders which are:

    Pheno (P):   dataframe
    Anno (A):    dataframe
    Counts (C):   dataframe
    norm:        list of dataframes
    summary:     list of dataframes

The *norm* folder will be used to store Counts that have been normalized in
different ways, while the *summary* folder will contain the data that has been
summerized across groups of samples. In both cases, applying a filter using
`PAC_filter` will automatically subset not only P, A, and C, but also all tables
stored in *norm* and *summary*.


### 2.3.4 Normalization
The built in normalization methods in seqpac are handled by the `PAC_norm`
function. In the current version only three methods are available: 

    1. Reads Per Million (rpm) 
    2. Variance-Stabalizing Transformation (vst)
    3. Regularized log Transformation (rlog)

Nonetheless, it is easy to generate your own normalized count table using your
method of choice, and import it as a dataframe to the *norm* folder in the PAC
object. Just remember that row and column names must be identical to the original Counts
table. Use `PAC_check` to verify that this is the case.

More specifically, rpm normalize the dataset according to the total number of reads, while vst 
uses both mean dispersion and size factor to produce homoskedastic values with functions avalable in the DESeq2 package. 


It is easy to generate your own normalized count table using your
method of choice, and import it as a dataframe to the *norm* folder in the PAC
object. Just remember that row and column names must be identical to the
original Counts table. Use `PAC_check` to verify that this is the case.

Lets generate two normalized count tables with rpm and vst:
```{r}
# Since pac_master is small to begin with we use thi

pac_rpm <- PAC_norm(pac_master, type="rpm")
pac_vst <- PAC_norm(pac_master, type="vst")

``` 

From this, it may be wise to run a further filtering step to remove reads with low 
RPM values. 

```{r}

pac_rpm_filter <- PAC_filter(pac_rpm, type="rpm", threshold = 10, coverage = 100)

``` 

### 2.3.5 Data Visualization
One excellent tool for studying the structure of the data is to study the relationship
of its principal components. This can be done with a PCA plot, where the distance of
datapoints are calculated and presented in a figure. A principal component analysis (PCA)
can only show how the data relates to one another, not why it behaves this way.
To produce a PCA plot with seqpac, use PAC_pca:

```{r}

pca_all_cnt <- PAC_pca(pac_rpm_filter, type="counts")
pca_all_rpm <- PAC_pca(pac_rpm_filter, type="rpm")

``` 

### 2.3.6 Differential Expression
In RNA-sequencing it is common to look for differnetially expressed transcripts and there
are several ways to study this. In addition to RPM, seqpac offers a function integrating
DESeq2 differential expression with the PAC dataset, PAC_deseq. DESeq2 uses a negative
binomial generailzed linear model to find differentially expressed transcripts in the data.
When running PAC_deseq, it is important to formulate a correct model. For more information
about designs and DESeq2 in general, please see https://github.com/mikelove/DESeq2 .

```{r}
 
model= ~Tissue+Exp
pac_deseq <- PAC_deseq(pac_rpm_filter, model=model, main_factor="Testis", norm=TRUE, histogram=TRUE, threads=4, pheno_target=NULL, anno_target=NULL)


``` 

### 2.3.7 Plotting Data
seqpac offers several ways to plot your data. 

-PAC_covplot
-PAC_jitter
-PAC_pie
-PAC_stackbar
-PAC_sizedist


<br>
Lets generate a few normalized count tables and compare them:
```{r, fig.width = 6, fig.height = 3}
###--------------------------------------------------------------------- 
## Since the example pac_master is small to begin with we use this as start:
## (You may wish to use a low-filtered PAC for normalization to get rid of noise)

pac_rpm <- PAC_norm(pac_master, type="rpm")                 # Returned as a dataframe in the PAC$norm folder
df_vst <- PAC_norm(pac_master, type="vst", PAC_merge=FALSE) # Returned as a dataframe 
df_rlog <- PAC_norm(pac_master, type="rlog", PAC_merge=FALSE) 

cowplot::plot_grid(nrow=1, ncol=2,
            ggplot2::ggplot(data.frame(log2_mean_rpm=log2(rowMeans(pac_rpm$norm$rpm)), mean_vst=rowMeans(df_vst)), aes(x=log2_mean_rpm, y=mean_vst)) + geom_point(),
            ggplot2::ggplot(data.frame(log2_mean_rpm=log2(rowMeans(pac_rpm$norm$rpm)), mean_rlog=rowMeans(df_rlog)), aes(x=log2_mean_rpm, y=mean_rlog)) + geom_point())

```

<br>
As you probably noticed we only stored the rpm values in the PAC. Lets now apply
a deeper filter that are based on rpm thresholds:

```{r}
###--------------------------------------------------------------------- 
## Extracts all sequences with >=10 counts in 100% of samples within each category of the 'type' column in Pheno.
filtsep <- PAC_filtsep(pac_rpm, type="rpm", threshold=10, coverage=100, pheno_target= list("type"))

pac_hifilt <- PAC_filter(pac_rpm, subset_only = TRUE,
                       anno_target= unique(do.call("c", as.list(filtsep))))

PAC_check(pac_hifilt)

ls.str(pac_hifilt)
```

<br>
## 2.4 Annotation
So far we have not bothered about what type of RNA species (or biotype) that we have in our data, but have   
