---
title: "seqpac - Guide for sRNA analysis"
author: "Daniel Nätt"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{seqpac - Guide for sRNA analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
<br>
<br>

---

## 1.1 Introduction

Seqpac contains a complete toolbox for the analysis of short sequenced reads.
The package was originally developed for small RNA (sRNA) analysis, but can be
applied on any type of data generated by large scale nucleotide sequencing,
where the user wish to maintain sequence integrity during the whole analysis.
This involves, for example, regular RNA-seq with long RNA.

To perserve sequence integrity, seqpac applies sequence-based counting. This can
be contrasted against feature-based counting, where reads are counted over known
genomic features, such a protein coding genes or sRNA. This will result in a
count table where a count is made per feature (e.g. number of read counts
mapping to a gene). In seqpac, such annotations are initially disregarded, as a
count table is generated solely by counting unique sequences in the raw sequence
files. Annotation against known refereces (such as databases containing
sequences of full genomes, miRNA, tRNA, protein coding genes, or genomic
coordinates of such features) are done after the count table has been generated.

The big advantage of using sequence-based counting, compared to feature-based
counting, is that mismatches in the classification of reads, can be applied
anytime during the analysis. In feature-based counting, allowing a mismatch in
the mapping will result in a loss of information (loss of sequence integrity).

For example, say that you have 506 read counts for miR-185 (a miRNA) when
allowing 3 mismatches against the reference. In feature-based analysis this will
result in 1 entry in the count table. Unless you have saved the exact alignments
elsewhere, you have lost the information about what sequences that are included
in that count. The only thing you know is that the sequence may differ from the
reference sequence by any 3 mismaches. In sequence-based counting, reads are
counted as unique sequences and each unique sequence is then mapped againts the
target reference databases. Information about whether a sequence was mapped
against a reference is maintained in a linked annotation table that can contain
both perfect alignments and alignments allowing mismatches. Thus, in any stage
of the analysis mismatches and classifications into features can be dynamically
controlled, meaning that you can easily observe the effect of for example
allowing more mismatches or changes in hierarchical classifications (often
applied in sRNA analysis when a sequence align with multiple classes of sRNA).


## 1.2 The seqpac workflow
The input file format for seqpac is .fastq, which can be generated from most
sequencing platforms. Two types of objects sustain the core of the seqpac
workflow:

- The PAC object 
- The Targeting objects


The PAC object stores the Phenotypic information (P), Annotations (A) and Counts
(C) needed for all downstream analysis, while the targeting object is used for
accessing specific subsets of data within the PAC object. To keep things simple,
both of these objects are lists. The PAC object is in its simplest form a list of 3
dataframes (P, A and C), while the Targeting object is a list of 2 character
vectors.

The workflow is roughly divided into four steps: 

- Generate a PAC object from fastq-files
- Preprocess the PAC object
- Annotate the PAC object
- Analyze the PAC object.

<br>
<br>

---

# 2 Running the seqpac workflow 

## 2.1 Example dataset

Contained within this package are six example fastq files. These files were
originally generated from extracting sRNA from fruit fly ovaries and sperm
(three each). The files were downsampled from two original fastq-files aquired
by Illumina NextSeq 500 sequencer using a High Output 75 cycles flowcell
(product no: 20024906) and NEBNext® Small RNA Library Prep Set for Illumina
(E7330).

## 2.2 Generating a count table
There are four ways of generating a count table in seqpac.

    1. Trimming raw fastq files using internal functions in seqpac/R.
    2. Trimming raw fastq files using external functions outside R.
    3. Importing reads from already trimmed fastq files.
    4. Importing sequence counts from Sports. 

Two involves adaptor trimming, while the two involves importing already trimmed
reads. All are contained within the \code{make_counts} function.

### 2.2.1 Internal trimming
Generating a count table from untrimmed fastq files using nothing but R packages
(internal) depends on the \code{make_trim} function. This function goes through
a series of trimming cycles using the \code{trimLRPatterns} function in
\package{Biostrings} package to generate highly comparable adaptor trimming as
generated by popular fastq trimming softwares, such as cutadapt. This combined
with the parallell capabilities of the \package{foreach} package makes
\code{make_trim} one of very few choices for adaptor trimming in R.

When \code{make_trim} is used on its own it results in trimmed fastq files
stored at a user defined location. When trimming="seqpac" is set in the
\code{make_counts} function, this function parses settings to the
\code{make_trim} to generate a count table from temporarly stored trimmed fastq
files.

Lets have a try using the example dataset:
```{r}
library(seqpac)


## Using default settings for NEB type adaptor 
# NEB=New England Biolabs: NEBNext® Small RNA Library Prep Set for Illumina (E7300/E7330)
# For 
path_to_fastq <- system.file("extdata", package = "seqpac", mustWork = TRUE)
make_counts(input=path_to_fastq, type = "fastq", trimming="seqpac", parse=

```



### 2.2.2 External trimming


### 2.2.2 make_trim


The first step depends on two external softwares, cutadapt and
fastq_quality_filter, which will trim the adapter sequence and remove low
quality reads prior of making a count table (C).

Important, cutadapt (stand alone) and fastq_quality_filter (part of FASTX-Toolkit) are only
available on Linux: 
    https://cutadapt.readthedocs.io/en/stable/installation.html
    http://hannonlab.cshl.edu/fastx_toolkit/commandline.html
    
<br>
For convenience we provide an aready trimmed and quality filtered count table here:
```{r}
library(seqpac)
load(system.file("extdata", "drosophila_sRNA_counts.Rdata", package = "seqpac", mustWork = TRUE))
```

<br>
For linux users with all dependencies installed:
```{r, eval = FALSE}
###--------------------------------------------------------------------- 
# Generate counts using setting path to fastq files and parse commands to cutadapt
# (Note, the cutadapt parse argument is specifcly designed for sRNA trimming
# with a NebNext smallRNA Library Prep Set For Illumina (E7330) adapter.) 
path_to_fastq <- system.file("extdata", package = "seqpac", mustWork = TRUE)

parse_to_cutadapt <- "cutadapt -j 1 -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCACAT --discard-untrimmed --nextseq-trim=20 -O 5 -m 5"

counts <- make_counts(path_to_fastq, type="fastq", threads=4, cutadpt=TRUE, parse=parse_to_cutadapt)

y```

Note that *counts* contains both a count table and the logs generated by
cutadapt/fastq_quality_filter. For other platforms, you may load already trimmed
and quality filtered fastq files by setting `cutadapt=FALSE`.

Also note that seqpac uses an intital noise filter. The `make_counts` function
will remove sequences that fail to appear in two independent fastq files. In
most studies, this will only remove noise since it is questionable if sequences
with evidence from only one single sample truly exists and should be analyzed
together with sequences that have better evidence. As seqpac focuses on group
analysis evidence from at least two independent samples, this is a minimum inclusion
criteria.

### 2.2.2 make_anno
Next, generate a simple Anno table (A):
```{r, results = "hide"}
###--------------------------------------------------------------------- 
## Generate a annotation table from the counts table 
anno <- make_anno(input=counts$counts, type="counts")

```


<br>

### 2.2.3 make_pheno
Now, generate a Pheno table (P) and add a report from the logs in *counts*. 
The Pheno table contains sample specific information such as sample name and possible interventions,
with each sample as a row. Pheno may be added manually (see ?make_pheno), or produced autoamtically,
such as in this case: 
```{r, results = "hide"}
###--------------------------------------------------------------------- 
## Generate a progress report from the cutadapt/fastq_quality_filter logs in counts
prog <- progress_report(counts)
```
```{r, results = "hide"}
###--------------------------------------------------------------------- 
## Generate Pheno table from file names and add report
path_to_fastq <- system.file("extdata", package = "seqpac")
pheno <- as.data.frame(do.call("rbind", strsplit(list.files(path_to_fastq, pattern="*.fastq.gz"), "_|\\."))[,c(2,4,5)]) 
colnames(pheno) <- c("sample", "type", "replicate"); rownames(pheno) <- colnames(counts$counts)
pheno <- make_pheno(pheno_input=pheno, progress_report=prog, counts=counts$counts)

```

### 2.2.4 make_PAC
<br>
Finally, put everything together as a master PAC object:
```{r}
###--------------------------------------------------------------------- 
## Generate PAC object
pac_master <- make_PAC(pheno_input=pheno, anno_input=anno, counts_input=counts$counts)
names(pac_master)

## If TRUE the PAC object is ok 
PAC_check(pac_master)
```

<br>

## 2.3 Preprocess the PAC object

### 2.3.1 Targeting objects
Seqpac uses a simple targeting system for dividing and focusing the analysis of
a PAC object to certain sample groups (Pheno) or specific sequences (Anno). If
not specified otherwise in the function help, a targeting object is always a
two item list, where the first object is a column name and the second object tells
the function which categories in that column that should be targeted. 

    pheno_target: extracts sample groups from a column in PAC$Pheno
    anno_target: extracts sequences from a column in PAC$Anno

While pheno_target and anno_target are the most common targeting objects, there 
are other targeting object. Common for all is that they target
a specific subtable stored in PAC.

<br>
For example, extracting the first columns in Pheno table and the first lines of the
Anno table found in master PAC object that was generated in 2.2.3 would be implemented
as such:

```{r}
pac_master$Pheno[,1:3]
head(pac_master$Anno)

```

A pheno_target object that will target replicate 1 and 2 would look like this:
`pheno_target=list("replicate", c("test1", "test2"))`

While an anno_target that will target sequences of 22 nt in length would look like this:
`anno_target=list("Length", "22")`

Notice that both target objects are a list of two character vectors, one
targeting a specific column and one targeting specific groups within that
column.

Important, if the second object is set to NULL or is empty this will
automatically target all samples in a given column. If the anno_target is a
character vector (not a list) some function will attempt to extract matches in the
rownames of either Pheno or Anno (see example with `PAC_filtsep` below).


### 2.3.2 Filtering
A master PAC object will contain sequences in your original fastq files that
passed the cutadapt/quality filters and have at least two evidence in two
independent samples. Now, in most analysis this still involves millions of
unique sequences, making the master PAC difficult to work with. Thus it is often
wise to further reduce noise prior to normalization and annotation.

Seqpac contains two functions for this purpose:

    PAC_filter
    PAC_filtsep

While `PAC_filter` gives a variety of choices to subset the PAC file according
to for example sequence size or minimum counts in a certain proportion of the
samples.`PAC_filtsep` extracts lists of top.

Here are some examples:
```{r}
###--------------------------------------------------------------------- 
## Extracts all sequences between 5-80 nt in length with at least 5 counts in 20% of all samples. 
pac_lowfilt <- PAC_filter(pac_master, size=c(10,80), threshold=5, coverage=20, type="counts",  
                          pheno_target=NULL, anno_target=NULL)

###--------------------------------------------------------------------- 
## Extracts all sequences with 22 nt size and the samples test1 and test2 replicates. 
pac_subset <- PAC_filter(pac_master, subset_only = TRUE,
                         pheno_target=list("replicate", c("test1", "test2")), 
                         anno_target=list("Length", "22"))

###--------------------------------------------------------------------- 
## Extracts all sequences with >=10 counts in 100% of samples within each category of the 'type' column in Pheno.
filtsep <- PAC_filtsep(pac_master, type="counts", threshold=10, coverage=100, pheno_target= list("type"))

pac_filt <- PAC_filter(pac_master, subset_only = TRUE,
                       anno_target= unique(do.call("c", as.list(filtsep))))
                       
                      

```

Notice that PAC_filtsep only extracts the sequence names and store them in a
dataframe. Converted into a character vector with unique names (using `unique` +
`do.call`) they can be applied as an anno_target that targets sequence names in
Anno. 

Hint, the dataframe output of PAC_filtsep has been designed for the purpose of
generating Venn diagrams that visualize top overlaps across groups:
```{r}
olap <- reshape2::melt(filtsep, measure.vars = c("Ovaries", "Sperm"), na.rm=TRUE)
plot(venneuler::venneuler(data.frame(olap[,2], olap[,1])))

```

### 2.3.3 Storage of processed data in PAC
While the master PAC only contains three different dataframe objects (P, A and
C), additional 'folders' will be stored in the PAC object as the analysis progresses. In
fact, you may choose to store any number of objects in your PAC as long as they
do not conflict with the names of the standard folders which are:

    Pheno (P):   dataframe
    Anno (A):    dataframe
    Counts (C):   dataframe
    norm:        list of dataframes
    summary:     list of dataframes

The *norm* folder will be used to store Counts that have been normalized in
different ways, while the *summary* folder will contain the data that has been
summerized across groups of samples. In both cases, applying a filter using
`PAC_filter` will automatically subset not only P, A, and C, but also all tables
stored in *norm* and *summary*.


### 2.3.4 Normalization
The built in normalization methods in seqpac are handled by the `PAC_norm`
function. In the current version only three methods are available: 

    1. Reads Per Million (rpm) 
    2. Variance-Stabalizing Transformation (vst)
    3. Regularized log Transformation (rlog)

Nonetheless, it is easy to generate your own normalized count table using your
method of choice, and import it as a dataframe to the *norm* folder in the PAC
object. Just remember that row and column names must be identical to the original Counts
table. Use `PAC_check` to verify that this is the case.

More specifically, rpm normalize the dataset according to the total number of reads, while vst 
uses both mean dispersion and size factor to produce homoskedastic values with functions avalable in the DESeq2 package. 


It is easy to generate your own normalized count table using your
method of choice, and import it as a dataframe to the *norm* folder in the PAC
object. Just remember that row and column names must be identical to the
original Counts table. Use `PAC_check` to verify that this is the case.

Lets generate two normalized count tables with rpm and vst:
```{r}
# Since pac_master is small to begin with we use thi

pac_rpm <- PAC_norm(pac_master, type="rpm")
pac_vst <- PAC_norm(pac_master, type="vst")

``` 

From this, it may be wise to run a further filtering step to remove reads with low 
RPM values. 

```{r}

pac_rpm_filt <- PAC_filter(pac_rpm, type="rpm", threshold = 10, coverage = 100)

``` 



## 2.4 Generate annotations
From the start a PAC object only contains a very limited Anno table.

```{r}

library(seqpac)
load(system.file("extdata", "drosophila_sRNA_pac.Rdata", package = "seqpac", mustWork = TRUE))
head(pac_master$Anno)

``` 

To facilitate easy adoption of seqpac to any species, we provide a fast and
comprahensive workflow for mapping PAC sequences against user defined reference
databases. We call this reannotation, since we map the sequences in Anno object
sequentially over one or multiple references.

*Important*, seqpac relies on the popular bowtie aligner for mapping:
http://bowtie-bio.sourceforge.net/manual.shtml. This means that references must
be indexed using \code{bowtie-build} before they are compatible with the
reannotation workflow (see below).

<br>

### 2.4.1 Fasta references
Most databases provide their references in the fasta file format. Seqpac can
use any correctly formated fasta file as input in the reannotation workflow.
However, we destiguish two kinds of fasta references:

1. Reference genomes.
2. Other specialized references.

You can download the files manually from the source database. Below are some
helpful example links where to retreive useful fasta references. Note that all
compressed files must be uncompressed to work with the bowtie aligner.

<br>
**Reference genomes:**
[Ensembl Animals](https://www.ensembl.org/info/data/ftp/index.html) <br>
[Ensembl Plants](https://plants.ensembl.org/info/data/ftp/index.html) <br>
[UCSC](http://hgdownload.cse.ucsc.edu/downloads.html) <br>
[iGenomes](https://emea.support.illumina.com/sequencing/sequencing_software/igenome.html?langsel=/se/) <br>

Hint: Unmasked top level fasta files are best for most purposes, e.g. Ensembl
file name *.dna.toplevel.fa.gz.

**Other specialized references:**
[miRNA (mirbase)](http://www.mirbase.org/ftp.shtml) <br>
[miRNA (mirgenedb)](https://mirgenedb.org/download) <br>
[piRNA (piRBase)](http://www.regulatoryrna.org/database/piRNA/download.html) <br>
[Different ncRNA (Ensembl Animals)](https://www.ensembl.org/info/data/ftp/index.html) <br>
[Different ncRNA (Ensembl Plants)](https://plants.ensembl.org/info/data/ftp/index.html) <br>
[tRNA (GtRNAbd)](http://gtrnadb.ucsc.edu/) <br>
[repeats (repeatMasker)](http://repeatmasker.org/genomicDatasets/RMGenomicDatasets.html) <br>


There are also several packages in R that allows you to download reference
genomes. Here are two examples using the BSgenome and biomartr packages.

```{r, eval=FALSE}

## First specify where to store all the fasta file
ref_path <- "/home/danis31/Desktop/Temp_docs/fasta"

```{r, eval=FALSE}
###################################
####---- BSgenome ------------ ####
dest_path <- file.path(ref_path, "/uscs_genome/dm6_ucsc.fa")
BSgenome::available.genomes()
BiocInstaller::biocLite("BSgenome.Dmelanogaster.UCSC.dm6") # Only once
dm6 <- BSgenome::getBSgenome("BSgenome.Dmelanogaster.UCSC.dm6", masked=FALSE)
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
Biostrings::writeXStringSet(getSeq(dm6), filepath=dest_path, format="fasta")

``` 

```{r, eval=FALSE}
###################################
####---- biomartr ------------ ####
dest_path <- file.path(ref_path, "/biomartr_genome/") # Only dir
biomartr::is.genome.available(db = "ensembl", organism = "Drosophila melanogaster", details = TRUE)
file_path <- biomartr::getGenome(db="ensembl", organism = "Drosophila melanogaster", path=dest_path, gunzip=TRUE, release=101) # Bowtie don't take gzip
genome <- Biostrings::readDNAStringSet(filepath=list.files(dest_path, pattern=".fa$", full.names=TRUE), format="fasta")

``` 

<br>

Similar to full genomes, some specilized references may be available for direct
download using specific packages. Here is an example for ensembl ncRNA (animals)
using the biomartr package.

```{r, eval=FALSE}

###################################
####---- biomartr ncRNA ------ ####
dest_path <- file.path(ref_path, "/ensembl_ncRNA/") # Only dir
ncrna_path <- biomartr::getRNA(db="ensembl", organism = "Drosophila melanogaster", path=dest_path, release=101)
R.utils::gunzip(ncrna_path, destname=paste0(dest_path, "/ncrna.fa"), remove=TRUE, skip=TRUE) # Unzip to prepare for bowtie
ncrna <-  biomartr::read_rna(file = paste0(dest_path, "/ncrna.fa"))

```

Using the \code{download.file} function makes all urls (https/http/ftp etc)
available for download. Here an example for drosophila tRNA and miRNA
fasta:
```{r, eval=FALSE}

###################################
####---- Download GtRNAdb ---- ####
dest_path <- file.path(ref_path, "/GtRNAdb/trna.fa")
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
download.file(url="http://gtrnadb.ucsc.edu/genomes/eukaryota/Dmela6/dm6-tRNAs.fa", destfile=dest_path)
trna <- Biostrings::readDNAStringSet(filepath=dest_path, format="fasta")
```

```{r, eval=FALSE}
###################################
####---- Download mirbase ---- ####
# 1. Download pre-miRNA data
# 2. Extract compressed fasta
# 3. Read as RNA
# 4. Extract species D. melanogaster 
# 4. Convert to DNA
# 5. Overwrite RNA fasta with DNA fasta
# (sequenced reads are always in DNA)
# (we use pre-miRNA to catch all miRNA)
dest_path <- file.path(ref_path, "/mirbase/mirna.fa.gz")
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
download.file(url="ftp://mirbase.org/pub/mirbase/CURRENT/hairpin.fa.gz", destfile=dest_path)
R.utils::gunzip(dest_path, remove=TRUE, skip=TRUE)
mirna <- Biostrings::readRNAStringSet(filepath=gsub(".gz", "", dest_path), format="fasta")
mirna <- mirna[grepl("Drosophila melanogaster", names(mirna)),]
mirna <- Biostrings::DNAStringSet(mirna)
Biostrings::writeXStringSet(mirna, filepath=gsub(".gz", "", dest_path), format="fasta")

```

```{r, eval=FALSE}
###################################
####- Similar but MirGeneDB -- ####
# Since mirBase is no longer updated you might want to use MirGeneDB
dest_path <- file.path(ref_path, "/mirgenedb/mirna_pre_mirbase.fa.gz")
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
download.file(url="https://www.mirgenedb.org/static/data/dme/dme-pre.fas", destfile=dest_path)
mirna2 <- Biostrings::readRNAStringSet(filepath=dest_path, format="fasta")
mirna2 <- Biostrings::DNAStringSet(mirna2)
Biostrings::writeXStringSet(mirna2, filepath=dest_path, format="fasta")

## There are some overlaps 
table(paste0(mirna2) %in% paste0(mirna))                          # Not much perfect overlap
table(grepl(paste(paste0(mirna2), collapse="|"), paste0(mirna)))  # Non-perfect overlaps better 

``` 

<br>
Custom fasta files can also be used, and you can easily merge, add and remove
features to the database references by functions in the Biostrings package, such
as \code{readDNAStringSet}.


You may for some reason want to remove all haplotype or scaffold 'chromosomes'
from your top level reference genome.

```{r, eval=FALSE}
## Extract scaffold in genome files
file_path <- list.files(paste0(ref_path, "/biomartr_genome/"), pattern="toplevel.fa", full.names=TRUE)
genome <- Biostrings::readDNAStringSet(filepath=file_path[1], format="fasta")
chrom <- genome[!grepl("scaffold", names(genome)),] # Remove scaffolds
Biostrings::writeXStringSet(chrom, filepath=paste0(dirname(file_path), "/chromsomes.fa") , format="fasta")
scaff <- genome[grepl("scaffold", names(genome)),] # Keep scaffolds
Biostrings::writeXStringSet(scaff, filepath=paste0(dirname(file_path), "/scaffolds.fa"), format="fasta")


``` 

As default, bowtie only reports the names up to the first white space. Sometime
the sequence names need to be modified or rearranged for the bowtie aligner to
best report the names in the mapping output.  This can easily be done using the
Biostrings package:

```{r, eval=FALSE}
## Fixing the trna names
file_path <- paste0(ref_path, "/GtRNAdb/trna.fa")
trna <- Biostrings::readDNAStringSet(filepath=file_path, format="fasta")
names(trna) <- gsub("Drosophila_melanogaster_", "", names(trna))              # Remove species 
mat <- do.call("rbind", strsplit(names(trna), " "))                           # Make a name matrix 
names(trna) <-  paste(mat[,1], mat[,ncol(mat)-1], mat[,ncol(mat)], sep="_")   # Save the important as one single string
Biostrings::writeXStringSet(trna, filepath=file_path, format="fasta")

``` 


```{r, eval=FALSE}
## Rearrange the ncRNA fasta names
file_path <- paste0(ref_path, "/ensembl_ncRNA/ncrna.fa")
ncrna <- Biostrings::readDNAStringSet(filepath=file_path, format="fasta")
mat <- do.call("rbind", strsplit(names(ncrna), " "))                        # Make a matrix of the names
mat <- mat[,1:7]                                                            # Pick only the 1st columns 
                                                                            # (some species contains multiple columns with same input) 
col_bio <- grepl("gene_biotype:", mat[1,])                                  # Locate gene biotype column
col_coord <- grepl("chromosome:|scaffold:", mat[1,])                        # Locate coordinate column
identical(nrow(mat), sum(grepl("gene_biotype:", mat[,col_bio])))            # Did you catch all?
identical(nrow(mat), sum(grepl("chromosome:|scaffold:", mat[,col_coord])))

new_names <- paste(mat[,ncol(mat)], mat[,1], mat[,col_bio], mat[,col_coord], sep="_") # Pick columns of your choice
names(ncrna) <- gsub("gene_symbol:|chromosome:BDGP6.28:|gene_biotype:", "",  new_names) # Clean up
Biostrings::writeXStringSet(ncrna, filepath=file_path, format="fasta")


```

You may also want to add tRNAs from the mitochrondrial genome to your
tRNA reference, which is not always provided in the GtRNAdb fasta. This can be
done by moving them from Ensembl ncRNA fasta or scan the mitochondrial genome
manually at [tRNAscan-SE](http://lowelab.ucsc.edu/tRNAscan-SE/). The
mitochonridal genome is found in the reference genome fasta.

```{r, eval=FALSE}
## Locate and add mito tRNA
trna_logi <- grepl("tRNA_mitochondrion_genome", names(ncrna)) # Locate mito tRNA
table(trna_logi)                                              # Should be 22
trna <- c(trna, ncrna[trna_logi,])
Biostrings::writeXStringSet(trna, filepath=paste0(ref_path, "/GtRNAdb/trna.fa"), format="fasta")

``` 

<br>

### 2.4.2 Indexing the fasta references 
Before we can use the fasta references we need to index them for bowtie mapping.
You can do this by using the \code{bowtie_build} function in the Rbowtie package
or by running bowtie externally, outside R. For more information see
?Rbowtie::bowtie, Rbowtie::bowtie_build_usage()
http://bowtie-bio.sourceforge.net/manual.shtml.

*Important*, the bowtie prefix must have the same basename (\code{prefix=}) and
the indexes must be saved in the same directory (\code{outdir=}) as the original
fasta file.

Building indexes may take some time for large fasta, such as a reference genome.
You only need to generate the index once for every fasta reference. Lets create
bowtie indexes for a few of the fasta references we downloaded:
```{r, eval = FALSE}

ref_path <- "/home/danis31/Desktop/Temp_docs/fasta"
Rbowtie::bowtie_build(paste0(ref_path, "/biomartr_genome/chromsomes.fa"), outdir=paste0(ref_path, "/biomartr_genome/"), prefix="chromosomes", force=TRUE)
Rbowtie::bowtie_build(paste0(ref_path, "/biomartr_genome/scaffolds.fa"), outdir=paste0(ref_path, "/biomartr_genome/"), prefix="scaffolds", force=TRUE)
Rbowtie::bowtie_build(paste0(ref_path, "/GtRNAdb/trna.fa"), outdir=paste0(ref_path, "/GtRNAdb/"), prefix="trna", force=TRUE)
Rbowtie::bowtie_build(paste0(ref_path, "/ensembl_ncRNA/ncrna.fa"), outdir=paste0(ref_path, "/ensembl_ncRNA/"), prefix="ncrna", force=TRUE)
Rbowtie::bowtie_build(paste0(ref_path, "/mirbase/mirna.fa"), outdir=paste0(ref_path, "/mirbase/"), prefix="mirna", force=TRUE)


``` 

<br>

### 2.4.3 GTF feature coordinates
After the sequences has been mapped against a reference genome they can also
aquire annotations from genomic feature files, such as the gtf and gff formates.
These files contains the coordinates for different genomic features associated
with a specific reference genome, such as repetitative regions, exons and CpG
islands etc. Some functions in seqpac will require gtf files. Thus it is
important to know how to handle them.

GTF files can often be aquired at the same places as the fasta reference files
(see above). The biomartr package also have functions for downloading some gtf
files and you can create your own by downloading different tables, for example
using rtracklayer. Here are some examples:

```{r, eval = FALSE}
## Get gene gtf using biomartr
dest_path <- file.path(ref_path, "/gtf/") # Only dir
gtf_path <- biomartr::getGTF(db="ensembl", organism = "Drosophila melanogaster", path=dest_path)
gtf <- tibble::as_tibble(rtracklayer::readGFF(gtf_path))

## Get repeatMasker gtf using biomartr (doesn't work for all species)
dest_path <- file.path(ref_path, "/repeatMasker/") # Only dir
rm_path <- biomartr::getRepeatMasker(db="refseq", organism = "Drosophila melanogaster", path=dest_path)
gtf <- tibble::as_tibble(rtracklayer::readGFF(gtf_path))

## Get repeatMasker table and manually turn it into gtf using rtracklayer
# Table names can be found at:
# https://genome.ucsc.edu/cgi-bin/hgTables
dest_path <- file.path(ref_path, "/repeatMasker/repeatMasker.gtf") # Full file path
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
session <- rtracklayer::browserSession("UCSC")
rtracklayer::genome(session) <- "dm6"
rm_tab <- tibble::as_tibble(rtracklayer::getTable(rtracklayer::ucscTableQuery(session, track="RepeatMasker", table="rmsk")))
gr <- GenomicRanges::GRanges(seqnames=rm_tab$genoName, IRanges::IRanges(rm_tab$genoStart, rm_tab$genoEnd), strand=rm_tab$strand)
GenomicRanges::mcols(gr)$type <- "repeat"
GenomicRanges::mcols(gr)$source <- "repeatMasker_dm6"
GenomicRanges::mcols(gr)$repName <- rm_tab$repName
GenomicRanges::mcols(gr)$repClass <- rm_tab$repClass
GenomicRanges::mcols(gr)$repFamily <- rm_tab$repFamily  
rtracklayer::export(gr, dest_path, format="gtf")

``` 

<br>

### 2.4.4 The reannotation workflow
Here we present the details on how seqpac generates annotations. If too much for
you, you can skip ahead to the next section, where user-friendly wrappers for
generating different kinds of annotations are presented.

The PAC reannotation family of functions carry out the following tasks:
- Mapping sequences against fasta references.
- Storing the output on hard drive.
- Importing specific parts into R.
- Reorganizing the import into a suitable table.
- Classifying and simplifying each annotation
- Merging the table with an existing PAC$Anno table.

This is done by five functions \code{map_reanno}, \code{import_reanno}, \code{make_reanno},
\code{add_reanno}, and \code{simplify_reanno}.

<br>

**map_reanno**<br>
To accommodate most users on most platforms, seqpac provides two alternatives
for calling bowtie: internally from within R \code{type="internal"} or
externally from outside R (\code{type="external"}). In the internal mode, seqpac
uses the bowtie function in the Rbowtie package, while in the external mode
bowtie is called by a system command to a locally installed version of bowtie.
Both options gives identical results, but since the internal Rbowtie package is
rarely updated, we provide the external option.

Since the input commands for external bowtie and internal Rbowtie differs
slightly, map_reanno has two parse options (\code{parse_internal} and
\code{parse_external}). These can be used to control the two versions of bowtie
as if they were run from the console or command line, respectively.

While bowtie has its own way to handle mismatches in the alignments,
seqpac runs bowtie sequentially, increasing the number of mismatches for each
round. After each round all sequences that recieved a match in any of the
provided references will be subtracted. Therefore, in the next round only
sequences without a match will be reapplied but allowing one additional
mismatch. The map_reanno function controls this by sequentially increasing the
the number of mismatches after substracting the matches.

<br>

**import_reanno**<br>
This is the function that is called by \code{map_reanno} to import the bowtie
results after each sequential run. If you would run \code{import_reanno}
seperatly it simply provides you with options on how to import bowtie results
into R. For example, when aligning against a reference genome the mapping
coordinates is important, while mapping against other references 'hit' or 'no
hit' might be enough, and will be a much faster option.

<br>

**make_reanno**<br>
This function will search for the Full_reanno_mis0/1/2/3/4/5.Rdata files that
were generated by \code{map_reanno} and create a reanno object. This involves
extracttion, ordering and preparing annotations in a format that can be merged
with the existing Anno table in a PAC object. It will also generate an overview
table, that summarizes the annotations if multiple fasta references were used in
\code{map_reanno}.

**add_reanno**<br>
Before merging the new annotations with a PAC object, unless we have provided a
fasta reference with only one type (e.g. miRNA for mirBase), classification not
only *between* fasta references but also *within* references might be necessary
(e.g. snoRNA, tRNA, miRNA, rRNA in the Ensembl_ncRNA fasta). Classification of
the fasta reference names, which was first saved by bowtie and then caught in
our reanno object as an annotation, is done with the \code{add_reanno} function.
Again, there are two primary modes, either "genome" or "biotype". When
type="genome" a standardized workflow anticipating genomic coordinates are
performed. When type="biotype" a list of search term vectors directed against
each fasta reference needs to be provided. Matches between search term (written
as regular expressions) and substrings in fasta reference names will result in a
classification of the counted sequence that was annotated with that fasta
reference. Finally, \code{add_reanno} generates an annotation table that can
either be saved seperately or merged it with the original PAC object.

**simplify_reanno**<br>
While \code{add_reanno} starts the process of simplifying the reference name
annotations into useful classifications, it will generate multiple
classifications for each counted sequence if it matches multiple search terms.
The \code{simplify_reanno} function boils down multi-classification into one
classification for each sequence. By doing so, an heirarchy must be set, where
priority of some classifications over others is done (e.g. miRNA over
piRNA). While this is a controversial topic, using such hierarchies is still the
only way to provide overview statistics in experiments targeting highly
multimapping sequences, such as small RNA. Nonetheless, the seqpac workflow with
its sequence based counts where hierarchical classification is done in the very
end of the annotation process, makes it easy to change your hierarchy and
observe the consequences in for example a pie chart.

In summary:
- \code{map_reanno}       Bowtie reference mapping over mismatch cycles 
- \code{import_reanno}    Used by map_reanno to import bowtie output after each cycle   
- \code{make_reanno}      Imports and organizes the outputs of all mismatch cycles
- \code{add_reanno}       Classifies according to reference name annotations
- \code{simplify_reanno}  Hierarchical classification


### 2.4.5 Reannotation in action
Lets observe the functions in action using the drosophila test dataset.

First we map against a reference genome, using \code{map_reanno}. Note that
import="genome" must be set to catch the genomic coordinates. Since
\code{map_reanno} can handle multiple fasta references, we provide both the
chromosomes and schaffold fasta that we generated previously. Remember, each
fasta must have bowtie indexes (see 2.4.2).
```{r, echo=FALSE, eval=TRUE}
library(seqpac)
load(system.file("extdata", "drosophila_sRNA_pac.Rdata", package = "seqpac", mustWork = TRUE))

#####################################################
### Genome mapping using external bowtie
##---------------------------------------------
# Paths to bowtie indexed fasta files as list

outpath_genome <- "/home/danis31/Desktop/Temp_docs/reanno_genome" # OBS! You must change this.

ref_paths <- list(chromosomes="/home/danis31/Desktop/Temp_docs/fasta/biomartr_genome/chromosomes.fa",
                  scaffolds="/home/danis31/Desktop/Temp_docs/fasta/biomartr_genome/scaffolds.fa")

```
```{r, echo=FALSE, eval=FALSE}
map_reanno(PAC=pac_master, ref_paths=ref_paths, output_path=outpath_genome, 
            type="external", mismatches=3, import="genome", threads=8, keep_temp=TRUE)

```

Similarly, we can map against other specialized references, that can be used for
classifying each sequence into biotypes. Note, unlike genome mapping, at this
stage we are not interested in where a sequence matches a reference for the
speciallized references, only if it matches or not. Thus we use
\code{import="biotype"}.
```{r, echo=FALSE, eval=TRUE}
#####################################################
### sRNA mapping using internal bowtie
##---------------------------------------------
# Paths to bowtie indexed fasta files as list

outpath_srna <- "/home/danis31/Desktop/Temp_docs/reanno_srna"   # OBS! You must change this.


ref_paths <- list(miRNA="/home/danis31/Desktop/Temp_docs/fasta/mirbase/mirna.fa",
                   Ensembl="/home/danis31/Desktop/Temp_docs/fasta/ensembl_ncRNA/ncrna.fa",
                   tRNA="/home/danis31/Desktop/Temp_docs/fasta/GtRNAdb/trna.fa")

```
```{r, echo=FALSE, eval=FALSE}
map_reanno(pac_master, ref_paths=ref_paths, output_path=outpath_srna, 
            type="internal", mismatches=3,  import="biotype", threads=8, keep_temp=TRUE)

```

Now, the output .Rdata files for all mismatch cycles should have been stored in
the output folders. Lets import everything into R, generate a reanno list
objects and plot some pie charts from the Overview table.
```{r, message=FALSE}
#####################################################
### Generate a reanno object with make_reanno 
##---------------------------------------------
reanno_genome <- make_reanno(outpath_genome, PAC=pac_master, mis_fasta_check = TRUE, threads=8)
reanno_srna <- make_reanno(outpath_srna, PAC=pac_master, mis_fasta_check = TRUE, threads=8)

# List structure
ls.str(reanno_genome)
ls.str(reanno_srna)

```
```{r}
# Simple pie charts using the Overview table
pie(table(reanno_genome$Overview$chromosomes))
pie(table(reanno_genome$Overview$scaffolds))
pie(table(reanno_srna$Overview$Any))

```

Next step is to reorganize and classify using \code{add_reanno}. For mapping
against a reference genome this is easy. Just set type="genome" and set the
maximum number of alignments to be reported by \code{genome_max}
(\code{genome_max="all"} will give you all alignments).

```{r, message=FALSE}
##########################################
### Genomic coordinates using add_reanno 
##----------------------------------------
anno_genome <- add_reanno(reanno_genome, type="genome", genome_max=10, mismatches=3)

# Example of original reference name annotations 
head(reanno_genome$Full_anno$mis0$chromosomes)
# Finished genome annotation 
head(anno_genome$Anno)


```

For specialized reference, \code{type="biotype"} should be used. This allows
classification based on match or no match between the search terms provided in
\code{bio_search} and the reference names annotated with each counted sequence.
Correct classification is all about finding the best search terms that
descriminates between the different names in the original reference fasta files
(up to the first white space; see 2.4.1). With the \code{bio_perfect} option you
may control how conservative the matching between search term and annotation
should be. With \code{bio_perfect=FALSE}, every reference hit that fail to match
your search terms, will be classified as other. Using \code{bio_perfect=TRUE}
will instead garantee that your search terms will cover all reference hits. 

Hint: See ?add_reanno for a trick on how to succeed with bio_perfect=TRUE.

```{r, message=FALSE}
##########################################
### Classify sequences using add_reanno 
##----------------------------------------
# Lets start by exploring the names in the original fasta reference:

# Explore reference search terms
ref_path <- "/home/danis31/Desktop/Temp_docs/fasta"

Ensembl_ncrna <- names(Biostrings::readDNAStringSet(paste0(ref_path,"/ensembl_ncRNA/ncrna.fa")))
Ensembl_ncrna <- do.call("rbind", strsplit(Ensembl_ncrna, " "))[,1]        # Extract up to 1st white space
Ensembl_ncrna <- do.call("rbind", strsplit(Ensembl_ncrna, "\\:"))[,1]      # Expressions up to ":"
table(Ensembl_ncrna[!grepl("pre_miRNA", Ensembl_ncrna)])           

trna <- names(Biostrings::readDNAStringSet(paste0(ref_path,"/GtRNAdb/trna.fa")))
trna <- do.call("rbind", strsplit(trna, " "))[,1]
table(do.call("rbind", strsplit(trna, "\\-"))[,1])

mirna <- names(Biostrings::readDNAStringSet(paste0(ref_path,"/mirbase/mirna.fa")))
mirna <- do.call("rbind", strsplit(mirna, " "))[,1]
table(do.call("rbind", strsplit(mirna, "\\-"))[,1])


# Lets try two search term directed against each reference and written as 'regular expressions'
bio_search_1 <- list(
                 Ensembl=c("lncRNA", "pre_miRNA", "rRNA", "snoRNA", "snRNA", "tRNA"),
                 miRNA="dme-",
                 tRNA =c("^tRNA", "mt:tRNA")      # ^= Regular expression for start of string  
                )

bio_search_2 <- list(
                 Ensembl=c("lncRNA", "miRNA", "pre_miRNA", "rRNA", "snoRNA", 
                           "snRNA", "tRNA", "Uhg", "7SLRNA", "asRNA", "hpRNA", 
                           "RNaseMRP","RNaseP", "sbRNA", "scaRNA", "sisRNA", 
                           "snmRNA", "snoRNA", "snRNA","Su\\(Ste\\)"), # ()= Brackets must be escaped  
                 miRNA="dme-",
                 tRNA =c("^tRNA", "mt:tRNA") 
                )
```
```{r, eval=FALSE, message=FALSE}
# Throws an error because perfect matching is required:
anno <- add_reanno(reanno_srna, bio_search=bio_search_1, type="biotype", bio_perfect=TRUE, mismatches = 3)
# References with no search term hits are classified as "other":
anno <- add_reanno(reanno_srna, bio_search=bio_search_1, type="biotype", bio_perfect=FALSE, mismatches = 3)
# Better search terms gives perfect matching
anno <- add_reanno(reanno_srna, bio_search=bio_search_2, type="biotype", bio_perfect=TRUE, mismatches = 3)

```
```{r, eval=TRUE, message=FALSE, echo=FALSE}
anno <- add_reanno(reanno_srna, bio_search=bio_search_2, type="biotype", bio_perfect=FALSE, mismatches = 3)

```


To make overview statistics and graphs we need to boil down the classifications
to a factor column with only a few biotypes per factor. This is what
\code{simplify_reanno} does. Just like \code{add_reanno} in the
\code{type="biotype"} mode, \code{simplify_reanno} needs a list of search terms,
\code{hierarchy}. This time, however, the list is order sensitive and targets
the output table from \code{add_reanno} that contains the columns with new
classifications (e.g. "mis0_bio", "mis1_bio", "mis2_bio" etc). If a match occurs
between the first search term and a classification, the counted sequence will be
annotated to this classification, no matter if other search terms matches
further down the list. This is done sequentially, allowing one additional
mismatch until a maximum specified in \code{mismatches} has been reached. Thus
if a match occurs in tRNA with 0 mismatch, and rRNA with 1 mismatch, it will be
reported as tRNA even though rRNA where higher in the \code{hierarchy}. A better
match will always be prioritized over the hierarchy.

```{r, message=FALSE}
###################################################
### Hierarchical classification with simply_reanno
##----------------------------------------
hierarchy <- list(rRNA="Ensembl_rRNA",
                   Mt_tRNA="tRNA_mt:tRNA",
                   tRNA="Ensembl_tRNA|tRNA_\\^tRNA",
                   miRNA ="^miRNA|Ensembl_miRNA|Ensembl_pre_miRNA",
                   snoRNA="Ensembl_snoRNA",
                   lncRNA="Ensembl_lncRNA"   
                  )

pac_master_anno <- simplify_reanno(input=anno, hierarchy=hierarchy, mismatches=0, bio_name="Biotypes_mis0", merge_pac=pac_master)
pac_master_anno <- simplify_reanno(input=anno, hierarchy=hierarchy, mismatches=0, bio_name="Biotypes_mis3", merge_pac=pac_master_anno)

# Example of original reference name annotations 
head(reanno_srna$Full_anno$mis0$Ensembl)
# Advanced biotype classification
head(anno)
# Simplified hierarchical classification
head(pac_master_anno$Anno)

``` 





<!-- ### 2.3.6 Differential Expression In RNA-sequencing it is common to look for -->
<!-- differnetially expressed transcripts and there are several ways to study this. -->
<!-- In addition to RPM, seqpac offers a function integrating DESeq2 differential -->
<!-- expression with the PAC dataset, PAC_deseq. DESeq2 uses a negative binomial -->
<!-- generailzed linear model to find differentially expressed transcripts in the -->
<!-- data. When running PAC_deseq, it is important to formulate a correct model. For -->
<!-- more information about designs and DESeq2 in general, please see -->
<!-- https://github.com/mikelove/DESeq2 . -->
<!-- ```{r} -->
<!-- model= ~Tissue+Exp pac_deseq <- PAC_deseq(pac_rpm_filt, model=model, -->
<!-- main_factor="Testis", norm=TRUE, histogram=TRUE, threads=4, pheno_target=NULL, -->
<!-- anno_target=NULL) -->
<!-- ``` -->
<!-- ### 2.3.7 Plotting Data seqpac offers several ways to plot your data. -->
<!-- -PAC_covplot -PAC_jitter -PAC_pie -PAC_stackbar -PAC_sizedist -->
<!-- <br> Lets generate a few normalized count tables and compare them: ```{r, -->
<!-- fig.width = 6, fig.height = 3} -->
<!-- ###--------------------------------------------------------------------- ## -->
<!-- Since the example pac_master is small to begin with we use this as start: ## -->
<!-- (You may wish to use a low-filtered PAC for normalization to get rid of noise) -->
<!-- pac_rpm <- PAC_norm(pac_master, type="rpm")                 # Returned as a -->
<!-- dataframe in the PAC$norm folder df_vst <- PAC_norm(pac_master, type="vst", -->
<!-- PAC_merge=FALSE) # Returned as a dataframe df_rlog <- PAC_norm(pac_master, -->
<!-- type="rlog", PAC_merge=FALSE) -->
<!-- cowplot::plot_grid(nrow=1, ncol=2, -->
<!-- ggplot2::ggplot(data.frame(log2_mean_rpm=log2(rowMeans(pac_rpm$norm$rpm)), -->
<!-- mean_vst=rowMeans(df_vst)), aes(x=log2_mean_rpm, y=mean_vst)) + geom_point(), -->
<!-- ggplot2::ggplot(data.frame(log2_mean_rpm=log2(rowMeans(pac_rpm$norm$rpm)), -->
<!-- mean_rlog=rowMeans(df_rlog)), aes(x=log2_mean_rpm, y=mean_rlog)) + geom_point()) -->
<!-- ``` -->
<!-- <br> As you probably noticed we only stored the rpm values in the PAC. Lets now -->
<!-- apply a deeper filter that are based on rpm thresholds: -->
<!-- ```{r} ###--------------------------------------------------------------------- -->
<!-- ## Extracts all sequences with >=10 counts in 100% of samples within each -->
<!-- category of the 'type' column in Pheno. filtsep <- PAC_filtsep(pac_rpm, -->
<!-- type="rpm", threshold=10, coverage=100, pheno_target= list("type")) -->
<!-- pac_hifilt <- PAC_filter(pac_rpm, subset_only = TRUE, anno_target= -->
<!-- unique(do.call("c", as.list(filtsep)))) -->
<!-- PAC_check(pac_hifilt) -->
<!-- ls.str(pac_hifilt) ``` -->
<!-- <br> -->
<!-- ## 2.5 Data Visualization One excellent tool for studying the structure of the -->
<!-- data is to study the relationship of its principal components. This can be done -->
<!-- with a PCA plot, where the distance of datapoints are calculated and presented -->
<!-- in a figure. A principal component analysis (PCA) can only show how the data -->
<!-- relates to one another, not why it behaves this way. To produce a PCA plot with -->
<!-- seqpac, use PAC_pca: -->


