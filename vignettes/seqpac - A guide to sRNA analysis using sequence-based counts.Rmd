---
title: "seqpac - A guide to sRNA analysis using sequence-based counts"
author: "Daniel Nätt"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{seqpac - A guide to sRNA analysis using sequence-based counts}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

<br>
<br>
<br>

Seqpac is available on github:

```{r, include = TRUE, eval=FALSE}
## Installation
devtools::install_github("Danis102/seqpac", upgrade="never", )
```

<br>
<br>

---

# Introduction 

<br>

## 1.1 Overview

Seqpac contains a complete toolbox for the analysis of short sequenced reads.
The package was originally developed for small RNA (sRNA) analysis, but can be
applied on any type of data generated by large scale nucleotide sequencing,
where the user wish to maintain sequence integrity during the whole analysis.
This involves, for example, regular RNA-seq with long RNA.

<br>
To perserve sequence integrity, seqpac applies sequence-based counting. This can
be contrasted against feature-based counting, where reads are counted over known
genomic features, such a protein coding genes or sRNA. This will result in a
count table where a count is made per feature (e.g. number of read counts
mapping to a gene). In seqpac, such annotations are initially disregarded, as a
count table is generated solely by counting unique sequences in the raw sequence
files. Annotations against known refereces (such as databases containing
sequences of full genomes, miRNA, tRNA, protein coding genes, or genomic
coordinates of such features) are done after the count table has been generated.

<br>
The advantage of using sequence-based counting, compared to feature-based
counting, is that mismatches in the classification of reads, can be applied any
time during the analysis. In feature-based counting, allowing a mismatch in the
mapping will result in a loss of information (loss of sequence integrity).

<br>
For example, say that you have 506 read counts for miR-185 (a miRNA) when
allowing 3 mismatches against the reference. In feature-based analysis this will
result in 1 entry in the count table. Unless you have saved the exact alignments
elsewhere, you have lost the information about what sequences that are included
in that count. The only thing you know is that the sequence may differ from the
reference sequence by any 3 mismaches. In sequence-based counting, reads are
counted as unique sequences and each unique sequence is then mapped againts the
target reference databases. Information about whether a sequence was aligning
against a reference is maintained in a linked annotation table that can contain
both perfect alignments and alignments allowing mismatches. Thus, in any stage
of the analysis mismatches and classifications into features can be dynamically
controlled, meaning that you can easily observe the effect of for example
allowing more mismatches or changes in hierarchical classifications (often
applied in sRNA analysis when a sequence align with multiple classes of sRNA).

<br>

## 1.2 The seqpac workflow
The input file format for seqpac is .fastq, which can be generated from most
sequencing platforms. Two types of objects sustain the core of the seqpac
workflow:

- The PAC object 
- The Targeting objects

<br>
The PAC object stores the Phenotypic information (P), Annotations (A) and Counts
(C) needed for all downstream analysis, while the targeting object is used for
accessing specific subsets of data within the PAC object. To keep things simple,
both of these objects are lists. The PAC object is in its simplest form a list
of 3 data.frames (Pheno, Anno and Counts), while the Targeting object is a list
of 2 character objects.

<br>
The workflow is roughly divided into four steps: 

- Generate a PAC object from fastq-files
- Preprocess the PAC object
- Annotate the PAC object
- Analyze the PAC object.

<br>

## 1.3 Example dataset
Contained within this package are nine example fastq files. These files were
originally generated by extracting sRNA from single fruit fly embryos at three
different developmental stages (Stage 1, 3, 5). The original fastq files were
aquired by Illumina NextSeq 500 sequencer using a High Output 75 cycles flow
cell (product no: 20024906) and NEBNext® Small RNA Library Prep Set for Illumina
(E7330). Each fastq were randomly downsampled to a fraction of its original
size.

<br>
<br>

---

# Making a PAC object

<br>

## 2.1 Generating a count table (make_counts)
There are three ways of generating a count table in seqpac.

- Trim raw fastq files using internal functions in seqpac/R.
- Trim raw fastq files using external functions outside R.
- Import reads from already trimmed fastq files.

<br>
The two first involves adaptor trimming, while the last involves already trimmed
reads. All input options are contained within the `make_counts`.
function.

<br>

### 2.1.1 Internal trimming
Generating a count table from untrimmed fastq files using nothing but R packages
(internal) depends on the `make_trim` function. This function goes through a
series of trimming cycles using the `trimLRPatterns` function in `Biostrings`
package to generate highly comparable adaptor trimming as generated by popular
fastq trimming softwares, such as cutadapt. This combined with the capability of
parallellization using the `foreach` package makes `make_trim` one of very few
choices for adaptor trimming in R.

<br>
When `make_trim` is used on its own it results in trimmed fastq files
stored at a user defined location. When `trimming="seqpac"` is set in the
`make_counts` function, this function parses settings to the
`make_trim` to generate a count table from temporarly stored trimmed fastq
files.

<br>
Lets have a try using the example dataset:
```{r, results = "hide", eval=FALSE}
library(seqpac)

## Using default settings for NEB type adaptor 
# NEB=New England Biolabs: NEBNext® Small RNA Library Prep Set for Illumina (E7300/E7330)
# For illumina type adaptors, 'parse="default_illumina"' may be used

path_to_fastq <- system.file("extdata", package = "seqpac", mustWork = TRUE)
count_list <- make_counts(input=path_to_fastq, type = "fastq", trimming="seqpac", 
                          parse="default_neb")


# That was quite slow, lets speed it up a bit by increasing threads:
count_list <- make_counts(input=path_to_fastq, type = "fastq", trimming="seqpac", 
                          parse="default_neb", threads=9)


```

<br>

### 2.1.2 External trimming
As an alternative to seqpac internal trimming, two external softwares, cutadapt
and fastq_quality_filter, can be used to trim the adapter sequence and remove
low quality reads prior of making a count table.

<br>
Importantly, cutadapt and fastq_quality_filter are only available on Linux:
    https://cutadapt.readthedocs.io/en/stable/installation.html
    http://hannonlab.cshl.edu/fastx_toolkit/commandline.html

<br>
For linux users with all dependencies installed:
```{r, eval=FALSE}
###--------------------------------------------------------------------- 
# Generate counts by parsing commands to cutadapt
# and fastq_quality_filter.
# (Note, the 'default_neb' parse argument is specificly designed for sRNA trimming

count_list <- make_counts(input=path_to_fastq, type = "fastq", trimming="cutadapt", parse="default_neb")

```
See the manuals for 'make_counts', 'make_trim',
'make_cutadapt' for more details.

<br>

### 2.1.3 Already trimmed fastq
Setting `trimming=NULL` in the `make_counts` function will pass
the adapter trimming and a count table will be generated directly from the fastq
files. Thus, this option can be used if you already have trimmed your fastq
files.

<br>

### 2.1.4 Outputs from make_counts
Besides the counts table, `make_counts` automatically generates a
progress report for the trimming and evidence filter, as well as bar graphs
showing the impact of the evidence filter (if plots=TRUE).

<br>

### 2.1.5 Evidence filtering
Users may already when making the counts table with `make_counts`
markedly reduce the noise in the data by specifying the number of independent
evidence that a specific sequence must reach to be included. This is controlled
by the `evidence` argument. As default, `evidence=c(experiment=2,
sample=1)` will include all sequences that have >=1 counts in at least 2
independent fastq files.

```{r, eval=FALSE}
## Lets plot the graphs from the default output again 
cowplot::plot_grid(plotlist=count_list$evidence_plot, nrow=2, ncol=1)

```

Importantly, since the test dataset is heavily down-sampled compared to the
original fastq files the default evidence filter results in a rather dramatic
loss of total number of reads. This will not be the case when running good
quality fastq files with saturated sequence depths. We routinely observe that
95-99% of all reads are maintained when applying the default evidence filter,
while >50% of the unique sequence will be dropped because they can not be
replicated across two independent samples. Despite being a down-sampled
(unsaturated) dataset, a tendency can be seen in the test data by comparing
the ratio between pass and not pass of reads and unique sequences. For an
example of how a saturated experiment may look like, see the original seqpac
paper, Skog et al. from 2021.

<br>
As you may have guessed, the 'experiment' argument controls the number of
independent fastq evidence needed across the whole experiment. Note, however,
that 'sample' does not control the number of counts needed in each sample. The
evidence filter will always use >=1 counts in X number of fastq files. Instead
'sample' controls when a sequence should be included despite not reaching the
'experiment' threshold. Thus if `evidence=c(experiment=2, sample=10)`,
sequences that reach 10 counts in a single sample will also be included. 
Here is an example on how to use the 'sample' argument:

```{r, results = "hide", eval=FALSE}
###--------------------------------------------------------------------- 
## Evidence over two indepenent samples, saving single sample sequences reaching 10 counts
test <- make_counts(input=path_to_fastq, type="fastq", trimming="seqpac", 
                    parse="default_neb", threads=9,  
                    evidence=c(experiment=2, sample=10))
extras <- apply(test$counts, 1, function(x){sum(!x==0)})
test$counts[extras==1,]  # 28 single sample sequences reach 10 counts

## Evidence over two indepenent samples, saving single sample sequences reaching 3 counts
test <- make_counts(input=path_to_fastq,  type="fastq", trimming="seqpac", 
                    parse="default_neb", threads=9,   
                    evidence=c(experiment=2, sample=3))
extras <- apply(test$counts, 1, function(x){sum(!x==0)})
test$counts[extras==1,] # A few hundred single sample sequences reach 3 counts

```

<br>
Lastly, if evidence=NULL all unique sequences will be saved. Remember, however,
that the count table will become at least twice as large, since each unique
sequence occupies a row in `PAC$Counts` and `PAC$Anno`.

<br>

## 2.2 Generate the phenotype table (make_pheno)
Next, we generate a Pheno table (P) and merge it with the progress report that
was stored from the `make_counts` output. The Pheno table contains
sample specific information such as sample name and possible interventions, with
each sample as a row. 

Importantly, the `make_pheno` function can import a Pheno table both
externally by providing a path to a .cvs file, as well as internally by just
passing a data.frame. In common for both options, is that a unique column named
"Sample_ID" needs to be present, and must contain the same sample names (column
names) present in the counts table generated by `make_counts`.

In addtion, `make_pheno` may add the progress report generated by
`make_counts`. Lets have a look at how this works:

```{r, results = "hide", eval=FALSE}
###--------------------------------------------------------------------- 
## Generate a Pheno table using the file names of test fastq 
path_to_fastq <- system.file("extdata", package = "seqpac")
pheno <- as.data.frame(do.call("rbind", 
                       strsplit(list.files(path_to_fastq, pattern="*.fastq.gz"),
                       "_|\\."))[,c(4, 1,2,3)]) 
colnames(pheno) <- c("sample", "stage", "batch", "index")
pheno$Sample_ID <- colnames(count_list$counts)
pheno <- make_pheno(pheno=pheno, 
                    progress_report=count_list$progress_report, 
                    counts=count_list$counts)

```

## 2.3 make_PAC
<br>
Finally, we put everything together as a master PAC object. Conveniently,
setting the `anno=NULL` will generate a very simple annotation table and
add it to the PAC object.
```{r, eval=FALSE}
###--------------------------------------------------------------------- 
## Generate PAC object
pac_master <- make_PAC(pheno=pheno, anno=NULL, counts=count_list$counts)
names(pac_master)
lapply(pac_master, head)

## If TRUE the PAC object is ok 
PAC_check(pac_master)
```

<br>
<br>

---

# Preprocess the PAC object

## 3.1 Targeting objects
Seqpac uses a simple targeting system for dividing and focusing the analysis of
a PAC object to certain sample groups (Pheno) or specific sequences (Anno). If
not specified otherwise in the function manual, a targeting object is always a
two item list, where the first object is naming a column in a specific table in
the PAC and the second object tells the function which categories in that column
that should be targeted.

- pheno_target:  extracts sample groups from a column in PAC$Pheno
- anno_target:   extracts sequences from a column in PAC$Anno

While pheno_target and anno_target are the most common targeting objects, there
are other targeting object. Common for all is that they target a specific
subtable in the PAC.

<br>
Now, take a look at the first columns in Pheno table and the first lines of the
Anno table found in master PAC object that was generated in 2.1: 

```{r, eval=FALSE}
###--------------------------------------------------------------------- 
## Load the PAC master and inspect the columns in Pheno and Anno
library(seqpac)
load(system.file("extdata", "drosophila_sRNA_pac.Rdata", package = "seqpac", mustWork = TRUE))

pac_master$Pheno[,1:5]
head(pac_master$Anno)

```

<br>
A pheno_target object that will exclusively target stage 1 and 5 samples would
look like this: `pheno_target=list("stage", c("Stage1", "Stage5"))`

<br>
While an anno_target that will target sequences of 22 nt in length would look like this:
`anno_target=list("Size", "22")`

<br>
Notice that both targeting objects are lists holding two secondary objects: one
character string targeting a specific column, and one character vector targeting
specific categorise within the target column. The only difference being that
each targeting object target different tables in the PAC object.

<br>
Important, if the second object is set to NULL or is left out this will
automatically target all samples in the specified column. If the anno_target is a
character vector (not a list) some function will attempt to extract matches in
the row names of either Pheno or Anno (see example with `PAC_filtsep` below).

<br>
For more examples, please refere to the original seqpac publication: Skog et al.
2021.

<br>

## 3.2 Filtering
A master PAC object will contain sequences in your original fastq files that
passed the trimming and the initial filters. Now, in most analysis this still
involves millions of unique sequences, making the master PAC difficult to work
with. Thus, it is often wise to further reduce noise prior to normalization and
annotation.

<br>
Seqpac contains two functions for this purpose:

- `PAC_filter`
- `PAC_filtsep`

<br>
While `PAC_filter` gives a variety of choices to subset the PAC file according
to for example sequence size or minimum counts in a certain proportion of the
samples,`PAC_filtsep` extracts the sequence names that pass a filter within
sample groups.

<br>
Here are some examples:
```{r, eval=FALSE}
###--------------------------------------------------------------------- 
## Extracts all sequences between 10-80 nt in length with at least 5 counts in
## 20% of all samples.
pac_lowfilt <- PAC_filter(pac_master, size=c(10,80), threshold=5, 
                          coverage=20, norm = "counts",  
                          pheno_target=NULL, anno_target=NULL)

###--------------------------------------------------------------------- 
## Extracts all sequences with 22 nt size and the samples in Batch1 and Batch2.
pac_subset <- PAC_filter(pac_master, subset_only = TRUE,
                         pheno_target=list("batch", c("Batch1", "Batch2")), 
                         anno_target=list("Size", "22"))

###--------------------------------------------------------------------- 
## Extracts all sequences with >=5 counts in 100% of samples a within stage
filtsep <- PAC_filtsep(pac_master, norm="counts", threshold=5, 
                       coverage=100, pheno_target= list("stage"))

pac_filt <- PAC_filter(pac_master, subset_only = TRUE,
                       anno_target= unique(do.call("c", as.list(filtsep))))
                       
                      

```

Notice that `PAC_filtsep` only extracts the sequence names and store them in a
data.frame. Converted into a character vector with unique names (using `unique` +
`do.call`) they can be applied as an anno_target that targets sequence names in
Anno. 

Hint, the data.frame output of `PAC_filtsep` has been designed for the purpose
of generating Venn diagrams that visualize overlaps across groups:
```{r, eval=FALSE}
###--------------------------------------------------------------------- 
## Venn diagram of all sequences with >=10 counts in 100% of samples 
## within each group
olap <- reshape2::melt(filtsep, 
                       measure.vars = c("Stage1", "Stage3", "Stage5"), na.rm=TRUE)
plot(venneuler::venneuler(data.frame(olap[,2], olap[,1])))

```

<br>

## 3.3 Storage of processed data in PAC
While the master PAC only contains three different data.frame objects (P, A and
C), additional 'folders' will be stored in the PAC object as the analysis progresses. In
fact, you may choose to store any number of objects in your PAC as long as they
do not conflict with the names of the standard folders, which are:

    Pheno  (P):    data.frame
    Anno   (A):    data.frame
    Counts (C):    data.frame
    norm:          list of data.frames
    summary:       list of data.frames

<br>
The *norm* folder will be used to store counts that have been normalized in
different ways, while the *summary* folder will contain the data that has been
summerized across groups of samples. In both cases, applying a filter using
`PAC_filter` will automatically subset not only P, A, and C, but also all tables
stored in `PAC$norm` and `PAC$summary`.

<br>

## 3.4 Normalization
The built in normalization methods in seqpac are handled by the `PAC_norm`
function. In the current version only three methods are available: 

- Counts per million reads (cpm) 
- Variance-Stabalizing Transformation (vst)
- Regularized log transformation (rlog)

<br>
More specifically, cpm normalize the dataset in relation to the total number of
reads, while vst and rlog uses both mean dispersion and size factor to produce
homoskedastic values with functions avalable in the DESeq2 package.

<br>
It is easy to generate your own normalized count table using your
method of choice, and import it as a data.frame to the *norm* folder in the PAC
object. Just remember that row and column names must be identical to the
original Counts table. Use `PAC_check` to verify that this is the case.

Lets generate two normalized count tables with cpm and vst:
```{r, results=FALSE, eval=FALSE}

###--------------------------------------------------------------------- 
## Example normalization in seqpac
pac_cpm <- PAC_norm(pac_master, norm="cpm")
pac_vst <- PAC_norm(pac_master, norm="vst")

``` 

From this, it may sometimes be wise to run a further filtering step to remove
reads with low cpm values.

```{r, results=FALSE, eval=FALSE}

###---------------------------------------------------------------------
## Filtering using cpm instead of raw counts
## filter >=10 cpm in 100% of samples in >= 1 full group
filtsep <- PAC_filtsep(pac_cpm, norm="cpm", threshold=10, coverage=100, pheno_target= list("stage")) 
pac_cpm_filt <- PAC_filter(pac_cpm, subset_only = TRUE,
                       anno_target= unique(do.call("c", as.list(filtsep))))


``` 

<br>
<br>

---

# Generate annotations
From the start a PAC object only contains a very limited Anno table.

```{r, results=FALSE, eval=FALSE}

library(seqpac)
load(system.file("extdata", "drosophila_sRNA_pac_filt.Rdata", package = "seqpac", mustWork = TRUE))
head(pac_cpm_filt$Anno)

``` 

To facilitate easy adoption of seqpac to any species, we provide a fast and
flexible workflow for mapping PAC sequences against user defined reference
databases. We call this reannotation, since we map the sequences in Anno object
sequentially over one or multiple references.

Important, seqpac relies on the popular bowtie aligner (R package Rbowtie) for
mapping: http://bowtie-bio.sourceforge.net/manual.shtml. This means that
references must be indexed using the `bowtie_build` function before they are
compatible with the reannotation workflow (see below).

<br>

## 4.1 Fasta references
Most databases provide their references in the fasta file format. Seqpac can
use any correctly formated fasta file as input in the reannotation workflow.
However, we destiguish two kinds of fasta references:

- Reference genomes.
- Other specialized references.

You can download the files manually from the source database. Below are some
helpful example links where to retreive useful fasta references. Note that all
compressed files must be uncompressed to work with the bowtie aligner.

<br>
**Reference genomes:**<br>
[Ensembl Animals](https://www.ensembl.org/info/data/ftp/index.html) <br>
[Ensembl Plants](https://plants.ensembl.org/info/data/ftp/index.html) <br>
[UCSC](http://hgdownload.cse.ucsc.edu/downloads.html) <br>
[iGenomes](https://emea.support.illumina.com/sequencing/sequencing_software/igenome.html?langsel=/se/) <br>

<br>
Hint: Unmasked top level fasta files are best for most purposes, e.g. Ensembl
file name *.dna.toplevel.fa.gz.

**Other specialized references:**<br>
[miRNA (mirbase)](http://www.mirbase.org/ftp.shtml) <br>
[miRNA (mirgenedb)](https://mirgenedb.org/download) <br>
[piRNA (piRBase)](http://www.regulatoryrna.org/database/piRNA/download.html) <br>
[Several ncRNA (Ensembl Animals)](https://www.ensembl.org/info/data/ftp/index.html) <br>
[Several ncRNA (Ensembl Plants)](https://plants.ensembl.org/info/data/ftp/index.html) <br>
[tRNA (GtRNAbd)](http://gtrnadb.ucsc.edu/) <br>
[repeats (repeatMasker)](http://repeatmasker.org/genomicDatasets/RMGenomicDatasets.html) <br>

<br>
There are also several packages in R that allow you to download reference
genomes. Here are two examples using the BSgenome and biomartr packages.

```{r, eval=FALSE}
###---------------------------------------------------------------------
## First specify where to store all the fasta file
ref_path <- "/home/danis31/Desktop/Temp_docs/fasta"      # You need to change this

```{r, eval=FALSE}
###---------------------------------------------------------------------
## BSgenome 
dest_path <- file.path(ref_path, "/uscs_genome/dm6_ucsc.fa")
BSgenome::available.genomes()
BiocInstaller::biocLite("BSgenome.Dmelanogaster.UCSC.dm6") # Only once
dm6 <- BSgenome::getBSgenome("BSgenome.Dmelanogaster.UCSC.dm6", masked=FALSE)
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
Biostrings::writeXStringSet(getSeq(dm6), filepath=dest_path, format="fasta")

``` 

```{r, eval=FALSE}
###---------------------------------------------------------------------
## biomartr  
dest_path <- file.path(ref_path, "/biomartr_genome/") # Only dir
biomartr::is.genome.available(db = "ensembl", organism = "Drosophila melanogaster", details = TRUE)
file_path <- biomartr::getGenome(db="ensembl", organism = "Drosophila melanogaster", path=dest_path, gunzip=TRUE, release=101) # Bowtie don't take gzip
genome <- Biostrings::readDNAStringSet(filepath=list.files(dest_path, pattern=".fa$", full.names=TRUE), format="fasta")

``` 

<br>
Similar to full genomes, some specilized references may be available for direct
download using specific packages. Here is an example for ensembl ncRNA (animals)
using the biomartr package.

```{r, eval=FALSE}
###---------------------------------------------------------------------
## biomartr ncRNA 
dest_path <- file.path(ref_path, "/ensembl_ncRNA/") # Only dir
ncrna_path <- biomartr::getRNA(db="ensembl", organism = "Drosophila melanogaster", path=dest_path, release=101)
R.utils::gunzip(ncrna_path, destname=paste0(dest_path, "/ncrna.fa"), remove=TRUE, skip=TRUE) # Unzip to prepare for bowtie
ncrna <-  biomartr::read_rna(file = paste0(dest_path, "/ncrna.fa"))

```

<br>
Using the `download.file` function makes all urls (https/http/ftp etc)
available for download. Here are examples for drosophila tRNA and miRNA
fasta:
```{r, eval=FALSE}
###---------------------------------------------------------------------
## Download GtRNAdb
dest_path <- file.path(ref_path, "/GtRNAdb/trna.fa")
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
download.file(url="http://gtrnadb.ucsc.edu/genomes/eukaryota/Dmela6/dm6-tRNAs.fa", destfile=dest_path)
trna <- Biostrings::readDNAStringSet(filepath=dest_path, format="fasta")
```

```{r, eval=FALSE}
###---------------------------------------------------------------------
## Download mirbase
# 1. Download pre-miRNA data
# 2. Extract compressed fasta
# 3. Read as RNA
# 4. Extract species D. melanogaster 
# 4. Convert to DNA
# 5. Overwrite RNA fasta with DNA fasta
# (sequenced reads are always in DNA)
# (we use pre-miRNA to catch all miRNA)
dest_path <- file.path(ref_path, "/mirbase/mirna.fa.gz")
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
download.file(url="ftp://mirbase.org/pub/mirbase/CURRENT/hairpin.fa.gz", destfile=dest_path)
R.utils::gunzip(dest_path, remove=TRUE, skip=TRUE)
mirna <- Biostrings::readRNAStringSet(filepath=gsub(".gz", "", dest_path), format="fasta")
mirna <- mirna[grepl("Drosophila melanogaster", names(mirna)),]
mirna <- Biostrings::DNAStringSet(mirna)
Biostrings::writeXStringSet(mirna, filepath=gsub(".gz", "", dest_path), format="fasta")

```

```{r, eval=FALSE}
###---------------------------------------------------------------------
## Similar but MirGeneDB 
# Since mirBase is rarely updated you might want to use MirGeneDB
dest_path <- file.path(ref_path, "/mirgenedb/mirna_pre_mirbase.fa.gz")
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
download.file(url="https://www.mirgenedb.org/static/data/dme/dme-pre.fas", destfile=dest_path)
mirna2 <- Biostrings::readRNAStringSet(filepath=dest_path, format="fasta")
mirna2 <- Biostrings::DNAStringSet(mirna2)
Biostrings::writeXStringSet(mirna2, filepath=dest_path, format="fasta")

## There are some overlaps 
table(paste0(mirna2) %in% paste0(mirna))                          # Not much perfect overlap
table(grepl(paste(paste0(mirna2), collapse="|"), paste0(mirna)))  # Non-perfect overlaps better 

``` 

<br>
Custom fasta files can also be used, and you can easily merge, add and remove
features to the database references by functions in the Biostrings package, such
as `readDNAStringSet`. You may for example want to separate all haplotypes and
scaffold 'chromosomes' from your top level reference genome.

```{r, eval=FALSE}
###---------------------------------------------------------------------
## Extract scaffold in genome files
file_path <- list.files(paste0(ref_path, "/biomartr_genome/"), pattern="toplevel.fa", full.names=TRUE)
genome <- Biostrings::readDNAStringSet(filepath=file_path[1], format="fasta")
chrom <- genome[!grepl("scaffold", names(genome)),] # Remove scaffolds
Biostrings::writeXStringSet(chrom, filepath=paste0(dirname(file_path), "/chromsomes.fa") , format="fasta")
scaff <- genome[grepl("scaffold", names(genome)),] # Keep scaffolds
Biostrings::writeXStringSet(scaff, filepath=paste0(dirname(file_path), "/scaffolds.fa"), format="fasta")


``` 

<br>
As default, bowtie only reports the names up to the first white space. Sometimes
the sequence names need to be modified or rearranged for the bowtie aligner to
best report the names in the mapping output. This can easily be done using the
Biostrings package:

```{r, eval=FALSE}
###---------------------------------------------------------------------
## Fixing the trna names
file_path <- paste0(ref_path, "/GtRNAdb/trna.fa")
trna <- Biostrings::readDNAStringSet(filepath=file_path, format="fasta")
names(trna) <- gsub("Drosophila_melanogaster_", "", names(trna))              # Remove species 
mat <- do.call("rbind", strsplit(names(trna), " "))                           # Make a name matrix 
names(trna) <-  paste(mat[,1], mat[,ncol(mat)-1], mat[,ncol(mat)], sep="_")   # Save the important as one single string
Biostrings::writeXStringSet(trna, filepath=file_path, format="fasta")

``` 


```{r, eval=FALSE}
###---------------------------------------------------------------------
## Rearrange the ncRNA fasta names
file_path <- paste0(ref_path, "/ensembl_ncRNA/ncrna.fa")
ncrna <- Biostrings::readDNAStringSet(filepath=file_path, format="fasta")
mat <- do.call("rbind", strsplit(names(ncrna), " "))                        # Make a matrix of the names
mat <- mat[,1:7]                                                            # Pick only the 1st columns 
                                                                            # (some species contains multiple columns with same input) 
col_bio <- grepl("gene_biotype:", mat[1,])                                  # Locate gene biotype column
col_coord <- grepl("chromosome:|scaffold:", mat[1,])                        # Locate coordinate column
identical(nrow(mat), sum(grepl("gene_biotype:", mat[,col_bio])))            # Did you catch all?
identical(nrow(mat), sum(grepl("chromosome:|scaffold:", mat[,col_coord])))

new_names <- paste(mat[,ncol(mat)], mat[,1], mat[,col_bio], mat[,col_coord], sep="_") # Pick columns of your choice
names(ncrna) <- gsub("gene_symbol:|chromosome:BDGP6.28:|gene_biotype:", "",  new_names) # Clean up
Biostrings::writeXStringSet(ncrna, filepath=file_path, format="fasta")


```

You may also want to add tRNAs from the mitochrondrial genome to your tRNA
reference, which is not always provided in the GtRNAdb fasta. This can be done
by moving them from Ensembl ncRNA fasta or scan the mitochondrial genome
manually at [tRNAscan-SE](http://lowelab.ucsc.edu/tRNAscan-SE/). The
mitochonridal genome is found in the reference genome fasta.

```{r, eval=FALSE}
###---------------------------------------------------------------------
## Locate, fix names and add mito tRNA
trna_logi <- grepl("tRNA_mitochondrion_genome", names(ncrna))     # Locate mito tRNA
table(trna_logi) # Should be 22
mt_trna_ensembl <- ncrna[trna_logi,]
mt_trna <- gsub("mt:tRNA:", "MT-tRNA-", names(mt_trna_ensembl))
mt_trna <- gsub(":-1$", "_(-)", mt_trna) 
mt_trna <- gsub(":1$", "_(+)", mt_trna)
mt_trna <- gsub("_FBtr", "-FBtr", mt_trna)
mt_trna <- gsub(":", "-", mt_trna)
mt_trna <- gsub("_tRNA_mitochondrion_genome-", "_chrMT:", mt_trna) 

names(mt_trna_ensembl) <- mt_trna
trna <- c(trna, mt_trna_ensembl)
Biostrings::writeXStringSet(trna, filepath=paste0(ref_path, "/GtRNAdb/trna.fa"), format="fasta")

``` 

<br>

## 4.2 Indexing the fasta references 
Before we can use the fasta references we need to index them for the bowtie
aligner. You can do this by using the `bowtie_build` function in the Rbowtie
package or by running bowtie externally, outside R. For more information see
?Rbowtie::bowtie, Rbowtie::bowtie_build_usage() and
http://bowtie-bio.sourceforge.net/manual.shtml.

<br>
Important, the bowtie prefix must have the same basename (`prefix=`) and
the indexes must be saved in the same directory (`outdir=`) as the original
fasta file.

<br>
Building indexes may take some time for large fasta, such as a reference genome.
You only need to generate the index once for every fasta reference. Lets create
bowtie indexes for a few of the fasta references we downloaded:
```{r, eval = FALSE}
###---------------------------------------------------------------------
## Examples of generating bowtie indexes

ref_path <- "/home/danis31/Desktop/Temp_docs/fasta"
Rbowtie::bowtie_build(paste0(ref_path, "/biomartr_genome/chromsomes.fa"), 
                      outdir=paste0(ref_path, "/biomartr_genome/"), 
                      prefix="chromosomes", force=TRUE)
Rbowtie::bowtie_build(paste0(ref_path, "/biomartr_genome/scaffolds.fa"), 
                      outdir=paste0(ref_path, "/biomartr_genome/"), 
                      prefix="scaffolds", force=TRUE)
Rbowtie::bowtie_build(paste0(ref_path, "/GtRNAdb/trna.fa"), 
                      outdir=paste0(ref_path, "/GtRNAdb/"), 
                      prefix="trna", force=TRUE)
Rbowtie::bowtie_build(paste0(ref_path, "/ensembl_ncRNA/ncrna.fa"), 
                      outdir=paste0(ref_path, "/ensembl_ncRNA/"), 
                      prefix="ncrna", force=TRUE)
Rbowtie::bowtie_build(paste0(ref_path, "/mirbase/mirna.fa"), 
                      outdir=paste0(ref_path, "/mirbase/"), 
                      prefix="mirna", force=TRUE)

``` 

<br>

## 4.3 GTF feature coordinates
After the sequences has been mapped against a reference genome they can also
aquire annotations from genomic feature files, such as the gtf and gff formates.
These files contains the coordinates for different genomic features associated
with a specific reference genome, such as repetitative regions, exons and CpG
islands etc. Some functions in seqpac will require gtf files. Thus, it is
important to know how to handle them.

<br>
GTF files can often be aquired at the same places as the fasta reference files
(see above). The biomartr package also have functions for downloading some gtf
files and you can create your own by downloading different tables, for example
using rtracklayer. Here are some examples:

```{r, eval = FALSE}
###---------------------------------------------------------------------
## Get gene gtf using biomartr
dest_path <- file.path(ref_path, "/gtf/") # Only dir
gtf_path <- biomartr::getGTF(db="ensembl", organism = "Drosophila melanogaster", path=dest_path)
gtf <- tibble::as_tibble(rtracklayer::readGFF(gtf_path))

###---------------------------------------------------------------------
## Get repeatMasker gtf using biomartr (doesn't work for all species)
dest_path <- file.path(ref_path, "/repeatMasker/") # Only dir
rm_path <- biomartr::getRepeatMasker(db="refseq", organism = "Drosophila melanogaster", path=dest_path)
gtf <- tibble::as_tibble(rtracklayer::readGFF(gtf_path))

###---------------------------------------------------------------------
## Get repeatMasker table and manually turn it into gtf using rtracklayer
# Table names can be found at:
# https://genome.ucsc.edu/cgi-bin/hgTables
dest_path <- file.path(ref_path, "/repeatMasker/repeatMasker.gtf") # Full file path
if(!file.exists(dirname(dest_path))){dir.create(dirname(dest_path))}
session <- rtracklayer::browserSession("UCSC")
rtracklayer::genome(session) <- "dm6"
rm_tab <- tibble::as_tibble(rtracklayer::getTable(rtracklayer::ucscTableQuery(session, track="RepeatMasker", table="rmsk")))
gr <- GenomicRanges::GRanges(seqnames=rm_tab$genoName, IRanges::IRanges(rm_tab$genoStart, rm_tab$genoEnd), strand=rm_tab$strand)
GenomicRanges::mcols(gr)$type <- "repeat"
GenomicRanges::mcols(gr)$source <- "repeatMasker_dm6"
GenomicRanges::mcols(gr)$repName <- rm_tab$repName
GenomicRanges::mcols(gr)$repClass <- rm_tab$repClass
GenomicRanges::mcols(gr)$repFamily <- rm_tab$repFamily  
rtracklayer::export(gr, dest_path, format="gtf")

``` 

<br>

## 4.4 The reannotation workflow
Here are the details on how seqpac generates annotations presented.

<br>
The PAC reannotation family of functions carries out the following tasks:
| Task                                        | Function                              |
|:--------------------------------------------|:--------------------------------------|
| Map sequences against fasta references      | `map_reanno`;`import_reanno`          |
| Store the output on hard drive              | `map_reanno`                          |
| Read parts into R and create a reanno object| `make_reanno`                         |
| Generate an overview from the reanno object | `make_reanno`                         |
| Classify and simplify each annotations      | `add_reanno`; `simplify_reanno`       |
| Add new classifications to an PAC object    | `add_reanno`; `simplify_reanno`       |

<br>


### 4.4.1 The functions in the reanno workflow

<br>

**map_reanno**<br>
To accommodate most users on most platforms, seqpac provides two alternatives
for calling bowtie using the `map_reanno` function: internally from within R
(`type="internal"`) or externally from outside R (`type="external"`). In
the internal mode, seqpac uses the `bowtie` function in the Rbowtie package, while
in the external mode bowtie is called by a system command to a locally installed
version of bowtie. Both options gives identical results, but since the internal
Rbowtie package is rarely updated, we provide the external option.

<br>
Since the input commands for external bowtie and internal Rbowtie differs
slightly, `map_reanno` has two parse options: `parse_internal` and
`parse_external`. These can be used to control the two versions of bowtie
as if they were run from the console or command line, respectively.

<br>
While bowtie has its own way to handle mismatches in the alignments, seqpac
disregards this and instead runs bowtie sequentially, increasing the number of
mismatches for each cycle. After each cycle all sequences that recieved a match
in any of the provided references will be subtracted. Therefore, in the next
cycle only sequences without a match will be 'reannotated' but allowing one
additional mismatch. The `map_reanno` function controls this by sequentially
increasing the the number of mismatches after substracting the matches.

<br>

**import_reanno**<br>
This function is called by `map_reanno` to import the bowtie results after
each cycle. If you would run `import_reanno` separately it simply
provides you with options on how to import bowtie results into R. For example,
when aligning against a reference genome the mapping coordinates is important,
while mapping against more specialized references used for creating sRNA
classifications (rRNA, tRNA, miRNA etc), 'hit' or 'no hit' might be enough, and
will be a much faster option. The `map_reanno` function therefore has two
default import modes, import="genome" and import="biotype", which automatically
configure `import_reanno` for genome or class annotation.

<br>

**make_reanno**<br>
After each annotation cycle, `map_reanno` will store an .Rdata file
(Full_reanno_mis0/1/2/3.Rdata) containing a list with all alignment hits for
all PAC-sequence-to-fasta-reference alignments. Calling `map_reanno` will
search for the these .Rdata files in a given folder and create a reanno
object in R. This involves extracting, ordering and preparing annotations in a
format that can be merged with the existing Anno table in a PAC object. It will
also generate an overview table, that summarizes the annotations if multiple
fasta references were used in `map_reanno`.

<br>

**add_reanno**<br>
Before merging the new annotations with a PAC object, unless we have provided a
fasta reference with only one type (e.g. miRNA for mirBase), classification not
only *between* fasta references but also *within* references might be necessary
(e.g. snoRNA, tRNA, miRNA, rRNA in the Ensembl_ncRNA fasta). Classification of
the fasta reference names, which was first saved by bowtie and then caught in
our reanno object as an annotation, is done with the `add_reanno` function.
Again, there are two primary modes, either "genome" or "biotype". When
type="genome" a standardized workflow anticipating genomic coordinates are
applied. When type="biotype" a list of search term vectors directed against each
fasta reference needs to be provided. Matches between search term (written as
regular expressions) and substrings in fasta reference names will result in a
classification of the PAC sequence. Finally, `add_reanno` generates an
annotation table that can either be saved seperately or merged with the
original PAC object.

<br>

**simplify_reanno**<br>
While `add_reanno` starts the process of simplifying the reference name
annotations into useful classifications, it will generate multiple
classifications for each counted sequence if it matches multiple search terms.
The `simplify_reanno` function boils down multi-classifications into one
classification for each sequence. By doing so, an heirarchy must be set, where
priority of some classifications over others is done (e.g. miRNA over piRNA).
While this is a controversial topic, using such hierarchies is still the only
way to provide overview statistics in experiments targeting highly multimapping
sequences, such as small RNA. Nonetheless, the seqpac workflow with its sequence
based counts where hierarchical classification is done in the very end of the
annotation process, makes it easy to generate classifications using alternative
hierarchies and observe the consequences of your choices in for example a pie
chart.

<br>
In summary:
- **map_reanno**       Bowtie reference mapping over mismatch cycles 
- **import_reanno**    Used by `map_reanno` to import bowtie output after each cycle   
- **make_reanno**      Organizes `map_reanno` output into a reanno object
- **add_reanno**       Classifies annotations according to reference name
- **simplify_reanno**  Hierarchical classification

<br>

### 4.4.2 Reannotation in action
Lets observe the functions in action using the drosophila test dataset.

<br>
First we map against a reference genome, using `map_reanno`. Note that
import="genome" must be set to catch the genomic coordinates. Since
`map_reanno` can handle multiple fasta references, we provide both the
chromosomes and schaffold fasta that we generated previously. Remember, each
fasta must have bowtie indexes (see 4.2).

<br>
```{r, echo=FALSE, eval=FALSE}
library(seqpac)
load(system.file("extdata", "drosophila_sRNA_pac_filt.Rdata", package = "seqpac", mustWork = TRUE))
pac <- pac_cpm_filt

```
```{r, echo=FALSE, eval=FALSE}
###---------------------------------------------------------------------
## Genome mapping using external bowtie

# Provide paths to bowtie indexed fasta references as a list
# OBS! You must change the paths.

outpath_genome <- "/home/danis31/Desktop/Temp_docs/reanno_genome"    

ref_paths <- list(chromosomes="/home/danis31/Desktop/Temp_docs/fasta/biomartr_genome/chromosomes.fa",
                  scaffolds="/home/danis31/Desktop/Temp_docs/fasta/biomartr_genome/scaffolds.fa")

map_reanno(PAC=pac, ref_paths=ref_paths, output_path=outpath_genome, 
            type="external", mismatches=3, import="genome", threads=8, keep_temp=TRUE)

```

<br>
Similarly, we can map against other specialized references, that can be used for
classifying each sequence into biotypes. Note, unlike genome mapping, at this
stage we are not interested in where a sequence matches a reference for the
speciallized references, only if it matches or not. Thus, we use
`import="biotype"`.
```{r, echo=FALSE, eval=FALSE}
###---------------------------------------------------------------------
## sRNA mapping using internal bowtie

# Provide paths to bowtie indexed fasta references as a list
 # OBS! You must change ths paths.

outpath_biotype <- "/home/danis31/Desktop/Temp_docs/reanno_biotype"  


ref_paths <- list(miRNA="/home/danis31/Desktop/Temp_docs/fasta/mirbase/mirna.fa",
                   Ensembl="/home/danis31/Desktop/Temp_docs/fasta/ensembl_ncRNA/ncrna.fa",
                   tRNA="/home/danis31/Desktop/Temp_docs/fasta/GtRNAdb/trna.fa")

map_reanno(pac, ref_paths=ref_paths, output_path=outpath_biotype, 
            type="internal", mismatches=3,  import="biotype", threads=8, keep_temp=TRUE)

```

<br>
Now, the output .Rdata files for all mismatch cycles should have been stored in
the output folders. Lets import everything into R, generate a reanno list
objects and plot some pie charts from the Overview table.
```{r, message=FALSE, eval=FALSE}
###---------------------------------------------------------------------
## Generate a reanno object with make_reanno 

reanno_genome <- make_reanno(outpath_genome, PAC=pac, mis_fasta_check = TRUE)
reanno_biotype <- make_reanno(outpath_biotype, PAC=pac, mis_fasta_check = TRUE)

# Note, setting mis_fasta_check=TRUE will double check that the number of
# sequences that failed to recieve an alignment in the last mismatch cycle
# agrees with the number sequences in the reanno object without an annotation.
# (these sequences are stored in mis_fasta_x.txt where x is max mismatches+1)

# List structure
str(reanno_genome, max.level = 3, give.attr = FALSE)
str(reanno_biotype, max.level = 3, give.attr = FALSE)

# Simple pie charts using the Overview table
pie(table(reanno_genome$Overview$chromosomes))
pie(table(reanno_genome$Overview$scaffolds))
pie(table(reanno_biotype$Overview$Any))

```

<br>
Next step is to reorganize and classify using `add_reanno`. For mapping
against a reference genome this is easy. Just set type="genome" and set the
maximum number of alignments to be reported by `genome_max`
(Warning: `genome_max="all"` will give you all alignments).
```{r, message=FALSE, eval=FALSE}
###---------------------------------------------------------------------
### Genomic coordinates using add_reanno 

# Output separate tibble
anno_genome <- add_reanno(reanno_genome, type="genome", genome_max=10, mismatches=3)

# Output merged with provided PAC object
pac <- add_reanno(reanno_genome, type="genome", genome_max=10, mismatches=3, merge_pac=pac)

# Example of original reference name annotations 
head(reanno_genome$Full_anno$mis0$chromosomes)

# Finished genome annotation 
head(anno_genome)
head(pac$Anno)

```

<br>
For specialized references, `type="biotype"` should be used. This allows for
classification based on match or no match between the search terms provided in
the `bio_search` input and the reference names annotated with each counted
sequence. Correct classification is all about finding the best search terms that
discriminates between the different names in the original fasta reference files
(up to the first white space; see 4.1).

<br>
With the `bio_perfect` option you may control how conservative the matching
between search term and annotation should be. With `bio_perfect=FALSE`,
every reference hit that fail to match your search terms, will be classified as
'other'. Using `bio_perfect=TRUE` will instead guarantee that your search
terms will cover all reference hits.

<br>
Hint: See `?add_reanno` for a trick on how to succeed with `bio_perfect=TRUE`.
```{r, message=FALSE, eval=FALSE}
###---------------------------------------------------------------------
## Classify sequences using add_reanno 

# Lets start by exploring the names in the original fasta reference:

# Explore reference search terms
ref_path <- "/home/danis31/Desktop/Temp_docs/fasta"

Ensembl_ncrna <- names(Biostrings::readDNAStringSet(paste0(ref_path,"/ensembl_ncRNA/ncrna.fa")))
Ensembl_ncrna <- do.call("rbind", strsplit(Ensembl_ncrna, " "))[,1]        # Extract up to 1st white space
Ensembl_ncrna <- do.call("rbind", strsplit(Ensembl_ncrna, "\\:"))[,1]      # Expressions up to ":"
table(Ensembl_ncrna)           

trna <- names(Biostrings::readDNAStringSet(paste0(ref_path,"/GtRNAdb/trna.fa")))
table(do.call("rbind", strsplit(trna, "\\_"))[,1])  # Divide
table(do.call("rbind", strsplit(trna, "\\-"))[,1])  # Further division

mirna <- names(Biostrings::readDNAStringSet(paste0(ref_path,"/mirbase/mirna.fa")))
mirna <- do.call("rbind", strsplit(mirna, " "))[,1] # Extract up to 1st white space
table(do.call("rbind", strsplit(mirna, "\\-"))[,1]) # Divide


# Lets try two search term lists directed against each reference and written as
# 'regular expressions'
bio_search_1 <- list(
                 Ensembl=c("lncRNA", "pre_miRNA", "rRNA", "snoRNA", "snRNA", "tRNA"),
                 miRNA="dme-",
                 tRNA =c("^tRNA", "MT")      # ^= Regular expression for start of string  
                )

bio_search_2 <- list(
                 Ensembl=c("lncRNA", "miRNA", "pre_miRNA", "rRNA", "snoRNA", 
                           "snRNA", "tRNA", "Uhg", "7SLRNA", "asRNA", "hpRNA", 
                           "RNaseMRP","RNaseP", "sbRNA", "scaRNA", "sisRNA", 
                           "snmRNA", "snoRNA", "snRNA","Su\\(Ste\\)"), # ()= Brackets must be escaped  
                 miRNA="dme-",
                 tRNA =c("^tRNA", "MT") 
                )

# Throws an error because perfect matching is required:
anno_temp <- add_reanno(reanno_biotype, bio_search=bio_search_1, type="biotype", bio_perfect=TRUE, mismatches = 3)

# References with no search term hits are classified as "Other":
anno_temp <- add_reanno(reanno_biotype, bio_search=bio_search_1, type="biotype", bio_perfect=FALSE, mismatches = 3)

# Better search terms gives perfect matching and merge with PAC
pac <- add_reanno(reanno_biotype, bio_search=bio_search_2, type="biotype", bio_perfect=TRUE, mismatches = 3, merge_pac=pac)
table(pac$Anno$mis0_bio)

```

<br>
To make overview statistics and graphs we need to boil down the classifications
to a factor column with only a few unique biotypes per factor. This is what
`simplify_reanno` does. Just like `add_reanno` in the `type="biotype"` mode,
`simplify_reanno` needs a list of search terms, `hierarchy`. This time, however,
the list is order sensitive and targets the output table from `add_reanno` that
contains the columns with new classifications (e.g. "mis0_bio", "mis1_bio",
"mis2_bio" etc). If a match occurs between the first search term and a
classification, the counted sequence will be annotated to this classification,
no matter if other search terms matches further down the list. This is done
sequentially, allowing one additional mismatch until a maximum (specified in
`mismatches`) has been reached. Thus, if a match occurs in tRNA with 0 mismatch,
and rRNA with 1 mismatch, it will be reported as tRNA even though rRNA where
higher in the `hierarchy`. A better match will always be prioritized over the
hierarchy.

<br>
```{r, message=FALSE, eval=FALSE}
###---------------------------------------------------------------------
## Hierarchical classification with simplify_reanno

table(pac$Anno$mis0_bio)

# Set the hierarchy (remember: order senstive; rRNA >>>>> lncRNA)
hierarchy <- list(rRNA="Ensembl_rRNA",
                   Mt_tRNA="tRNA:MT",
                   tRNA="Ensembl_tRNA|tRNA__tRNA",
                   miRNA ="^miRNA|Ensembl_miRNA|Ensembl_pre_miRNA",
                   snoRNA="Ensembl_snoRNA",
                   lncRNA="Ensembl_lncRNA"   
                  )

# No mistmach allowed
pac <- simplify_reanno(input=pac, hierarchy=hierarchy, mismatches=0, bio_name="Biotypes_mis0", merge_pac=TRUE)

# Up to 3 mismatches allowed
pac <- simplify_reanno(input=pac, hierarchy=hierarchy, mismatches=3, bio_name="Biotypes_mis3", merge_pac=TRUE)

# Example of original reference name annotations 
head(reanno_biotype$Full_anno$mis0$Ensembl)

# Simplified hierarchical classification
head(pac$Anno)
table(pac$Anno$Biotypes_mis0)
table(pac$Anno$Biotypes_mis3)

``` 


<br>
<br>

---

# Analysis and visualization
There are several functions in seqpac that handle statistical analysis and
visualization. We will only present a few of them here, so please refer to
seqpac's reference manual for a complete list. Just like many of the
preprocessing functions, these functions are named PAC_xxx to clearly show that
they are applied on a PAC object. 

Hint: If you are unsure if your manually constructed/manipulated PAC object are
compatible, you can always run `PAC_check`.


## 5.1 Summarize data over groups
To make simple summaries over column categories/groups in the `PAC$Pheno` table
such as means, standard deviation (SD), standard error (SE), and log2 fold
changes (log2FC) etc, seqpac has a conventient function called
`PAC_summary`. This function uses a target_pheno object to target a column
in `PAC$Pheno` to generate a summary over the raw Counts or normalized counts.
Processed data will be stored in the `PAC$summary` folder.

*Important*, summarized data in the `PAC$summary` folder will always have the
same rownames (unique sequences) as `PAC$Counts` and `PAC$Anno`, while the
column names will be derived from `PAC$Pheno` object. Summarize using an
anno_target object is not allowed, because that would disrubt sequence names
(loss of sequence integrity). Summaries over sequences (such as generating means
over sRNA classes) is instead handled by each plotting/statistical function, and
are often stored in the output from these functions. Nonetheless, user may
always generate their own derived tables, using functions like `aggregate` and
`reshape::melt`.

Lets have some examples of how PAC_summary works:
```{r, message=FALSE, eval=FALSE}
library(seqpac)
load(system.file("extdata", "drosophila_sRNA_pac_filt_anno.Rdata", package = "seqpac", mustWork = TRUE))

###---------------------------------------------------------------------
## PAC_summary in seqpac 

# Make means of counts over stages and return a data.frame
tab <- PAC_summary(pac, norm = "counts", type = "means", 
                   pheno_target=list("stage"), merge_pac=FALSE)
head(tab[[1]]) 

# When merge_pac=TRUE the summarized table is added to the PAC$summary folder  
pac_test <- PAC_summary(pac, norm = "counts", type = "means", 
                        pheno_target=list("stage"), merge_pac=TRUE)

summary(pac)       # Structure of PAC before PAC_summary
summary(pac_test)  # Structure of PAC after PAC_summary
names(pac_test$summary)
head(pac_test$summary$countsMeans_stage)

# You may want to use normalized counts   
pac_test <- PAC_summary(pac_test, norm = "cpm", type = "means", 
                        pheno_target=list("stage"), merge_pac=TRUE)

# Maybe only include a subset of the samples
pac_test <- PAC_summary(pac_test, norm = "cpm", type = "means", 
                        pheno_target=list("batch", c("Batch1", "Batch2")), 
                        merge_pac=TRUE)

# Generate standard errors
pac_test <- PAC_summary(pac_test, norm = "cpm", type = "se", 
                        pheno_target=list("stage"), merge_pac=TRUE)

# log2FC
pac_test <- PAC_summary(pac_test, norm = "cpm", type = "log2FC",  
                        pheno_target=list("stage"), merge_pac=TRUE)

# log2FC generated from a grand mean over all samples
pac_test <- PAC_summary(pac_test, norm = "cpm", type = "log2FCgrand",  
                        pheno_target=list("stage"), merge_pac=TRUE)

# All summarize tables have identical rownames that can be merged
names(pac_test$summary)
lapply(pac_test$summary, function(x){
  identical(rownames(x), rownames(pac_test$summary[[1]]))
  })
head(do.call("cbind", pac_test$summary))

```

## 5.2 Differential Expression using PAC object 
Seqpac has a convenient function, `PAC_deseq`, that lets you make simple
omic scale expressional analysis on PAC objects using the popular
`DESeq2` package. This involves fitting generalized linear models with
negative binomial distribtions and subsequent correction for multiple testing
using the Pheno and Counts PAC tables. For more information (such as how to
correctly build models), please see the DESeq2 vingette:
https://bioconductor.org/packages/release/bioc/html/DESeq2.html.

In addition to preparing a PAC object for DESeq2, `PAC_deseq` will organize
and visualize the output. Lets have an example using the test dataset:


```{r, message=FALSE, eval=FALSE}
library(seqpac)
load(system.file("extdata", "drosophila_sRNA_pac_filt_anno.Rdata", package = "seqpac", mustWork = TRUE))

###---------------------------------------------------------------------
## Differential expression in seqpac 

# Simple model testing stages against using Wald test with local fit (default)
table(pac$Pheno$stage)
output_deseq <- PAC_deseq(pac, model= ~stage, threads=6)

# More complicated, but still graphs will be generated from 'stage' since it is first in model  
output_deseq <- PAC_deseq(pac, model= ~stage + batch)

# Using pheno_target we can change focus
output_deseq <- PAC_deseq(pac, model= ~stage + batch, pheno_target=list("batch")) # No batch effect 

# With pheno_target we can also change the direction fo the comparision change focus
output_deseq <- PAC_deseq(pac, model= ~stage, pheno_target=list("stage", c("Stage3", "Stage1"))) # Zygotic transcription has not started
output_deseq <- PAC_deseq(pac, model= ~stage, pheno_target=list("stage", c("Stage5", "Stage3"))) # Start of zygotic transcritption
output_deseq <- PAC_deseq(pac, model= ~stage, pheno_target=list("stage", c("Stage5", "Stage1"))) 

## In the output you find PAC merged results, target plots and output_deseq   
names(output_deseq)
tibble::as_tibble(output_deseq$result)


``` 


## 5.3 Principal component analysis (PAC_pca)
The `PAC_pca` function uses the FactoMineR package to make a principle component
analysis, from which scatter plots are plotted using the ggplot2 package. Here
are some examples on how to use PAC_pca:

```{r, results = "hide", eval=FALSE}
library(seqpac)
load(system.file("extdata", "drosophila_sRNA_pac_filt_anno.Rdata", package = "seqpac", mustWork = TRUE))

###---------------------------------------------------------------------
## PCA analysis in seqpac 

# As simple as possible 
output_pca <- PAC_pca(pac)
names(output_pca)  # Two folders: graphs and pca results

# Using pheno_target
output_pca <- PAC_pca(pac, pheno_target =list("stage"))

# Using pheno_target with sample labels
output_pca <- PAC_pca(pac, pheno_target =list("stage"), label=pac$Pheno$sample)

# Plotting sequences instead
output_pca <- PAC_pca(pac, type = "anno", anno_target =list("Biotypes_mis0"))

```

### 5.4 Size distribution and nucleotide bias
There are two function that can plot size distributions using the `ggplot2`
package:

-*PAC_nbias:*      First nuclotide bias
-*PAC_sizedist:*   (Biotype) size distribution

**PAC_nbias**<br>
First nuclotide bias can be visualzed without any advanced annotations added to
the `PAC$Anno` table:

```{r, include = TRUE, eval=FALSE}
###---------------------------------------------------------------------
## Nucleotide bias in seqpac 

# Using master pac plotting 1st nt bias (default)
load(system.file("extdata", "drosophila_sRNA_pac.Rdata", package = "seqpac", mustWork = TRUE))
output_nbias <- PAC_nbias(pac_master)
cowplot::plot_grid(plotlist=output_nbias$Histograms)

# Same but using filtered data
load(system.file("extdata", "drosophila_sRNA_pac_filt_anno.Rdata", package = "seqpac", mustWork = TRUE))
output_nbias <- PAC_nbias(pac)
cowplot::plot_grid(plotlist=output_nbias$Histograms)

# Only miRNA (Oops, heavy T-bias on 1st nt; are they piRNA?)  
table(pac$Anno$Biotypes_mis0)
output_nbias <- PAC_nbias(pac, anno_target = list("Biotypes_mis0", "miRNA") )
cowplot::plot_grid(plotlist=output_nbias$Histograms)

# Switch to 10:th nt bias
output_nbias <- PAC_nbias(pac, position=10, anno_target = list("Biotypes_mis0", "miRNA"))
cowplot::plot_grid(plotlist=output_nbias$Histograms)

# Summarized over group cpm means
pac_test <- PAC_summary(pac, norm = "cpm", type = "means", 
                        pheno_target=list("stage"), merge_pac=TRUE)
output_nbias <- PAC_nbias(pac_test, summary_target = list("cpmMeans_stage") )
cowplot::plot_grid(plotlist=output_nbias$Histograms)


```

<br>
**PAC_sizedist**<br>
The size distribution also works in a similar fashion, but instead diveds the
stacked columns using an anno_target:

```{r, message=FALSE, include = TRUE, eval=FALSE}
###---------------------------------------------------------------------
## Biotype size distribution

# Divide stacked bars by biotype with no mismach allowed  
output_sizedist_1 <- PAC_sizedist(pac, anno_target = list("Biotypes_mis0"))
cowplot::plot_grid(plotlist=c(output_sizedist_1$Histograms), ncol=3, nrow=3)

# Divide stacked bars by biotype with allowing up to 3 mismaches  
output_sizedist_2 <- PAC_sizedist(pac, anno_target = list("Biotypes_mis3"))
cowplot::plot_grid(plotlist=c(output_sizedist_2$Histograms), ncol=3, nrow=3)

# anno_target is order sensitive, thus can take care of color order issues:
ord_bio <- as.character(unique(pac$Anno$Biotypes_mis0))
ord_bio <- ord_bio[c(1,5,2,4,3,6,7)] 
output_sizedist_1 <- PAC_sizedist(pac, anno_target = list("Biotypes_mis0", ord_bio))
output_sizedist_2 <- PAC_sizedist(pac, anno_target = list("Biotypes_mis3", ord_bio))
cowplot::plot_grid(plotlist=c(output_sizedist_1$Histograms[1:3], output_sizedist_2$Histograms[1:3]), ncol=3, nrow=2)
cowplot::plot_grid(plotlist=c(output_sizedist_1$Histograms[4:6], output_sizedist_2$Histograms[4:6]), ncol=3, nrow=2)
cowplot::plot_grid(plotlist=c(output_sizedist_1$Histograms[7:9], output_sizedist_2$Histograms[7:9]), ncol=3, nrow=2)

## Note: #######################################################################
# 1. miRNA is clearly associated with the correct size (21-23) nt, which are   #
# dramatically increased in Stage 5 when zygotic transcription has started.    #
# 2. piRNA was deliberately left out from the fasta references. Note, however, #
# that there is a broad peak with no annotions between 20-30 nt in Stage 1,    #
# which also showed a T-bias at the first nt. These are likely piRNA.          #  
################################################################################

```


## 5.5 Simple stacked bars and pie charts
The `PAC_stackbar` and `PAC_pie` have the same arguments as input but with slightly
different outputs. None of them have target_summary input argument. Instead
summaries over groups in `PAC$Pheno` are controlled på the 'summary' argument.

    summary= "all"    | % are generate over a mean of all samples
    summary= "sample" | % are generate for each sample
    summary= "pheno"  | Group % are derived from the pheno_target object

<br>

**PAC_stackbar**<br>
```{r, message=FALSE, include = TRUE, eval=FALSE}
###---------------------------------------------------------------------
## Stacked bars in seqpac 

# Choose an anno_target and plot samples (summary="samples")
PAC_stackbar(pac, anno_target=list("Biotypes_mis0"))

# 'no_anno' and 'other' will always end on top not matter the order
ord_bio <- as.character(sort(unique(pac$Anno$Biotypes_mis3)))
p1 <- PAC_stackbar(pac, anno_target=list("Biotypes_mis0", ord_bio))
p2 <- PAC_stackbar(pac, anno_target=list("Biotypes_mis0", rev(ord_bio)))
cowplot::plot_grid(plotlist=list(p1, p2))
# (Hint: if you want them to appear not on top, rename them)

# Reorder samples by pheno_targets
PAC_stackbar(pac, pheno_target=list("batch"), summary="samples", anno_target=list("Biotypes_mis0"))

# Summarized over pheno_target 
# (as default PAC_stackbar orders by pheno_target but plots all samples, unless summary="pheno")
PAC_stackbar(pac, anno_target=list("Biotypes_mis0"), summary="pheno", pheno_target=list("stage"))

```

<br>

**PAC_pie**<br>
```{r, message=FALSE, include = TRUE, eval=FALSE}
###---------------------------------------------------------------------
## Pie chart in seqpac 

# Choose an anno_target and plot samples (summary="samples"; default)
output_pie <- PAC_pie(pac, anno_target=list("Biotypes_mis0"))
cowplot::plot_grid(plotlist=output_pie)

output_pie <- PAC_pie(pac, anno_target=list("Biotypes_mis3"))
cowplot::plot_grid(plotlist=output_pie, ncol=3, scale = 0.8)


# Make ordered pie charts of grand mean percent of all samples
ord_bio <- as.character(sort(unique(pac$Anno$Biotypes_mis3)), unique(pac$Anno$Biotypes_mis0))
output_pie_1 <- PAC_pie(pac, anno_target=list("Biotypes_mis0", ord_bio), summary="all")
output_pie_2 <- PAC_pie(pac, anno_target=list("Biotypes_mis3", ord_bio), summary="all")
cowplot::plot_grid(plotlist=c(output_pie_1, output_pie_2), nrow=2)

# Rotate
PAC_pie(pac, anno_target=list("Biotypes_mis0"), summary="all", angle=180)
PAC_pie(pac, anno_target=list("Biotypes_mis0"), summary="all", angle=40)

# Compare biotype mapping with or without mismaches and group by PAC$Pheno
# (Notice: all stages gains a lot of 'hidden' lncRNA by allowing mismatches)
ord_bio <- as.character(sort(unique(pac$Anno$Biotypes_mis0)))  # Make sure that both get same biotype order
output_mis0 <- PAC_pie(pac, pheno_target=list("stage"), summary="pheno", anno_target=list("Biotypes_mis0", ord_bio))
output_mis3 <- PAC_pie(pac, pheno_target=list("stage"), summary="pheno", anno_target=list("Biotypes_mis3", ord_bio))
cowplot::plot_grid(plotlist=c(output_mis0, output_mis3), labels = names(c(output_mis0, output_mis3)), nrow=2)


```

<br>
<br>

---

# Specilized analysis in seqpac
Seqpac functions may be used for more advanced analysis than simple
classification. For example, we can dwell deeper into the details between the
alignments of reads and references, by for example classify reads depending on
where it align. The best example of such advanced alignment analysis is tRNA
loop and range classification. We may also want to make further annotations of
specific classes of reads, such as classifying piRNA depending on overlap with
transposible elements and genes.

In the current version of this guide we have only included a section on how to
do advanced alignment analysis for the purpose of tRNA classification, but
please see the `PAC_gtf` function to for customized workflows for repeats and
ensembl gene analysis.

<br>

## 6.1 Advanced alignment analysis (tRNA class analysis)
So far, classification of sRNA has only involved whether reads align or not
align to for example a tRNA reference sequence. Type classification of tRNA,
such as 5', 3', i' and half, tRF (as best discribed in the MINTmap tool
\https://pubmed.ncbi.nlm.nih.gov/28220888/), resembles mapping against a
reference genome. Obtaining the exact coordinates of where a read align to the
reference allows us to plot coverage plots showing the coverage of sRNA across
the reference.

<br>
Conveniently, seqpac contains a backdoor to the reanno workflow, which allows
the user to quickly obtain mapping coordinates of sequences in a PAC object that
aligns to a refeference fasta file. This is done by the `PAC_mapper` function.
This wrapper uses temporary output files from bowtie to generate a map object,
which simply lists the reads that mapped to each sequence in the reference.

<br>
After a map object has been generated, the `PAC_covplot` function can make
coverage plots of reads mapping to each reference. Lets have a look on how it
works in seqpac for advanced tRNA analysis using the test dataset:

<br>
```{r, message=FALSE, include = TRUE, eval=FALSE}
library(seqpac)
load(system.file("extdata", "drosophila_sRNA_pac_filt_anno.Rdata", package = "seqpac", mustWork = TRUE))

###---------------------------------------------------------------------
## tRNA analysis in seqpac 

# First create an annotation blanc PAC with group means
pac$Anno <- pac$Anno[,1, drop=FALSE]
pac_trna <- PAC_summary(pac, norm = "cpm", type = "means", pheno_target=list("stage"), merge_pac = TRUE)

# Then reannotate only tRNA using the PAC_mapper function
ref <- "/home/danis31/Desktop/Temp_docs/fasta/GtRNAdb/trna.fa"  # Your path to tRNA fasta 
map_object <- PAC_mapper(pac_trna, ref=ref, N_up = "NNN", N_down = "NNN", mapper="reanno", mismatches=0, threads=8, report_string=TRUE)

### Hint:
# By adding N_up ad N_down you can make sure that modified fragments (like 3'
# -CAA in mature tRNA are included).

###---------------------------------------------------------------------
## Coverage plot of tRNA using PAC_covplot

# Single tRNA targeting a summary dataframe 
PAC_covplot(pac_trna, map=map_object, summary_target= list("cpmMeans_stage"), map_target="tRNA-Ala-AGC-1-1_chr3R:17657145-17657217_(+)")

# Find tRNAs with many fragments
n_tRFs <- unlist(lapply(map_object, function(x){nrow(x[[2]])}))
table(n_tRFs)
names(map_object)[n_tRFs>2]
selct <- (names(map_object)[n_tRFs>1])[c(1, 16, 25, 43)]
cov_plt <- PAC_covplot(pac_trna, map=map_object, summary_target= list("cpmMeans_stage"), map_target=selct)
cowplot::plot_grid(plotlist=cov_plt, nrow=2, ncol=2)


```

<br>
Now, tRNAs can be further classified into isodecoder and isoacceptors.
This information is usually provided within the reference names in a tRNA fasta
reference file. Thus, it can be extracted from these names. 

<br>
Classification of cleavage products, like 5'and 3' halves etc, are more
complicated. Such classification involves knowledge of where in the full tRNA
sequence loops (A-loop, anticodon loop and T-loop) are likely to occur. There
are external software that predict loop from models of secondary structures. One
of the most popular tools for predicting tRNA secondary structures are
tRNAscan-SE (http://lowelab.ucsc.edu/tRNAscan-SE/). The output from this
software is an ss file, which stores loop information in the following format:

    Full length tRNA: tRNA-Pro-CGG-2-1_chrX:18565764-18565835_(+)
    GGCTCGTTGGTCTAGAGGTATGATTCTCGCTTCGGGTGCGAGAGGTCCCGGGTTCAATTCCCGGACGAGCCC
    >>>>>>>..>>>.........<<<.>>>>>.......<<<<<.....>>>>>.......<<<<<<<<<<<<.
                  Loop 1           Loop 2                Loop 3                  

<br>
You may notice that each loop is contain between ">>>...<<<" and that each
character (".><") corresponds to one nucleotide in the original full length
tRNA. Ss-files for most common genomes are readily available for download at
http://gtrnadb.ucsc.edu/.

<br>
In seqpac, the `map_rangetype` function is used to futher annotate the resulting
map object obtained using the `PAC_mapper` function. First, if tRNA reference
names were provided in the correct tRNAscan-SE format (eg.
"tRNA-Pro-CGG-2-1_chrX:18565764-18565835_(+): format: name -> genome coordinates
-> strand), it will automatically extract the isodecoder (e.g. "Pro") and
isoacceptor (e.g. "CGG") and make them seperate factors. It may also classify
eached mapped PAC sequence in relation to the start and end terminals of the
full length tRNA. Lastly, given an ss file, it can annotate PAC sequences in
relation to tRNA loops. The `tRNA_class` function can then combine the
information in the mapping object and to classify each read sequence in the PAC
object. Lets have a look on how this is done:

<br>
```{r, message=FALSE, include = TRUE, eval=FALSE}

###---------------------------------------------------------------------
## Analyze range types with map_rangetype and PAC_trna functions

# Download ss object from GtRNAdb 
dest_path <- file.path("/home/danis31/Desktop/Temp_docs/fasta/GtRNAdb/trna.tar.gz")
download.file(url="http://gtrnadb.ucsc.edu/genomes/eukaryota/Dmela6/dm6-tRNAs.tar.gz", destfile=dest_path)
untar(dest_path, exdir= dirname(dest_path), files = "dm6-tRNAs-confidence-set.ss")
ss_file <- "/home/danis31/Desktop/Temp_docs/fasta/GtRNAdb/dm6-tRNAs-confidence-set.ss"

# Classify fragments according to loop cleavage (small loops are omitted)       
map_object_ss <- map_rangetype(map_object, type="ss", ss=ss_file, min_loop_width=4)            

# Remove reference tRNAs with no hits
map_object_ss <-  map_object_ss[!unlist(lapply(map_object_ss, function(x){x[[2]][1,1] == "no_hits"}))]
map_object_ss[[2]]


###---------------------------------------------------------------------
## Function classifying 5'-tRF, 5'halves, i-tRF, 3'-tRF, 3'halves

# Does all tRNAs have 3 loops?
table(unlist(lapply(map_object_ss, function(x){unique(x$Alignments$n_ssloop)})))

# Set tolerance for classification as a terminal tRF
tolerance <- 5  # 2 nucleotides from start or end of full-length tRNA)

### Important:
# We set N_up and N_down to "NNN" in the PAC_mapper step. To make sure
# that we have a tolerance that include the original tRNA sequence
# we set terminal= 2+3 (5).  

## tRNA classifying function 
# Apply the tRNA_class function and make a tRNA type column
pac_trna <- tRNA_class(pac_trna, map=map_object_ss, terminal=tolerance)
pac_trna$Anno$type <- paste0(pac_trna$Anno$decoder, pac_trna$Anno$acceptor)
head(pac_trna$Anno)

```

<br>
When classification by isoacceptor/decoder and cleavage type has been done, the
`PAC_trna` function can be applied to generate pheno group
differences in relation to tRNA fragmentation:

<br>
```{r, message=FALSE, include = TRUE, eval=FALSE}

###---------------------------------------------------------------------
## Plotting tRNA types

# Now use PAC_trna to generate some graphs based on grand means
trna_result <- PAC_trna(pac_trna, norm="cpm", filter = NULL,
  join = TRUE, top = 15, log2fc = TRUE,
  pheno_target = list("stage", c("Stage1", "Stage3")), 
  anno_target_1 = list("type"),
  anno_target_2 = list("class"))

names(trna_result)
names(trna_result$plots)
names(trna_result$plots$Expression_Anno_1)

cowplot::plot_grid(trna_result$plots$Expression_Anno_1$Grand_means,
                   trna_result$plots$Log2FC_Anno_1,
                   trna_result$plots$Percent_bars$Grand_means,
                   nrow=1, ncol=3)

# By setting join = FALSE you will get group means
trna_result <- PAC_trna(pac_trna, norm="cpm", filter = NULL,
  join = FALSE, top = 15, log2fc = TRUE,
  pheno_target = list("stage", c("Stage1", "Stage3")), 
  anno_target_1 = list("type"),
  anno_target_2 = list("class"))

names(trna_result$plots$Expression_Anno_1)

cowplot::plot_grid(trna_result$plots$Expression_Anno_1$Stage1,
                   trna_result$plots$Expression_Anno_1$Stage3,
                   trna_result$plots$Log2FC_Anno_1,
                   trna_result$plots$Percent_bars$Stage1,
                   trna_result$plots$Percent_bars$Stage3,
                   nrow=1, ncol=5)

```


