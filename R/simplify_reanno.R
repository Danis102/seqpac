#'Generates one-hit hierarchial biotype annotation
#'
#'\code{simplify_reanno} adds biotypes from reannotation to PAC.
#'
#'This function deals with and can be used to explores the effect of
#'multimapping. Given a biotype reannotation matrix (colnames: mis0_bio,
#'mis1_bio, mis2_bio etc) created by \code{add_reanno} and usually added to the
#'Anno dataframe of a PAC object, the function will generated a one-hit biotype
#'vector according to a user-defined biotype hierarchy.
#'
#'@family PAC reannotation
#'
#'@seealso 
#'  \url{http://bowtie-bio.sourceforge.net/index.shtml} for information about
#'  Bowtie \url{https://github.com/Danis102} for updates on the current package.
#'
#'@param Input Dataframe with biotype/mismatch matrix generated by
#'  \code{add_reanno}. A PAC-list object can also be provided here where the
#'  Anno dataframe will be used as input.
#'
#'@param hierarchy List with character vectors. The vectors search terms
#'  constructed as regular expressions that will be parsed to grepl() and
#'  searched for in the mismatch/biotype reannotation matrix. Important
#'  \emph{hierarchy} is order sensitive. For example if \emph{hierarchy} is
#'  defined as list(rRNA="rRNA", miRNA="miRNA", piRNA="piRNA") a sequence
#'  annotated with 0 mismatches for all three biotypes will only be reported as
#'  rRNA since this biotype was put first in the list. Sequences annotated to
#'  neither of the biotypes listed in \emph{hierarchy} but still is annotated to
#'  something will be asigned as "other". Sequences without an annotation down
#'  to the specified mismatch level (\code{mismatches} will be asigned as
#'  "no_anno".
#'  
#'@param mismatches Integer indicating the number of allowed mismatches. Note
#'  that this value can never be larger than the maximum number of mismatches
#'  used in the reannotation workflow (default=0).
#'
#'@param bio_name Character naming the final biotype column (default="Biotype")
#'
#'@param merge_pac Logical whether the simplified annotation column should
#'  automatically be added to the Anno object if a PAC list object were given as
#'  input (default=FALSE). Alternatively, if a PAC object is provided in
#'  merge_pac, the simplified column will be added to the Anno table for this
#'  PAC object.
#'  
#'@return Character vector with single best-hit biotypes with fewest mismatches.
#'  
#'@examples
#'
#'
#'#-------------------------------------------------------------------------------------------------#
#'# Simplify and make hierarchy of reannotation 
#'#-------------------------------------------------------------------------------------------------#
#' library(seqpac)
#' load(system.file("extdata", "drosophila_sRNA_pac.Rdata", package = "seqpac", mustWork = TRUE))
#' 
#' # Build hierarchy with regular expressions:
#' hierarchy <- list(rRNA="Ensembl_rRNA",
#'                   Mt_tRNA="tRNA_mt:tRNA",
#'                   tRNA="Ensembl_tRNA|tRNA_\\^tRNA",
#'                   miRNA ="^miRNA|Ensembl_miRNA|Ensembl_pre_miRNA"
#'                  )
#'
#'pac_master <- simplify_reanno(pac_master, hierarchy=hierarchy, mismatches=0, bio_name="Biotypes_mis0", merge_pac=TRUE)
#'
#'PAC_check(pac_master)
#'
#' 
#' @export

simplify_reanno <- function(input, hierarchy, mismatches=2, bio_name="Biotypes", merge_pac=FALSE, target_columns=NULL){
  
  ### Prepare:
  if(sum(names(input)[1:3] == c("Pheno", "Anno", "Counts"))==3){
    anno <- input$Anno
  }else{ 
    anno <- input}
  
  if(is.null(target_columns)){
    logi_colnam <- grepl("^mis0_bio", colnames(anno))
    if(sum(logi_colnam)>1){
      stop("\nThere were multiple columns starting with 'mis0_bio' indiciating multiple rounds of \nbiotype reannotation. Please, rename the columns (do not repeatively use 'mis0_bio')\nor use the 'target_columns' input to specify which of these columns that should be \nsimplified (eg. target_columns= c('mis0_bio2, mis1_bio2, mis2_bio2, mis3_bio2').")
    }
    if(sum(logi_colnam)<1){ 
       stop("\nYour input did not contain a 'mis0_bio' column. Please, add \na mismatch/biotype reannotation matrix using add_reanno, which will\n generate the correct column names, before running this function.")
    }
    logi_colnam  <- grepl(paste(paste0("mis", 0:mismatches, "_bio"), collapse="|"), colnames(anno))
    mis_col <- sum(grepl(paste(paste0("mis", 0:10, "_bio"), collapse="|"), colnames(anno)))
    cat(paste0("\nNumber of mismatches specified by user: ", mismatches, "\t(max available: ", mis_col-1,")"))
  }
  if(!is.null(target_columns)){
    logi_colnam <- colnames(anno) %in% target_columns
    if(!sum(logi_colnam) == length(target_columns)){
      stop("\nYour names in target_columns did not match input column names.\nPlease double check spelling or (re)run add_reanno to generate \ncompatible column names.")
    }
    if(!is.null(mismatches)){
      warning("You specifed columns in target_columns. By doing so the function \nwill disregard the mismatches option and instead simplify by \nmerging the target_columns.") 
      }
    }
  anno_mat <- anno[,logi_colnam, drop=FALSE]
  anno_vect <- apply(anno_mat, 1, function(x){paste(x, collapse="|")})
  
  ### Report the results:   
  anno_vect_uni <- unique(do.call("c", strsplit(anno_vect, ";|\\|")))
  cat(paste0("\nBiotypes will be asigned as follows:\n"))
  catg <- do.call("rbind", lapply(hierarchy, function(x){paste(anno_vect_uni[grepl(x, anno_vect_uni)], collapse=", ")}))
  colnames(catg) <- "Original_biotypes"
  other <- anno_vect_uni[!anno_vect_uni %in% c(do.call("c", strsplit(catg[,1], ", ")), "_")]
  if(length(other) == 0){ other <- "<NA>"}
  catg <- rbind(catg, data.frame(row.names=c("other", "no_anno") , Original_biotypes=c(paste(other, collapse=", "), "_"))) 
  catg <- data.frame(Simplified_biotype=rownames(catg), Hierarchy=1:(nrow(catg)), Original_biotypes=catg[,1])
  print(catg)
  
  ### Extract simplified biotypes:
  df_hits <- data.frame(matrix(NA, nrow=length(anno_vect), ncol=nrow(catg)), row.names=names(anno_vect))
  colnames(df_hits) <- catg$Simplified_biotype
  search_terms <- as.character(catg$Original_biotypes)
  if(any(duplicated(unlist(strsplit(paste0(search_terms, collapse=", "), ", "))))){stop("\nAborted! Search terms overlap multiple biotype categories.\nPlease double check the asignments.")}  
  search_terms <- gsub(", ", "|", search_terms) 
  for(i in 1:length(search_terms)){
    df_hits[,i]  <- ifelse(grepl(search_terms[i], anno_vect), as.character(catg$Simplified_biotype[i]), "no_hit")
  }
  vect_hits <- apply(df_hits, 1, function(x){paste(x, collapse="|")}) 
  vect_hits <- gsub("no_hit\\||\\|no_hit", "", vect_hits)
  bio_vect_lst <- lapply(as.list(vect_hits), function(x){
    splt  <- do.call("c", strsplit(x, "\\|"))
    return(splt[1])
  })
  bio_vect_fin <- as.data.frame(do.call("c", bio_vect_lst))
  colnames(bio_vect_fin) <- bio_name
  if(sum(names(merge_pac)[1:3] == c("Pheno", "Anno", "Counts"))==3){
    input <- merge_pac
    input$Anno <- cbind(input$Anno, bio_vect_fin)
  }else{  
  if(merge_pac==FALSE){
    input <- bio_vect_fin
  }
  if(merge_pac==TRUE){  
    stopifnot(identical(rownames(input$Anno), rownames(bio_vect_fin))) 
    input$Anno <- cbind(input$Anno, bio_vect_fin)
    }
  }
    return(input)
}