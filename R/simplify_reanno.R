#' Generates one-hit hierarchial biotype annotation
#'
#'\code{simplify_reanno} adds hierarchical classification to PAC.
#'
#'This function deals with and can be used to explores the effect of
#'multimapping. Given a biotype reannotation matrix (colnames = mis0_bio,
#'mis1_bio, mis2_bio etc) created by \code{\link{add_reanno}} and usually added
#'to the Anno data.frame of a PAC object, the function will generated a one-hit
#'biotype vector according to a user-defined biotype hierarchy.
#'
#'@family PAC reannotation
#'
#'@seealso 
#'  \url{http://bowtie-bio.sourceforge.net/index.shtml} for information about
#'  Bowtie \url{https://github.com/Danis102} for updates on the current package.
#'
#'@param input Data.frame with biotype/mismatch matrix generated by
#'  \code{add_reanno}. A PAC-list object can also be provided here where the
#'  Anno data.frame will be used as input. Important, PAC objects need biotype
#'  columns generated by \code{\link{add_reanno}}.
#'
#'@param hierarchy List with character vectors. The vectors search terms
#'  constructed as regular expressions that will be parsed to grepl() and
#'  searched for in the mismatch biotype reannotation matrix (colnames:
#'  mis0_bio, mis1_bio, mis2_bio, mis3_bio). Important \emph{hierarchy} is order
#'  sensitive. For example if \emph{hierarchy} is defined as list(rRNA="rRNA",
#'  miRNA="miRNA", piRNA="piRNA") a sequence annotated with 0 mismatches for all
#'  three biotypes will only be reported as rRNA since this biotype was put
#'  first in the list. Sequences annotated to neither of the biotypes listed in
#'  \emph{hierarchy} but still is annotated to something will be asigned as
#'  "other". Sequences without an annotation down to the specified mismatch
#'  level (\code{mismatches} will be asigned as "no_anno".
#'  
#'@param mismatches Integer indicating the number of allowed mismatches. Note
#'  that this value can never be larger than the maximum number of mismatches
#'  used in the reannotation workflow (default=0).
#'
#'@param bio_name Character naming the final biotype column (default="Biotype")
#'
#'@param target_columns Character vector naming the target columns for the
#'  reannotation matrix. When \code{target_columns=NULL}(default), then the
#'  function assumes that one (and only one) reannotation matrix for biotypes
#'  generatated by \code{\link{add_reanno}} is present in PAC$Anno (colnames =
#'  mis0_bio, mis1_bio, mis2_bio etc). With \code{target_columns} two
#'  alternative reannotation matrixes can be discriminated.
#'  
#'@param merge_pac Logical whether the simplified annotation column should
#'  automatically be added to the Anno object if a PAC list object were given as
#'  input (default=FALSE). Alternatively, if a PAC object is provided in
#'  merge_pac, the simplified column will be added to the Anno table for this
#'  PAC object.
#'  
#'@return Character vector with single best-hit biotypes with fewest mismatches.
#'  
#'@examples
#'
#' \dontrun{
#' 
#' # Read prepared PAC object:
#' library(seqpac)
#' load(system.file("extdata", "drosophila_sRNA_pac_filt.Rdata", 
#'                  package = "seqpac", mustWork = TRUE))
#' pac <- pac_cpm_filt
#' 
#' ##--------------------------------------------------------------------------#
#' ## Example biotype classification allowing 1 mismatch
#' ##--------------------------------------------------------------------------#
#' 
#' # Path to bowtie indexed fasta references:   
#' ref_paths <- list(miRNA="/some/path/to/miRNA.fa",
#'                   Ensembl="/some/path/to/ensembl.ncrna.fa",
#'                   rRNA="/some/path/to/rRNA.fa",
#'                   tRNA="/some/path/to/tRNA.fa",
#'                   piRNA="/some/path/to/piRNA.fa")
#' 
#' # Path to output folder:
#' output_bio <- "/some/path/to/output_folder/"
#' 
#' # Run map_reanno for biotype classification:
#' map_reanno(pac, ref_paths=ref_paths, output_path=output_bio, 
#'            type="external", mismatches=1,  import="biotype")
#' 
#' # Import map_reanno output into a reanno-object using make_reanno:
#' reanno <- make_reanno(reanno_path=output_bio, PAC=pac, mis_fasta_check = TRUE)
#' names(reanno)
#' names(reanno$Full_anno)
#' 
#' 
#' # Make search terms (regular expressions) where hits create annotations:  
#' bio_search <- list(
#'                 miRNA="dme-",
#'                 Ensembl =c("lincRNA", "miRNA", "pre_miRNA", "rRNA", "snoRNA", 
#'                           "snRNA", "tRNA", "Uhg", "7SLRNA", "asRNA", "hpRNA", 
#'                           "RNaseMRP","RNaseP", "sbRNA", "scaRNA", "sisRNA", 
#'                           "snmRNA", "snoRNA", "snRNA","Su\\(Ste\\)"),
#'                 rRNA    =c("5.8S", "28S", "18S"),
#'                 tRNA    =c("^tRNA", "MT"),
#'                 piRNA   =c("piR-"))
#' 
#' # Classify by search term using add_reanno:
#' pac <- add_reanno(reanno, merge_pac=pac, bio_search=bio_search, 
#'                   type="biotype", bio_perfect=FALSE, mismatches = 1)
#' head(pac$Anno)           # Note: two misX_bio ("mis0_bio" and "mis1_bio")
#' table(pac$Anno$mis0_bio) # Annotations with 0 mismatches
#' 
#' 
#' 
#' ##--------------------------------------------------------------------------#
#' ## The trick to succeed with bio_perfect=TRUE
#' ##--------------------------------------------------------------------------#
#' 
#' # Run add_reanno with bio_perfect="FALSE" (look where "Other=XX" occur):
#' bio_search <- list(
#'                 miRNA="dme-",
#'                 Ensembl =c("miRNA", "pre_miRNA", "rRNA", "snoRNA", 
#'                           "snRNA", "tRNA", "Uhg", "7SLRNA", "asRNA", "hpRNA", 
#'                           "RNaseMRP","RNaseP", "sbRNA", "scaRNA", "sisRNA", 
#'                           "snmRNA", "snoRNA", "snRNA","Su\\(Ste\\)"),
#'                 rRNA    =c("5.8S", "28S", "18S", "rRNA"),
#'                 tRNA    =c("^tRNA"),
#'                 piRNA   =c("piR-"))
#' 
#' anno <- add_reanno(reanno, bio_search=bio_search, type="biotype", 
#'                    bio_perfect=FALSE, mismatches = 1)
#' 
#' # Find sequences that has been classified as other: 
#' other_seqs  <- anno[grepl("other", anno$mis0_bio),]$seq_bio
#' tab <- reanno$Full_anno$mis0$Ensembl
#' tab[tab$seq %in% other_seqs,]         # lincRNA don't have a search term
#' 
#' 
#' # Add a search terms that catches all lincRNA: 
#' bio_search <- list(
#'                 miRNA="dme-",
#'                 Ensembl =c("lincRNA", "miRNA", "pre_miRNA", "rRNA", "snoRNA", 
#'                           "snRNA", "tRNA", "Uhg", "7SLRNA", "asRNA", "hpRNA", 
#'                           "RNaseMRP","RNaseP", "sbRNA", "scaRNA", "sisRNA", 
#'                           "snmRNA", "snoRNA", "snRNA","Su\\(Ste\\)"),
#'                 rRNA    =c("5.8S", "28S", "18S", "rRNA"),
#'                 tRNA    =c("^tRNA"),
#'                 piRNA   =c("piR-"))
#'                 
#' anno <- add_reanno(reanno, bio_search=bio_search, type="biotype", 
#'                    bio_perfect=FALSE, mismatches = 1)
#' 
#' # Repeat search until no "Other" appear, then run  bio_perfect=TRUE: 
#' anno <- add_reanno(reanno, bio_search=bio_search, type="biotype", 
#'                    bio_perfect=TRUE, mismatches = 1)
#' 
#' 
#' ##--------------------------------------------------------------------------#
#' ## Hierarchical classification with simplify_reanno
#' ##--------------------------------------------------------------------------#
#' table(pac$Anno$mis0_bio)
#' 
#' # Setup hierarchy 
#' hierarchy <- list( rRNA="Ensembl_rRNA|rRNA_other|rRNA_5.8S|rRNA_28S|rRNA_18S",
#'                    Mt_tRNA="tRNA:MT",
#'                    tRNA="Ensembl_tRNA|tRNA__tRNA",
#'                    miRNA ="^miRNA|Ensembl_miRNA|Ensembl_pre_miRNA",
#'                    snoRNA="Ensembl_snoRNA",
#'                    lncRNA="Ensembl_lincRNA",
#'                    piRNA="piRNA"   
#'                   )
#' 
#' # No mistmach allowed
#' pac <- simplify_reanno(input=pac, hierarchy=hierarchy, mismatches=0, 
#'                       bio_name="Biotypes_mis0", merge_pac=TRUE)
#' 
#' # Up to 1 mismatches allowed
#' pac <- simplify_reanno(input=pac, hierarchy=hierarchy, mismatches=1, 
#'                        bio_name="Biotypes_mis1", merge_pac=TRUE)
#' 
#' }
#'
#' 
#' @export

simplify_reanno <- function(input, hierarchy, mismatches=2, bio_name="Biotypes", 
                            merge_pac=FALSE, target_columns=NULL){
  
  ### Prepare:
  if(sum(names(input)[1:3] == c("Pheno", "Anno", "Counts"))==3){
    anno <- input$Anno
  }else{ 
    anno <- input}
  
  if(is.null(target_columns)){
    logi_colnam <- grepl("^mis0_bio", colnames(anno))
    if(sum(logi_colnam)>1){
      stop(
           "\nThere were multiple columns starting with 'mis0_bio' ",
           "\nindiciating multiple rounds of biotype reannotation.",
           "\nPlease, rename the columns (do not repeatively use ",
           "\n'mis0_bio')or use the 'target_columns' input to specify",
           "\nwhich of these columns that should be simplified (eg. ",
           "\ntarget_columns= c('mis0_bio2, mis1_bio2, mis2_bio2, mis3_bio2').")
    }
    if(sum(logi_colnam)<1){ 
       stop(
         "\nYour input did not contain a 'mis0_bio' column. Please, add",
         "\na mismatch/biotype reannotation matrix using add_reanno, ",
         "\nwhich will generate the correct column names, before running",
         "\nthis function.")
    }
    logi_colnam  <- grepl(paste(paste0("mis", 0:mismatches, "_bio"), 
                                collapse="|"), colnames(anno))
    mis_col <- sum(grepl(paste(paste0("mis", 0:10, "_bio"), collapse="|"), 
                         colnames(anno)))
    cat(paste0("\nNumber of mismatches specified by user: ", 
               mismatches, "\t(max available: ", mis_col-1,")"))
  }
  if(!is.null(target_columns)){
    logi_colnam <- colnames(anno) %in% target_columns
    if(!sum(logi_colnam) == length(target_columns)){
      stop(
        "\nYour names in target_columns did not match input column names.",
        "\nPlease double check spelling or (re)run add_reanno to generate",
        "\ncompatible column names.")
    }
    if(!is.null(mismatches)){
      warning(
        "You specifed columns in target_columns. By doing so the function",
        "\nwill disregard the mismatches option and instead simplify by",
        "\nmerging the target_columns.") 
      }
    }
  anno_mat <- anno[,logi_colnam, drop=FALSE]
  anno_vect <- apply(anno_mat, 1, function(x){paste(x, collapse="|")})
  
  ### Report the results:   
  anno_vect_uni <- unique(do.call("c", strsplit(anno_vect, ";|\\|")))
  cat(paste0("\nBiotypes will be asigned as follows:\n"))
  catg <- do.call("rbind", lapply(hierarchy, function(x){
    paste(anno_vect_uni[grepl(x, anno_vect_uni)], collapse=", ")}))
  colnames(catg) <- "Original_biotypes"
  other <- anno_vect_uni[!anno_vect_uni %in% c(
    do.call("c", strsplit(catg[,1], ", ")), "_")]
  if(length(other) == 0){ other <- "<NA>"}
  catg <- rbind(catg, data.frame(
    row.names=c("other", "no_anno") , 
    Original_biotypes=c(paste(other, collapse=", "), "_"))) 
  catg <- data.frame(
    Simplified_biotype=rownames(catg), 
    Hierarchy=1:(nrow(catg)), 
    Original_biotypes=catg[,1])
  print(catg)
  
  ### Extract simplified biotypes:
  df_hits <- data.frame(matrix(
    NA, nrow=length(anno_vect), ncol=nrow(catg)), row.names=names(anno_vect))
  colnames(df_hits) <- catg$Simplified_biotype
  search_terms <- as.character(catg$Original_biotypes)
  search_terms[nchar(search_terms) == 0] <- "xkFTGWQd$[}))$jks"
  
  if(any(duplicated(
    unlist(strsplit(paste0(search_terms, collapse=", "), ", "))))){
    stop(
      "\nAborted! Search terms overlap multiple biotype categories.",
      "\nPlease double check the asignments.")
    }  
  search_terms <- gsub(", ", "|", search_terms) 
  for(i in 1:length(search_terms)){
    if(search_terms[i]=="xkFTGWQd$[}))$jks"){
      df_hits[,i]  <- "no_hit"
    }else{
      df_hits[,i]  <- ifelse(grepl(search_terms[i], anno_vect), 
                             as.character(catg$Simplified_biotype[i]), "no_hit")
    }
  }
  vect_hits <- apply(df_hits, 1, function(x){
    paste(x, collapse="|")
    }) 
  vect_hits <- gsub("no_hit\\||\\|no_hit", "", vect_hits)
  bio_vect_lst <- lapply(as.list(vect_hits), function(x){
    splt  <- do.call("c", strsplit(x, "\\|"))
    return(splt[1])
  })
  bio_vect_fin <- as.data.frame(do.call("c", bio_vect_lst))
  colnames(bio_vect_fin) <- bio_name
  if(sum(names(merge_pac)[1:3] == c("Pheno", "Anno", "Counts"))==3){
    input <- merge_pac
    input$Anno <- cbind(input$Anno, bio_vect_fin)
  }else{  
  if(merge_pac==FALSE){
    input <- bio_vect_fin
  }
  if(merge_pac==TRUE){  
    stopifnot(identical(rownames(input$Anno), rownames(bio_vect_fin))) 
    input$Anno <- cbind(input$Anno, bio_vect_fin)
    }
  }
  return(input)
}