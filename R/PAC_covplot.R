#' Plot sequence covarage over a reference
#'
#' \code{PAC_covplot} Plotting sequences in a PAC object using an PAC mapping object.
#'
#' Given a PAC object and a PAC_map object generated by \emph{PAC_mapping}
#' this function will attempt to plot the sequence coverage over long
#' references.
#'
#' @family PAC analysis
#'   
#' @seealso \url{https://github.com/Danis102} for updates on the current
#'   package.
#'
#' @param PAC PAC-list object.
#'
#' @param PAC_map PAC_map object generated by \emph{PAC_mapping}.
#'
#' @param summary_target List with 2 character vectors: 
#'   1st object: Character indicating the name of the target PAC summary object
#'   which should be used as input data for the plots. If left empty the 1st
#'   summary object will be used.
#'   2nd object: Character vector indicating the names of the columns in the
#'   summary object from which individual graphs should be plotted. If left
#'   empty all summary columns are plotted in the same graph.
#'   Summaries are generated by the PAC_summary function or customly generated
#'   by the user and stored in the summary 'folder' of a PAC object.
#'   
#' @param map_target (optional) Character vector. Imporant: This is similar to
#'   an anno_target, but instead extracts target references in the PAC_mapping
#'   object. Should contain search terms that can find unique strings in the
#'   reference names. The search terms are parse to grepl("<search terms>,
#'   names(<PAC_mapping object>)). (default=NULL)
#'
#' @param xseq Logical indicating whether the nucleotides should be plotted on
#'   the x-axis. Plotting long references with xseq=FALSE will increase
#'   script performance. (default=TRUE).
#'
#' @param color Character vector indicating the rgb colors to be parsed to
#'   ggplot2 for plotting the covarage lines  (default = c("black", "red",
#'   "grey", "blue"))
#'   
#' @return Plot list with plots generated by ggplot2
#'
#' @examples
#' 
#' ### Load data ###
#' path="/data/Data_analysis/Projects/Drosophila/Other/IOR/Joint_analysis/R_analysis/"
#' load(file=paste0(path, "PAC_all.Rdata"))
#' 
#' PAC_filt <- PAC_filter(PAC_all, size=c(16,70), threshold=10, coverage=5, type="counts", stat=FALSE, pheno_target=NULL, anno_target=NULL)
#' PAC_filt <- PAC_rpm(PAC_filt)
#' PAC_filt <- PAC_filter(PAC_filt, size=c(16,70), threshold=10, coverage=5, type="rpm", stat=FALSE, pheno_target=NULL, anno_target=NULL)
#' 
#' ## Remove corrupt samples and make means 
#' Ph_trg <- as.character(PAC_filt$Pheno$Sample[!PAC_filt$Pheno$Sample %in% "Inx24_200130_S12"])
#' PAC_filt <- PAC_filter(PAC_filt, pheno_target= list("Sample", Ph_trg))
#' 
#' PAC_filt$Pheno$Groups <- paste(do.call("rbind", strsplit(as.character(PAC_filt$Pheno$SampleProject), "_" ))[,1], PAC_filt$Pheno$Method, PAC_filt$Pheno$Method_tag, PAC_filt$Pheno$Tag, sep="_")
#' 
#' ## Make summaries
#' PAC_filt <- PAC_summary(PAC_filt, norm = "rpm", type = "means", pheno_target=list("Groups", unique(PAC_filt$Pheno$Groups)))
#' 
#' ## Mapping
#' map_rRNA <- PAC_mapper(PAC_filt, ref_path="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/rRNA_reanno/drosophila_rRNA_all.fa", threads=12)
#' 
#' All_plots <- lapply(as.list(Smry_trg_all), function(x){PAC_covplot(PAC_filt, map_rRNA, summary_target = list("means_[Groups]", x), xseq=FALSE, style="line", color="red")})
#'
#' cowplot::plot_grid(All_plots[[1]][[7]], All_plots[[2]][[7]], All_plots[[3]][[7]], 
#'                   All_plots[[4]][[7]], All_plots[[5]][[7]], All_plots[[6]][[7]],
#'                   All_plots[[7]][[7]], All_plots[[8]][[7]], All_plots[[9]][[7]], 
#'                   All_plots[[10]][[7]], All_plots[[11]][[7]], All_plots[[12]][[7]],
#'                   All_plots[[13]][[7]], All_plots[[14]][[7]], All_plots[[15]][[7]],
#'                   nrow = 5, ncol = 3)
#' 
#' 
#'
#' 
#' @export

PAC_covplot <- function(PAC, map, summary_target=names(PAC), map_target=NULL, style="line", xseq=TRUE, color=c("black", "red", "grey", "blue")){
                            require("GenomicRanges")
                            require("ggplot2")
                            require("stringr")
                            if(is.null(summary_target[[1]])){stop("Error: You need to specify a target object in PAC$summary with summary_target.")}
                            if(is.null(names(PAC$summary[[summary_target[[1]]]]))){stop("You need to specify a valid summary_target.\n(Hint: Double check correct object name in PAC$summary or rerun the 'PAC_summary' function.)")}
                            if(length(summary_target)==1){summary_target[[2]] <- names(PAC$summary[[summary_target[[1]]]])}
                            if(is.null(map_target)){map_target <- names(map)}

                            ## Subsetting data
                            smry <- PAC$summary[[summary_target[[1]]]]
                            data <- smry[,summary_target[[2]], drop=FALSE]
                            data$empty_ <- 0 # Avoids problems with automatic vectorization
                            
                            sub_map <- map[names(map) %in% map_target]
                            if(length(sub_map)==1){sub_map <- map[grepl(paste(map_target, collapse="|"), names(map))]}
                            uni_map <- unique(do.call("c", lapply(sub_map, function(x){rownames(x$Alignments)})))
                            uni_map <- uni_map[!uni_map == "1"]
                            PAC <- PAC_filter(PAC, anno_target=uni_map, subset_only=TRUE)
                            sub_map  <- lapply(sub_map, function(x){
                                                          if(is.integer(x$Alignments$Align_start)){x$Alignments <- x$Alignments[rownames(x$Alignments) %in% rownames(PAC$Anno),]}
                                                          return(x)})
                            if(!nrow(PAC$Anno) == length(uni_map)){warning("Only ", nrow(PAC$Anno), " of ", length(uni_map), " mapped sequences were found in PAC.\n  Will proceede with the ones that were found.\n  (Hint: Did you subset the PAC object after you generated the map?)")}               

                            ## Remove empty references
                            rm_filt <- !do.call("c", lapply(sub_map, function(x){as.character(x$Alignments[1,1]) == "no_hits"}))
                            cat(paste0("Of ", length(rm_filt), " references analyzed, ", length(rm_filt[rm_filt==TRUE]), " was covered\n"))
                            cat(paste0("by one or more query sequence in PAC.\n"))
                            if(length(names(sub_map)[!rm_filt]) > 0 ){
                            if(length(names(sub_map)[!rm_filt]) > 30){cat("References with no coverage will be ignored.\n")}
                            if(length(names(sub_map)[!rm_filt]) <= 30){
                                                cat("These reference names was not covered by any query sequence:\n")
                                                print(names(sub_map)[!rm_filt])}}
                            sub_map <- sub_map[rm_filt]
                            
                            ## Check for multialigning sequences
                            multi_seq_lst <- lapply(sub_map, function(x){ grepl("\\.\\d", rownames(x$Alignments))})
                            if(any(do.call("c", multi_seq_lst))){
                                    lst <- list(NA)
                                    for(i in 1:length(multi_seq_lst)){lst[[i]] <-  sub_map[[i]]$Alignments[multi_seq_lst[[i]],]}
                                    names(lst) <- names(multi_seq_lst)
                                    warning("Occurens of multiple identical alignments within the same reference was detected.\nWill proceed anyway, but the multiple alignment(s) are listed above.\n")
                                    print(lst[do.call("c", lapply(multi_seq_lst, any))])
                                }
                            sub_map <- lapply(sub_map, function(x){x$Alignments$seqs <- gsub(".\\d", "", rownames(x$Alignments)); return(x)}) 
                            ref_data_lst <- lapply(sub_map, function(x){
                                                                sub_data <- data[rownames(data) %in% x$Alignments$seqs,]
                                                                fin <- sub_data[match(x$Alignments$seqs, rownames(sub_data)),]
                                                                return(fin)}) 
                            stopifnot(identical(do.call("c", lapply(ref_data_lst, function(x){gsub("\\.\\d", "", rownames(x))})), do.call("c", lapply(sub_map, function(x){x$Alignments$seqs}))))
                            stopifnot(identical(length(ref_data_lst), length(sub_map)))

                            ## Generate coverage files using granges
                            rep_lst <- lapply(ref_data_lst, function(x){
                                            lapply(as.list(x), function(y){
                                                                  rep_vect <- rep(seq_along(rownames(x)), time=round(y))
                                                                  if(length(rep_vect)<1){ rep_vect <- 0}
                                                                  return(rep_vect)
                                                                  })
                                                            })
                                                              
                            
                            cov_lst <- list(NA)
                            for(i in 1:length(sub_map)){
                                                       df <- data.frame(seqnames="sequence",
                                                                        start=sub_map[[i]]$Alignments$Align_start,
                                                                        end=sub_map[[i]]$Alignments$Align_end,
                                                                        ID=sub_map[[i]]$Alignments$seqs)
                                                       
                                                       cov_lst[[i]] <- lapply(as.list(1:length(summary_target[[2]])), function(x){
                                                                                                          df <- df[rep_lst[[i]][[x]],]
                                                                                                          if(nrow(df)==0){
                                                                                                              fin <- data.frame(Postion=as.factor(1:width(sub_map[[i]]$Ref_seq)), Coverage=0)
                                                                                                              }
                                                                                                          if(nrow(df)>0){  
                                                                                                              gr <- GRanges(df)
                                                                                                              seqlengths(gr) <- as.numeric(width(sub_map[[i]]$Ref_seq))
                                                                                                              cov <- as.numeric(coverage(gr)[[1]])
                                                                                                              fin <- data.frame(Postion=ordered(as.factor(1:length(cov))), Coverage=cov)
                                                                                                              }
                                                                                                          return(fin)
                                                                                                          })
                                                       names(cov_lst[[i]]) <- summary_target[[2]]
                                                       names(cov_lst)[i] <- names(sub_map)[i]
                                                      }

                            ## Plot graphs
                            names(color) <- summary_target[[2]]
                            plot_lst <- list(NA)
                            for(i in 1:length(cov_lst)){
                                    cov_df <- cbind(data.frame(Position=cov_lst[[i]][[1]][,1]), do.call("cbind", lapply(cov_lst[[i]], function(x){x[,2]})))
                                    cov_df <- reshape2::melt(cov_df, id.vars="Position")
                                    colnames(cov_df) <- c("Postion", "Group", "Coverage")
                                    if(xseq==TRUE){
                                       x_lab <- c(unlist(str_split(as.character(sub_map[[i]]$Ref_seq), "", n = Inf, simplify = FALSE)))
                                       tcks <- element_line()
                                       }else{x_lab<-NULL; tcks <- element_blank()}

                                    ########### Solid style ##########
                                    if(style=="solid"){
                                        if(max(cov_df$Coverage) >= 100){
                                          plot_lst[[i]] <- ggplot(cov_df, aes(x=Postion, y=Coverage, group=Group, fill=Group)) +
                                                            geom_line(size=1.0) +
                                                            geom_ribbon(data=cov_df, aes(x=Postion, ymax=Coverage), ymin=0, alpha=0.5) +
                                                            scale_fill_manual(name='', values=color)+
                                                            geom_abline(intercept =0, slope=0)+
                                                            ylab("mean RPM") +
                                                            xlab(paste("postion on ", names(cov_lst)[i], sep=""))+
                                                            scale_x_discrete(labels=x_lab)+
                                                            theme_bw()+
                                                            theme(axis.ticks.x=tcks)}
                                        if(max(cov_df$Coverage) < 100){
                                          plot_lst[[i]] <- ggplot(cov_df, aes(x=Postion, y=Coverage, group=Group, fill=Group)) +
                                                            geom_line(size=1.0) +
                                                            geom_ribbon(data=cov_df, aes(x=Postion, ymax=Coverage), ymin=0, alpha=0.5) +
                                                            scale_fill_manual(name='', values=color)+
                                                            coord_cartesian(ylim=c(0,100))+
                                              							scale_y_continuous(breaks = seq(0, 100, 30))+
                                                            geom_abline(intercept =0, slope=0)+
                                                            ylab("mean RPM") +
                                                            xlab(paste("postion on ", names(cov_lst)[i], sep=""))+
                                                            scale_x_discrete(labels=x_lab)+
                                                            theme_bw()+
                                                            theme(axis.ticks.x=tcks)}
                                                      }

                                    ########### Line style ##########
                                    if(style=="line"){
                                        if(max(cov_df$Coverage) >= 100){
                                          plot_lst[[i]] <- 	ggplot(cov_df, aes(x=Postion, y=Coverage, group=Group, color=Group, fill=Group)) +
                                            								geom_path(lineend="butt", linejoin="round", linemitre=1, size=1.0)+
                                            								scale_color_manual(values=color)+
                                            								labs(title=names(sub_map)[i])+
                                              							ylab("mean RPM") +
                                            								expand_limits(y=max(cov_df$Coverage)+20) +
                                            								scale_x_discrete(labels=x_lab)+
                                            								theme_classic()+
                                            								theme(axis.ticks.x=tcks, axis.text.x = element_text(size=8), plot.title = element_text(size=10))}

                                        if(max(cov_df$Coverage) < 100){
                                          plot_lst[[i]] <-  ggplot(cov_df, aes(x=Postion, y=Coverage, group=Group, color=Group, fill=Group)) +
                                            								geom_path(lineend="butt", linejoin="round", linemitre=1, size=1.0)+
                                            								scale_color_manual(values=color)+
                                                            coord_cartesian(ylim=c(0,100))+
                                              							scale_y_continuous(breaks = seq(0, 100, 30))+
                                            								labs(title=names(sub_map)[i])+
                                              							ylab("mean RPM") +
                                            								expand_limits(y=max(cov_df$Coverage)+20) +
                                            								scale_x_discrete(labels=x_lab)+
                                            								theme_classic()+
                                            								theme(axis.ticks.x=tcks, axis.text.x = element_text(size=8), plot.title = element_text(size=10))}
                                    names(plot_lst)[i] <- names(cov_lst)[i]
                                    plot_lst[[i]]$seqs_rpm <-  ref_data_lst[[i]]
                                    }
                            }
                            names(plot_lst) <- names(sub_map)
                            return(plot_lst)
}