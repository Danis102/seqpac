#' Plot sequence covarage over a reference
#'
#' \code{PAC_covplot} Plotting sequences in a PAC object using an PAC mapping object.
#'
#' Given a PAC object and a PAC_map object generated by \emph{PAC_mapping}
#' this function will attempt to plot the sequence coverage over long
#' references.
#'
#' @family PAC analysis
#'   
#' @seealso \url{https://github.com/Danis102} for updates on the current
#'   package.
#'
#' @param PAC PAC-list object.
#'
#' @param PAC_map PAC_map object generated by \emph{PAC_mapping}.
#'
#' @param summary_target List with 2 character vectors: 
#'   1st object: Character indicating the name of the target PAC summary object
#'   which should be used as input data for the plots. If left empty the 1st
#'   summary object will be used.
#'   2nd object: Character vector indicating the names of the columns in the
#'   summary object from which individual graphs should be plotted. If left
#'   empty all summary columns are plotted in the same graph.
#'   Summaries are generated by the PAC_summary function or customly generated
#'   by the user and stored in the summary 'folder' of a PAC object.
#'   
#' @param map_target (optional) Character vector. Imporant: This is similar to
#'   an anno_target, but instead extracts target references in the PAC_mapping
#'   object. Should contain search terms that can find unique strings in the
#'   reference names. The search terms are parse to grepl("<search terms>,
#'   names(<PAC_mapping object>)). (default=NULL)
#'
#' @param xseq Logical indicating whether the nucleotides should be plotted on
#'   the x-axis. Plotting long references with xseq=FALSE will increase
#'   script performance. (default=TRUE).
#'
#' @param colour Character vector indicating the rgb colors to be parsed to
#'   ggplot2 for plotting the covarage lines  (default = c("black", "red",
#'   "grey", "blue"))
#'   
#' @return Plot list with plots generated by ggplot2
#'
#' @examples
#' 
#' ### Load data ###
#' reanno_path="/data/Data_analysis/Projects/Pigs/Specific_projects/SRA_download/SRP135969_Sperm_Exosomes_Hemicastration/Processed_Pipeline31_05-03-20/R_files/"
#' load(file=paste0(reanno_path, "PAC_filt_rpm10in25.Rdata"))
#' 
#' ## Filter out biotype of interest
#' table(PAC_filt$Anno$Biotypes_tRNA)
#' PAC_filt_tRNA <- PAC_filter(PAC_filt, anno_target=list("Biotypes_tRNA", c("Mt_tRNA", "tRNA")), subset_only=TRUE)
#' table(PAC_filt_tRNA$Anno$Biotypes_tRNA)
#' 
#' ## Mapping
#' ref_path <- "/data/Data_analysis/Genomes/Pigs/Sports/Sus_scrofa/tRNA_reanno/tRNA_mature.fa"
#' PAC_map <- PAC_mapper(PAC=PAC_filt_tRNA, ref_path, threads=8, mismatches=0)
#' table(rownames(PAC_filt_tRNA$Anno) %in%  unique(do.call("c", lapply(PAC_map, function(x){ rownames(x[[2]])}))))
#' 
#' ## Make summary
#' PAC_filt_tRNA <- PAC_summary(PAC_filt_tRNA, norm = "rpm", type = "means", pheno_target=list("Index", unique(PAC_filt_tRNA$Pheno$Index)))
#' 
#' PAC_filt_tRNA <- PAC_summary(PAC_filt_tRNA, norm = "rpm", type = "se", pheno_target=list("Index", c("sperm_cells_HC", "sperm_cells_CT")))
#' 
#' plot_lst <- PAC_covplot(PAC_filt_tRNA, PAC_map, summary_target = list("means_[Index]", NULL), xseq=TRUE, style="line", colour=c("black", "red", "grey", "blue"))
#' plot_lst <- PAC_covplot(PAC_filt_tRNA, PAC_map, summary_target = list("means_[Index]", NULL), xseq=FALSE, style="line", colour=c("black", "red", "grey", "blue"))

#' names(plot_lst)[grepl("Arg", names(plot_lst))]
#' names(plot_lst)[grepl("LeuCAA", names(plot_lst))]
#' 
#' 
#' sub_plots_lst <- plot_lst[grepl("Arg", names(plot_lst))]
#' sub_plots_lst <- plot_lst[grepl("LeuCAA", names(plot_lst))]
#' 
#' cowplot::plot_grid(sub_plots_lst[[1]],sub_plots_lst[[2]],sub_plots_lst[[3]],sub_plots_lst[[4]],sub_plots_lst[[5]], sub_plots_lst[[6]])
#'
#' 
#' @export

PAC_covplot <- function(PAC, map, summary_target=names(PAC), map_target=NULL, style="line", xseq=TRUE, colour=c("black", "red", "grey", "blue")){
                            require("GenomicRanges")
                            require("ggplot2")
                            require("stringr")
                            if(is.null(summary_target[[1]])){stop("Error: You need to specify a target list in PAC$summary using summary_target.")}
                            if(is.null(summary_target[[2]])){summary_target[[2]] <- names(PAC$summary[[summary_target[[1]]]])}
                            if(is.null(map_target)){map_target <- names(map)}

                            ## Subsetting data
                            smry <- PAC$summary[[summary_target[[1]]]]
                            data <- smry[,summary_target[[2]], drop=FALSE]
                            data$empty_ <- 0 # Avoids problems with automatic vectorization
                            sub_map <- map[names(map) %in% map_target]
                            if(length(sub_map)==1){sub_map <- map[grepl(paste(map_target, collapse="|"), names(map))]}
                            
                            ## Remove empty references
                            rm_filt <- !do.call("c", lapply(sub_map, function(x){as.character(x$Alignments[1,1]) == "no_hits"}))
                            cat(paste0("Of ", length(rm_filt), " references analyzed, ", length(rm_filt[rm_filt==TRUE]), " was covered\n"))
                            cat(paste0("by one or more query sequence in PAC.\n"))
                            if(length(names(sub_map)[!rm_filt]) > 0 ){
                            if(length(names(sub_map)[!rm_filt]) > 30){cat("References with no coverage will be ignored.\n")}
                            if(length(names(sub_map)[!rm_filt]) <= 30){
                                                cat("These reference names was not covered by any query sequence:\n")
                                                print(names(sub_map)[!rm_filt])}}
                            sub_map <- sub_map[rm_filt]
                            
                            ## Check for multialigning sequences
                            multi_seq_lst <- lapply(sub_map, function(x){ grepl("\\.\\d", rownames(x$Alignments))})
                            if(any(do.call("c", multi_seq_lst))){
                                    lst <- list(NA)
                                    for(i in 1:length(multi_seq_lst)){lst[[i]] <-  sub_map[[i]]$Alignments[multi_seq_lst[[i]],]}
                                    names(lst) <- names(multi_seq_lst)
                                    warning("Occurens of multiple identical alignments within the same reference was detected.\nWill proceed anyway, but the multiple alignment(s) are listed above.\n")
                                    print(lst[do.call("c", lapply(multi_seq_lst, any))])
                                }
                            sub_map <- lapply(sub_map, function(x){x$Alignments$seqs <- gsub(".\\d", "", rownames(x$Alignments)); return(x)}) 
                            ref_data_lst <- lapply(sub_map, function(x){
                                                                sub_data <- data[rownames(data) %in% x$Alignments$seqs,]
                                                                fin <- sub_data[match(x$Alignments$seqs, rownames(sub_data)),]
                                                                return(fin)}) 
                            stopifnot(identical(do.call("c", lapply(ref_data_lst, function(x){gsub("\\.\\d", "", rownames(x))})), do.call("c", lapply(sub_map, function(x){x$Alignments$seqs}))))
                            stopifnot(identical(length(ref_data_lst), length(sub_map)))

                            ## Generate coverage files using granges
                            rep_lst <- lapply(ref_data_lst, function(x){
                                            lapply(as.list(x), function(y){
                                                                  rep_vect <- rep(seq_along(rownames(x)), time=round(y))
                                                                  if(length(rep_vect)<1){ rep_vect <- 0}
                                                                  return(rep_vect)
                                                                  })
                                                            })
                                                              
                            
                            cov_lst <- list(NA)
                            for(i in 1:length(sub_map)){
                                                       df <- data.frame(seqnames="sequence",
                                                                        start=sub_map[[i]]$Alignments$Align_start,
                                                                        end=sub_map[[i]]$Alignments$Align_end,
                                                                        ID=sub_map[[i]]$Alignments$seqs)
                                                       
                                                       cov_lst[[i]] <- lapply(as.list(1:length(summary_target[[2]])), function(x){
                                                                                                          df <- df[rep_lst[[i]][[x]],]
                                                                                                          if(nrow(df)==0){
                                                                                                              fin <- data.frame(Postion=as.factor(1:width(sub_map[[i]]$Ref_seq)), Coverage=0)
                                                                                                              }
                                                                                                          if(nrow(df)>0){  
                                                                                                              gr <- GRanges(df)
                                                                                                              seqlengths(gr) <- as.numeric(width(sub_map[[i]]$Ref_seq))
                                                                                                              cov <- as.numeric(coverage(gr)[[1]])
                                                                                                              fin <- data.frame(Postion=ordered(as.factor(1:length(cov))), Coverage=cov)
                                                                                                              }
                                                                                                          return(fin)
                                                                                                          })
                                                       names(cov_lst[[i]]) <- summary_target[[2]]
                                                       names(cov_lst)[i] <- names(sub_map)[i]
                                                      }

                            ## Plot graphs
                            names(colour) <- summary_target[[2]]
                            plot_lst <- list(NA)
                            for(i in 1:length(cov_lst)){
                                    cov_df <- cbind(data.frame(Position=cov_lst[[i]][[1]][,1]), do.call("cbind", lapply(cov_lst[[i]], function(x){x[,2]})))
                                    cov_df <- reshape2::melt(cov_df, id.vars="Position")
                                    colnames(cov_df) <- c("Postion", "Group", "Coverage")
                                    if(xseq==TRUE){
                                       x_lab <- c(unlist(str_split(as.character(sub_map[[i]]$Ref_seq), "", n = Inf, simplify = FALSE)))
                                       tcks <- element_line()
                                       }else{x_lab<-NULL; tcks <- element_blank()}

                                    ########### Solid style ##########
                                    if(style=="solid"){
                                        if(max(cov_df$Coverage) >= 100){
                                          plot_lst[[i]] <- ggplot(cov_df, aes(x=Postion, y=Coverage, group=Group, fill=Group)) +
                                                            geom_line(size=1.0) +
                                                            geom_ribbon(data=cov_df, aes(x=Postion, ymax=Coverage), ymin=0, alpha=0.5) +
                                                            scale_fill_manual(name='', values=colour)+
                                                            geom_abline(intercept =0, slope=0)+
                                                            ylab("mean RPM") +
                                                            xlab(paste("postion on ", names(cov_lst)[i], sep=""))+
                                                            scale_x_discrete(labels=x_lab)+
                                                            theme_bw()+
                                                            theme(axis.ticks.x=tcks)}
                                        if(max(cov_df$Coverage) < 100){
                                          plot_lst[[i]] <- ggplot(cov_df, aes(x=Postion, y=Coverage, group=Group, fill=Group)) +
                                                            geom_line(size=1.0) +
                                                            geom_ribbon(data=cov_df, aes(x=Postion, ymax=Coverage), ymin=0, alpha=0.5) +
                                                            scale_fill_manual(name='', values=colour)+
                                                            coord_cartesian(ylim=c(0,100))+
                                              							scale_y_continuous(breaks = seq(0, 100, 30))+
                                                            geom_abline(intercept =0, slope=0)+
                                                            ylab("mean RPM") +
                                                            xlab(paste("postion on ", names(cov_lst)[i], sep=""))+
                                                            scale_x_discrete(labels=x_lab)+
                                                            theme_bw()+
                                                            theme(axis.ticks.x=tcks)}
                                                      }

                                    ########### Line style ##########
                                    if(style=="line"){
                                        if(max(cov_df$Coverage) >= 100){
                                          plot_lst[[i]] <- 	ggplot(cov_df, aes(x=Postion, y=Coverage, group=Group, color=Group, fill=Group)) +
                                            								geom_path(lineend="butt", linejoin="round", linemitre=1, size=1.0)+
                                            								scale_color_manual(values=colour)+
                                            								labs(title=names(sub_map)[i])+
                                              							ylab("mean RPM") +
                                            								expand_limits(y=max(cov_df$Coverage)+20) +
                                            								scale_x_discrete(labels=x_lab)+
                                            								theme_classic()+
                                            								theme(axis.ticks.x=tcks, axis.text.x = element_text(size=8), plot.title = element_text(size=10))}

                                        if(max(cov_df$Coverage) < 100){
                                          plot_lst[[i]] <-  ggplot(cov_df, aes(x=Postion, y=Coverage, group=Group, color=Group, fill=Group)) +
                                            								geom_path(lineend="butt", linejoin="round", linemitre=1, size=1.0)+
                                            								scale_color_manual(values=colour)+
                                                            coord_cartesian(ylim=c(0,100))+
                                              							scale_y_continuous(breaks = seq(0, 100, 30))+
                                            								labs(title=names(sub_map)[i])+
                                              							ylab("mean RPM") +
                                            								expand_limits(y=max(cov_df$Coverage)+20) +
                                            								scale_x_discrete(labels=x_lab)+
                                            								theme_classic()+
                                            								theme(axis.ticks.x=tcks, axis.text.x = element_text(size=8), plot.title = element_text(size=10))}
                                    names(plot_lst)[i] <- names(cov_lst)[i]
                                    plot_lst[[i]]$seqs_rpm <-  ref_data_lst[[i]]
                                    }
                            }
                            names(plot_lst) <- names(sub_map)
                            return(plot_lst)
}