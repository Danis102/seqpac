#' Make a Simple Annotaion File from Sport Output
#'
#' \code{make_anno} uses parallel processing to generate a simple annotation
#' file from a Sports output list (generated by \code{import_sports}).
#'
#' Given a list of imported Sports output data.frames (generated by
#' \code{import_sports}), this function will filter and join overlapping
#' annotations in the output list creating a master annotation file in common
#' for all imported output files.
#'
#' @family PAC generation
#'
#' @seealso \url{https://github.com/junchaoshi/sports1.0} for download and
#'   documentation about running Sports. \url{https://github.com/Danis102} for
#'   updates on the current package.
#'
#' @param sports_lst A list object containing imported data.frames from Sports output.
#'
#' @param threads Integer stating the number of parallell jobs.
#'
#' @param filt Integer stating the number of independent evidences for need for retainment.
#'
#' @param stat Logical stating if statistics should be generated (promts for user input).
#'
#' @return
#'   Each dataframe in the sports_lst object (list generated by
#'   \code{import_sports}) contains all unique sequences present within the
#'   original fastq raw sequence files. Sports counted these sequences, creating
#'   a table with the counts for each unique sequence. Most of these sequences
#'   will, however, be highly specific for a given sample. Given that a project
#'   often involves multiple samples, and that comparing groups across samples
#'   only is relevant if a sequence is consistently identified in at least one
#'   group, it is advisable to only analyze sequences with enough
#'   coverage/evidence across samples.
#'
#'   Nevertheless, since all projects are unique, the user must be sure that the
#'   filtering criterias are compatible with the experimental design. For
#'   instance, in a project with few replicates you might have to handle noise
#'   using different strategies.
#'
#'   A weak filter, like filt=2 (deafult), will remove data noise and decrease
#'   the file size, which will make dramatically will decrease the processing
#'   times and hardware resources in downstream analysis.
#'
#'   If stat=TRUE (default/recommended), the function will first generate
#'   statistics based on overlapping sequences across all the files in the
#'   imported list (sports_lst) and promt the user for input before progressing.
#'   If stat=FALSE, no statistics will be generated and the user will not be
#'   promted.
#'
#'   Using threads > 1, the final  will be  in parallell Use \code{parallel::detectcores()} to see available
#'   threads on the computer. Do not exceed the number of available threads!
#'
#'
#' @examples
#'   anno <- make_anno(sports_lst = <name_of_your_imported_sports_list>,
#'                       threads    = <number_of_jobs>,
#'                       filt       = <number_of_independent_evidence>,
#'                       stat       = <TRUE/FALSE_should_statistics_be_produced?>,
#'                       )
#'
#'  anno <- make_anno(sports_lst = sports_lst, threads=12,  stat= TRUE)
#'
#' @export

make_anno <- function(sports_lst, threads=1, filt=2, stat=TRUE){
                        require(data.table)
                        setDTthreads(threads=threads)
                        cat("First extracting all sequences from output files ...\n")
                        pb <- txtProgressBar(min = 0, max = length(sports_lst), initial = 0, style = 3, width = 100)
                        seq_lst<- list(NA)
                        for (i in 1:length(sports_lst)){
                        seq_lst[[i]] <- as.character(sports_lst[[i]]$Sequence)
                        Sys.sleep(0.001)
                        setTxtProgressBar(pb,i)
                        }
                        seq <- list(NA)
                        cat("\n\nPlease wait while making coverage tables for output files ... \n")
                        seq[[1]] <- do.call("c", seq_lst)
                        rm(seq_lst)
                        uni_seq <- list(unique(seq[[1]]))
                        cat("In total there are ", length(uni_seq[[1]]), " unique sequences in all files\n")
                        if(stat==TRUE){
                                  seq[[2]] <- seq[[1]][duplicated(seq[[1]])]
                                  uni_seq[[2]] <- unique(seq[[2]])
                                  cat("of which ", length(uni_seq[[2]]), "(", round(length(uni_seq[[2]])/length(uni_seq[[1]])*100, 2), "%) have at leasts 2 evidence\n")
                                  seq[[3]] <- seq[[2]][duplicated(seq[[2]])]
                                  uni_seq[[3]] <- unique(seq[[3]])
                                  cat("and ", length(uni_seq[[3]]), "(", round(length(uni_seq[[3]])/length(uni_seq[[1]])*100, 2), "%) have at leasts 3 evidence\n")
                                  seq[[4]] <- seq[[3]][duplicated(seq[[3]])]
                                  uni_seq[[4]] <- unique(seq[[4]])
                                  cat("and ", length(uni_seq[[4]]), "(", round(length(uni_seq[[4]])/length(uni_seq[[1]])*100, 2), "%) have at leasts 4 evidence\n")
                                  seq[[5]] <- seq[[4]][duplicated(seq[[4]])]
                                  uni_seq[[5]] <- unique(seq[[5]])
                                  cat("and ", length(uni_seq[[5]]), "(", round(length(uni_seq[[5]])/length(uni_seq[[1]])*100, 2), "%) have at leasts 5 evidence\n")
                                  seq[[6]] <- seq[[5]][duplicated(seq[[5]])]
                                  uni_seq[[6]] <- unique(seq[[6]])
                                  cat("and ", length(uni_seq[[6]]), "(", round(length(uni_seq[[6]])/length(uni_seq[[1]])*100, 2), "%) have at leasts 6 evidence\n")
                                  seq[[7]] <- seq[[6]][duplicated(seq[[6]])]
                                  uni_seq[[7]] <- unique(seq[[7]])
                                  cat("and ", length(uni_seq[[7]]), "(", round(length(uni_seq[[7]])/length(uni_seq[[1]])*100, 2), "%) have at leasts 7 evidence\n")
                                  seq[[8]] <- seq[[7]][duplicated(seq[[7]])]
                                  uni_seq[[8]] <- unique(seq[[8]])
                                  cat("and ", length(uni_seq[[8]]), "(", round(length(uni_seq[[8]])/length(uni_seq[[1]])*100, 2), "%) have at leasts 8 evidence\n")
                                  seq[[9]] <- seq[[8]][duplicated(seq[[8]])]
                                  uni_seq[[9]] <- unique(seq[[9]])
                                  cat("and ", length(uni_seq[[9]]), "(", round(length(uni_seq[[9]])/length(uni_seq[[1]])*100, 2), "%) have at leasts 9 evidence\n")
                                  seq[[10]] <- seq[[9]][duplicated(seq[[9]])]
                                  uni_seq[[10]] <- unique(seq[[10]])
                                  cat("and ", length(uni_seq[[10]]), "(", round(length(uni_seq[[10]])/length(uni_seq[[1]])*100, 2), "%) have at leasts 10 evidence\n\n")
                                }
                        cat("\nOBS! Only RNA sequences that have at least evidence in ", filt, " samples will be retained (as specified by user or default=2).\n\n")
                        cat("Now generating annotation table across all output files ...\n")
                        filt_seqs <- uni_seq[[filt]]
                        rm(seq)
                        gc(reset=TRUE)
                        cat("Processing raw anno file 1 /", length(sports_lst), "at", paste0(Sys.time()), "\n")
                        filt_lst <- list(NA)
                        filt_lst[[1]] <- as.character(sports_lst[[1]]$Sequence) %in% filt_seqs
                        remains <- filt_seqs[!filt_seqs %in% as.character(sports_lst[[1]]$Sequence)]
                        for(i in 2:length(sports_lst)){
                                  filt_lst[[i]] <- as.character(sports_lst[[i]]$Sequence) %in% remains
                                  remains <- remains[!remains %in% as.character(sports_lst[[i]]$Sequence)]
                                  Sys.sleep(0.001)
                                  cat("Processing raw anno file", i, "/", length(sports_lst), "at", paste0(Sys.time()), "\n")
                        }
                        cat("Extracting sub tables at ", paste0(Sys.time()), "\n")
                        anno_lst <- list(NA)
                        pb <- txtProgressBar(min = 0, max = length(sports_lst), initial = 0, style = 3, width = 100)
                        for(i in 1:length(sports_lst)){
                                  anno_lst[[i]]<- sports_lst[[i]][filt_lst[[i]],]
                                  Sys.sleep(0.001)
                                  setTxtProgressBar(pb,i)
                        }
                        cat("\nMerging subtables and finalizing at ", paste0(Sys.time()), "\n")
                        anno <- as.data.frame(rbindlist(anno_lst))
                        rownames(anno) <- anno$Sequence
                        anno <- anno[,c(3, 5:6)]
                        rownames(anno)
                        cat("Finished at ", paste0(Sys.time()), "\n")
                      return(anno)
}


