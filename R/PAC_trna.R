#' Plot sequence covarage over a reference
#'
#' \code{PAC_covplot} Plotting sequences in a PAC object using an PAC mapping object.
#'
#' Given a PAC object and a PAC_map object generated by \emph{PAC_mapping}
#' this function will attempt to plot the sequence coverage over long
#' references.
#'
#' @family PAC analysis
#'   
#' @seealso \url{https://github.com/Danis102} for updates on the current
#'   package.
#'
#' @param PAC PAC-list object.
#'
#' @param PAC_map PAC_map object generated by \emph{PAC_mapping}.
#'
#' @param summary_target List with 2 character vectors: 
#'   1st object: Character indicating the name of the target PAC summary object
#'   which should be used as input data for the plots. If left empty the 1st
#'   summary object will be used.
#'   2nd object: Character vector indicating the names of the columns in the
#'   summary object from which individual graphs should be plotted. If left
#'   empty all summary columns are plotted in the same graph.
#'   Summaries are generated by the PAC_summary function or customly generated
#'   by the user and stored in the summary 'folder' of a PAC object.
#'   
#' @param map_target (optional) Character vector. Imporant: This is similar to
#'   an anno_target, but instead extracts target references in the PAC_mapping
#'   object. Should contain search terms that can find unique strings in the
#'   reference names. The search terms are parse to grepl("<search terms>,
#'   names(<PAC_mapping object>)). (default=NULL)
#'
#' @param xseq Logical indicating whether the nucleotides should be plotted on
#'   the x-axis. Plotting long references with xseq=FALSE will increase
#'   script performance. (default=TRUE).
#'
#' @param colour Character vector indicating the rgb colors to be parsed to
#'   ggplot2 for plotting the covarage lines  (default = c("black", "red",
#'   "grey", "blue"))
#'   
#' @return Plot list with plots generated by ggplot2
#'
#' @examples
#' 
#' load(file="/home/danis31/OneDrive/Programmering/Programmering/Pipelines/Drosophila/Pipeline_3.1/seqpac/dm_test_PAC.Rdata")
#' 
#' #PAC_filt <- PAC_filter(PAC_all, threshold=5, coverage=4, type="counts", stat=FALSE, pheno_target=NULL, anno_target=NULL)
#' PAC_filt <- PAC_rpm(PAC_filt)
#' PAC_filt <- PAC_summary(PAC_filt, norm = "rpm", type = "means", pheno_target=list("Method"))
#' PAC_check(PAC_filt)
#' 
#' ref_path <- "/data/Data_analysis/Genomes/Drosophila/dm6/tRNA/tRNA.fa"
#' full <- Biostrings::readDNAStringSet(ref_path)
#' ref <- full[grepl("Glu-CTC-3-1|Lys-CTT-1-1 ", names(full))]
#'
#' map_refs <- PAC_mapper(PAC_filt, ref=ref, threads=12, mismatches=0)
#' 
#' 
#' ss_path <- "/data/Data_analysis/Genomes/Drosophila/dm6/tRNA/Finished_tRNA_Drosophila_loop_anno.ss"
#'
#'
#' plot_lst <- PAC_mismap(PAC=PAC_filt, map=map_refs, ss=ss_path, summary_target=list("means_[Method]"), map_target=NULL,  xseq=TRUE, col_vect=NULL, threads=8, par_type="PSOCK")
#'
#'
#' cowplot::plot_grid(plot_lst[[1]][[1]][[1]], plot_lst[[1]][[1]][[2]], 
#'                    plot_lst[[1]][[2]][[1]], plot_lst[[1]][[2]][[2]],
#'                    labels="auto", nrow = 4, ncol = 1)
#'                    
#' plot_lst$Data
#'
#' 
#' 
#'
#' 
#' @export

PAC_trna <- function(PAC, map, ss=NULL, summary_target=NULL, map_target=NULL,  threads=1, par_type="PSOCK", col_vect=NULL)
                            require("ggplot2")
                            require("foreach")
                            if(is.null(summary_target[[1]])){stop("Error: You need to specify a target list in PAC$summary using summary_target.")}
                            if(is.null(names(PAC$summary[[summary_target[[1]]]]))){stop("You need to specify a valid summary_target.\n(Hint: Double check correct object name in PAC$summary or rerun the 'PAC_summary' function.)")}
                            if(length(summary_target)==1){summary_target[[2]] <- names(PAC$summary[[summary_target[[1]]]])}
                            if(is.null(map_target)){map_target <- names(map)}
                            
                            #### Check and subset if necessary
                            map <- map[names(map) %in%  map_target]
                            uni_map <- unique(do.call("c", lapply(map, function(x){rownames(x$Alignments)})))
                            PAC <- PAC_filter(PAC, anno_target=uni_map, subset_only=TRUE)
                            map  <- lapply(map, function(x){x$Alignments <- x$Alignments[rownames(x$Alignments) %in% rownames(PAC$Anno),]; return(x)})
                            if(!nrow(PAC$Anno) == length(uni_map)){warning("Only ", nrow(PAC$Anno), " of ", length(uni_map), " mapped sequences were found in PAC.\n  Will proceede with the ones that were found.\n  (Hint: Did you subset the PAC object after you generated the map?)")}               
                              
                            cl <- parallel::makeCluster(threads, type = par_type)
                            doParallel::registerDoParallel(cl)
                            
                            ### Add aligned seqs 
                            lst <- lapply(map, function(x){ 
                                            x[[1]] -> ref
                                            x[[2]] -> algn
                                            n_ref <- str_count(as.character(ref))
                                            algn_lst <- split(algn, factor(row.names(algn), levels=row.names(algn)))
                                            positions_lst <- foreach(j=1:length(algn_lst), .final=function(y){names(y) <- names(algn_lst);return(y)})  %dopar% {
                                                                    ref=ref
                                                                    n_ref=n_ref
                                                                    algn_str <- paste(strrep("-", times=(algn_lst[[j]]$Align_start)-1), rownames(algn_lst[[j]]), strrep("-", times= n_ref-(algn_lst[[j]]$Align_end)), sep="")
                                                                    return(algn_str)
                                                                    }
                                            df <- cbind(algn, data.frame(Alignment=paste(do.call("c", positions_lst))))
                                            return(list(Ref_seq=ref, Alignments=df))
                                            }) 
                            
                            ### Add ss info
                            if(!is.null(ss)){
                                    ss_anno <- readLines(ss)
                                    seqs <- ss_anno[grepl("\\<Seq: ", ss_anno)]
                                    seqs <- gsub("Seq: ", "", seqs)
                                    str <- ss_anno[grepl("\\<Str: ", ss_anno)]
                                    str <- gsub("Str: ", "", str)
                                    tpe <- ss_anno[grepl("\\<Type: ", ss_anno)]
                                    tpe <- gsub("Type: ", "", tpe)
                                    
                                    sb <- ss_anno[!grepl("\\<Type: |\\<Str: |\\<Seq: |      |\\<HMM ", ss_anno)]
                                    
                                    ss_anno[seq(1, length(ss_anno), 7)]
                                    data.frame(
                                    
                                    
                                    }
                            

                            
                            
                            
                            
                                                                        
                                                    }
                            map


DNA_strings <- DNAStringSet(master_list_cut$Anno$tRF_sequence)
names(DNA_strings) <- row.names(master_list_cut$Anno)
all_tRNA <- read.delim("D:/DanielAnalys/-Anita_human_sperm/R/MINTmap/List_of_availble_tRNs.txt", header=TRUE)
df_align <- data.frame(matrix(NA, nrow=1, ncol=8))
colnames(df_align) <- c("tRF_names", "Full_tRNA_names", "tRF_Align_start", "tRF_Align_end", "tRF_Align_width", "Full_tRNA_width", "Seq_tRF", "Seq_tRNA")

for(i in 1:nrow(all_tRNA)){
	nam <- as.character(all_tRNA[i,])
	tRNAs <-  full_tRNAs[grepl(nam, rownames(as.data.frame(full_tRNAs)))]
	tRFs <- DNA_strings[grepl(nam, master_list_cut$Anno$tRNA_full),]
		for(k in 1:length(tRNAs)){
			target_tRNA <-	tRNAs[k]
				for(t in 1:length(tRFs)){
					align <- vmatchPattern(as.character(tRFs[t]), target_tRNA, max.mismatch=0, fixed=FALSE)
					if (length(align[[1]])>0) {
					align_string <- paste(strrep("-", times=(start(align[[1]])-1)), as.character(tRFs[t]), strrep("-", times= (str_count(as.character(target_tRNA))-(end(align[[1]])))), sep="")
					df <- data.frame(tRF_names=names(tRFs[t]), Full_tRNA_names=names(target_tRNA), tRF_Align_start=start(align[[1]]), tRF_Align_end=end(align[[1]]), tRF_Align_width=width(align[[1]]), Full_tRNA_width=str_count(as.character(target_tRNA)), Seq_tRF=align_string, Seq_tRNA=as.data.frame(target_tRNA)[1,1])
					df_align <- rbind(df_align, df)
					}}}
	Sys.sleep(0.1)
	cat("\n", nam,' ended ', as.character(Sys.time()), " on row: ", nrow(df_align))} # Takes approx. 2h.


df_align -> sav
df_align[2:nrow(df_align),] -> df_align2
table(duplicated(paste(df_align2$tRF_names, df_align2$Full_tRNA_names, df_align2$Seq_tRF)))
df_align3 <- df_align2[!duplicated(paste(df_align2$tRF_names, df_align2$Full_tRNA_names, df_align2$Seq_tRF)),]

save(df_align2, file="D:/DanielAnalys/-Anita_human_sperm/R/MINTmap/tRNA_align_MINT_GtRNAdb_Best_hit.Rdata")
# write.table(df_align3, "D:/DanielAnalys/-Anita_human_sperm/R/MINTmap/Anno_cutsite_All_tRNA.xls", sep="\t", row.names=F)
write.table(df_align3, "D:/DanielAnalys/-Anita_human_sperm/R/MINTmap/Anno_cutsite_All_16-45_tRNA.xls", sep="\t", row.names=F)
