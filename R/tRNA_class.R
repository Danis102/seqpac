#' Classify tsRNA/tRFs from  PAC object
#'
#' Classifying tRFs/tsRNA into 5'-tRF/halves, 3'-tRFs/halves, i'-tRFs/halves, as
#' well as acceptor and decoder isotypes.
#' 
#' Given a map object with range types generated by
#' \code{\link[seqpac]{PAC_mapper}} followed by
#' \code{\link[seqpac]{map_rangetype}} functions, sequences in a PAC object are
#' classified according the terminals (5'/3'/i'), anticodon loop (half/tRF), and
#' isotype (decoder/accepter) of the full length tRNA.
#' 
#' @family PAC analysis
#'   
#' @seealso \url{https://github.com/Danis102} for updates on the current
#'   package.
#'
#' @param PAC PAC-list object.
#'
#' @param map Map object with loop annotations generated by
#'   \code{\link[seqpac]{PAC_mapper}} followed by
#'   \code{\link[seqpac]{map_rangetype}} functions. Note, only full length
#'   reference tRNAs annotated with 3 loops in the ss file (see:
#'   \code{\link[seqpac]{map_rangetype}}) are used in the classifications.
#'   Explanation: sometimes tRNAscan-SE scans results in ss files with
#'   incomplete secondary structures with either more or fewer loops than the D,
#'   T and anticodon loops found in canonical tRNAs. Such tRNAs will be reomved
#'   from the analysis.
#'
#' @param terminal Integer setting the terminal tolerance. Example, when terminal
#'   is set to 5 (default) sequenced reads starting within the 5 first
#'   nucleotides of the full-length tRNA reference will be classifed as 5'. If
#'   it instead ends within the 5 last nucleotides of the full-length tRNA
#'   reference it will be classified as 3'. If a read neither starts nor ends
#'   within the terminal threshold it will be classified as i' (internal). Note,
#'   for tsRNA/tRF classification we recommend a threshold of terminal=2 (not
#'   default). Advisably, however, \code{\link[seqpac]{PAC_mapper}} runs with
#'   N_up = "NNN" and N_down = "NNN" when mapping tsRNA/tRFs. Thus, the default
#'   threshold of 5 is used when full-length tRNAs has been extended with NNN
#'   up- and downstream to compensate for possible fragments from mature tRNAs
#'   (3+2). Always double check the exact fragment using
#'   \code{\link[seqpac]{PAC_covplot}}.
#'   
#' @return Merged PAC object with an extended Anno table containing the
#'   tRF/tsRNA classifications.
#'   
#' @export

tRNA_class <- function(PAC, map, terminal){
      type_vector <- lapply(map, function(x){
        map
        # Setup
          align <- x$Alignments
          reference_length <- x$Ref_seq@ranges@width
          ref_name <- x$Ref_seq@ranges@NAMES
        # Classify according to terminal tolerance 
          terminal_type <- ifelse(align$Align_start <= terminal, "5'",
                                ifelse(reference_length - align$Align_end <= terminal, "3'", "i'"))
        # Classify according to terminal tolerance 
          half_type <- ifelse(align$type_start_loop2 == TRUE | align$type_end_loop2 == TRUE, "half", "tRF")
          return(data.frame(tRNA_ref=ref_name, 
                            seq=rownames(align), 
                            class=paste(terminal_type, half_type, sep="-"),
                            decoder=align$decoder,
                            acceptor=align$acceptor))
        })
      # Merge all references
      type_vector <- do.call("rbind", type_vector)
      rownames(type_vector) <- NULL
      # Split by sequence instead of references
      type_vector <- split(type_vector, type_vector$seq)
      # Collapse multimapping seqences into one column 
      finished <-  lapply(type_vector, function(x){
        df <- data.frame(seq=paste0(sort(unique(x$seq), collapse=";")), 
                               class=paste0(sort(unique(x$class)), collapse=";"),
                               decoder=paste0(sort(unique(x$decoder)), collapse=";"),
                               acceptor=paste0(sort(unique(x$acceptor)), collapse=";"),
                               tRNA_ref=paste0(sort(unique(x$tRNA_ref)), collapse=";"))
      })
      finished <- do.call("rbind", finished)
      # Extract tRNAs from PAC and merge results
      PAC$Anno$seq <- rownames(PAC$Anno)
      pac_trna <- PAC_filter(PAC, anno_target=list("seq", finished$seq), subset_only=TRUE)
      # Before you merge make sure both dataframes are matching
      stopifnot(identical(rownames(pac_trna$Anno), as.character(finished$seq)))
      pac_trna$Anno <- cbind(pac_trna$Anno[,1, drop=FALSE], finished[,-1])
      return(pac_trna)
}