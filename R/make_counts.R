#' Make raw Counts table from Sports output
#'
#'\code{make_counts} uses parallel processing to generate a raw countTable.
#'
#' Given a list of imported Sports output data.frames (generated by
#' \code{import_sports}), and an annotation file (generated by \code{make_anno}
#' this function will generate a raw countTable (columns=sample, rows=sequence).
#'
#' @family PAC generation
#'
#' @seealso \url{https://github.com/junchaoshi/sports1.0} for download and
#'   documentation about running Sports. \url{https://github.com/Danis102} for
#'   updates on the current package.
#'
#' @param input If type="fastq" the input is a path to a directory containing
#'   input fastq-files. The script will recursively search this directory for
#'   the .fastq|.fastq.gz extension. If type="sports" input is a list containing
#'   imported data frames from Sports output. This list can be generated using
#'   \code{import_sports}.
#'
#' @param type Character indicating what input that should be used. If
#'   type="fastq", the scripts will generate a count table based on fastq files
#'   stored in the input path. If type="sports", a count table is generated from
#'   a list object created using \code{import_sports} contain imported sports
#'   output files .
#'   
#' @param anno Annotation dataframe generated by makeAnno (type="sports"). This
#'   parameter must be set to NULL if type="fastq" (default=NULL).
#'
#' @param threads Integer stating the number of parallell jobs. Note, that
#'   reading multiple fastq files drains memory fast, using up to 10Gb per fastq
#'   file. To avoid crashing the system due to memory shortage, make sure that
#'   each thread on the machine have at least 10 Gb of memory availabe, unless
#'   your fastq files are very small.Use \code{parallel::detectcores()} to see
#'   available threads on the machine.
#'
#' @param par_type Character indicating what type of parallel processing that
#'   should be used. If par_type="PSOCK" parallel socket clustering is used
#'   (Windows/Linux/Mac). If par_type="FORK", branching forks are used
#'   (Linux/Mac). Default="PSOCK".
#'
#' @param cutadpt Logical indicating if fastq files should be parsed to cutadapt
#'   and fastq_quality_filter (only available in Linux) for adaptor trimming and
#'   filtering prior to compiling a count table. If cutadpt=FALSE, the input
#'   path must contain already trimmed and quality filtered fastq files. If
#'   cutadpt=TRUE, trimming will be carried out using the commands in "parse",
#'   while quality filtering will be done using the following command:
#'   "fastq_quality_filter -q 20 -p 80 -v". Trimmed and filtered fastq files
#'   will be temporarly stored in "tmp/seqpac/", but will be deleted after the
#'   script has completed.
#'
#' @param parse Command strings defining the command that should be parsed to
#'   cutadapt using the system function in R. This will allow you to customize
#'   your timming according to 3' adaptor sequence and platform specifics etc.
#'   See examples below. Important: Do not include the two last options in
#'   cutadapt: -o (output path) and -i (input path). These will be generated
#'   automatically.
#'
#' @param tag Logical indicating whether 5' tagging has been used. This is
#'   specific to certain types of sequencing experiments, where beside a 3'
#'   adaptor a 5' tag has been ligated to the sequencing library. If tag=TRUE, a
#'   5' tag will be searched for only in the samples specified in 'target_tag'
#'   using the commands indicated in 'parse_tag'. Note that target_tag and
#'   parse_tag are lists, thus groups of samples can have different commands
#'   parsed to them. Example of how this can be done see below. Note that
#'   parsing these commands will be done after the 3' adaptor sequence has been
#'   trimmed off. This will be done on the fastq files If tag=FALSE, this step
#'   will be passed. 
#'
#' @param parse_tag A named list of command strings. Each object contains the
#'   command that are to be parsed to cutadapt, for splitting the input fastq
#'   file specified in 'target_tag' into fastq files containg (_tag.fastq) and
#'   not containing (_notag.fastq) the 5' tag. The 5' tag will also be trimmed
#'   from _tag.fastq files. Important: Do not include the two last options in
#'   cutadapt: -o (output path) and -i (input path). These will be generated
#'   automatically. Default=NULL.
#'
#' @param target_tag A named list of character vectors. Each vector should
#'   contain the the input fastq file names of which 5' tagging have been used.
#'   If different 5' tags, with different sequences, has been ligated to
#'   different samples,  this can be specified objects with the same names in
#'   'target_tag' and 'parse_tag' having the same names.  For example, if
#'   target_tag$short contains the fastq file names of sample_A and sample_D,
#'   the command in parse_tag$short will be applied only on these samples.
#'   Samples missing from 'target_tag', will pass 5' tagging. For an examples
#'   see below. Default=NULL.
#'   
#' @return 
#' type="fastq": Data frame (a count table) with sequence counts across
#' all samples of sequences that occured at least two independent samples.
#' 
#' type="sports" Using the weakly filtered master annotation file (anno)
#' generated by the \code{make_anno} function, \code{make_counTable} will
#' extract the target sequences in anno from sports_lst and merge the counts
#' into one single data.frame (raw countTable). The output data.frame will ahve
#' rownames matching the original master annotation file.
#' 
#' 
#'
#'
#' @examples
#'   
#'   ### Sports type ### 
#'   countTable <- make_counts2(input = <name_of_your_imported_sports_list>,
#'                       anno    = <name_of_your_annotation_dataframe>,
#'                       threads       = <number_of_independent_evidence>,
#'                       )
#'
#'   countTable <- make_count2(sports_lst = sports_lst, anno=anno, threads=12)
#'   
#'   
#'  ### Fastq type ### 
#'  Ph_grps <- read.delim("/data/Data_analysis/Projects/Drosophila/Other/IOR/Jan_IOR_200130/Groups_data.txt", header=TRUE)
#'  Ph_grps$Sample <-  gsub("_d|_s", "", Ph_grps$Sample_ID)
#'  Ph_grps <- Ph_grps[!duplicated(Ph_grps$Sample),]
#'  Ph_grps$Tag_type <- ifelse(grepl("Long", Ph_grps$Method), "Long", 
#'                              ifelse(grepl("Short", Ph_grps$Method), "Short", NA))
#'  
#'  input <-  "/data/Data_analysis/Projects/Drosophila/Other/IOR/"
#'  parse = "cutadapt -j 1 -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCACAT --discard-untrimmed --nextseq-trim=20 -O 5 -m 5"
#'  type="fastq"
#'  cutadpt =TRUE
#'  threads =8
#'  par_type="PSOCK"
#'  tag=TRUE
#'  
#'  parse_tag = list(  Long="cutadapt -j 1 -g TGGCAACGATC -O 5 -m 5", 
#'                         Short="cutadapt -j 1 -g TGGGATC -O 5 -m 5")
#'                         
#'  target_tag = list(  Long= gsub("_2", "-2", Ph_grps$Sample[Ph_grps$Tag_type %in% "Long"]),
#'                       Short= gsub("_2", "-2", Ph_grps$Sample[Ph_grps$Tag_type %in% "Short"]))
#'  
#'  test <- make_counts2(input, type=type, threads=threads, par_type=par_type, anno=NULL, cutadpt=cutadpt, parse=parse, tag=tag, parse_tag=parse_tag, target_tag=target_tag)
#'  
#' @export
#' 


make_counts <- function(input, type="fastq", threads, par_type="PSOCK", anno=NULL, cutadpt=FALSE, parse=NULL, tag=FALSE, parse_tag=NULL, target_tag=NULL){
                          require(foreach)
                          ### Sports as input
                          if(type=="sports"){
                                    sports_lst = input
                                    setDTthreads(threads=threads)
                                    cat("Generating a raw countTable from ", length(sports_lst), "sport output files over ", nrow(anno), "unique RNA sequences.\n")
                                    cat("Started at ", paste0(Sys.time()), "\n")
                                    ordCount_df <- data.frame(matrix(NA, nrow=nrow(anno), ncol=length(sports_lst)))
                                    pb <- txtProgressBar(min = 0, max = length(sports_lst), initial = 0, style = 3, width = 100)
                                    for(i in 1:length(sports_lst)){
                                              ordCount_df[,i]  <- sports_lst[[i]]$Reads[match(rownames(anno), as.character(sports_lst[[i]]$Sequence))]
                                              colnames(ordCount_df)[i] <- gsub("_merge", "", names(sports_lst)[i])
                                              Sys.sleep(0.001)
                                              setTxtProgressBar(pb,i)
                                    }
                                    rownames(ordCount_df) <- rownames(anno)
                                    for(j in 1:ncol(ordCount_df)){set(ordCount_df, which(is.na(ordCount_df[[j]])), j, 0)} # Replace NAs with 0s using set in data.table (paralell processing)
                                    cat("\nFinished at ", paste0(Sys.time()), "\n")
                                    }
                          
                          ### fastq as input
                          if(type=="fastq"){
                                    cat("Started at ", paste0(Sys.time()), "\n")
                                    ## Parallel setup
                                    gc(reset=TRUE)
                                    cl <- parallel::makeCluster(threads, type = par_type)
                                    doParallel::registerDoParallel(cl)
                            
                                    ## Read file system
                                    path <- input
                                    count_files <- list.files(path, pattern ="fastq.gz\\>|fastq\\>", full.names=TRUE, recursive=TRUE)
                                    count_files <- count_files[!grepl("Undetermined_", count_files)]
                                    count_files_nams <- basename(count_files)
                                    cat("\nInput type was set to fastq.\n")
                                    cat("The following fastq files were found in the path:\n")
                                    print(count_files)
                                    
                                    ## Read and trim fastq files
                                    if(cutadpt==TRUE){
                                            cat("\nAdaptor trimming was specified.")
                                            cat("\nThis will work unless cutadapt and fastq_quality_filter have not been installed correctly.")
                                            system("cutadapt --version", intern=TRUE)
                                            system("cutadapt --version", intern=TRUE)

                                            ## Tagging check
                                            if(tag==TRUE){
                                                                if(is.null(target_tag)){stop("You have to specify the names of the samples that are tagged in target_tag!\n       (Hint: If all samples are tagged, add all samples names to target_tag)")}
                                                                if(length(target_tag[[1]])<1){stop("You have to specify the names of the samples that are tagged in target_tag!\n       (Hint: If all samples are tagged, add all sample names to target_tag)")}
                                                                if(!class(target_tag) == "list"){ target_tag <- list(target_tag)
                                                                                                  names(target_tag) <- names(parse_tag)
                                                                                                  warning("Your target_tag was not a list. Will try to automatically make it to a list and match the object names with parse_tag names.")}
                                                                chk_nam <- grepl(paste0(do.call("c", target_tag), collapse="|"), count_files_nams)
                                                                stopifnot(sum(as.numeric(chk_nam)) == length(do.call("c", target_tag)))
                                                                cat("\n\n5' tagging was specified and sample names were sum checked againts samples in input path, but please double check.")
                                                                cat("\nTagged samples:\n")
                                                                print(count_files[chk_nam])
                                            }

                                            cat(paste0("\nParsing fastq-files into cutadapt and then fastq_quality_filter using ", threads, " workers (this may take some time) ..."))
                                            cat(paste0("\n(Hint: You can follow the progress in the /tmp/seqpac folder.)"))
                                            suppressWarnings(dir.create("/tmp/seqpac"))
                                            fn <- list.files("/tmp/seqpac", full.names=TRUE, recursive=TRUE)
                                            if(any(file.exists(fn))){file.remove(fn)}


                                            ## cutadapt and fastq_quality_filter
                                            foreach::foreach(i=1:length(count_files), .packages=c("ShortRead"), .final = function(x){names(x) <- basename(count_files); return(x)}) %dopar% {
                                                                spl_nam <- basename(count_files[i])
                                                                log1 <-system(paste0(parse, " -o /tmp/seqpac/temp_", spl_nam, ".fastq ", count_files[i]), intern = TRUE)

                                                            ## No tagging
                                                                if(tag==FALSE){
                                                                    log2 <- system(paste0("fastq_quality_filter -q 20 -p 80 -v -i /tmp/seqpac/temp_", spl_nam, ".fastq -o /tmp/seqpac/temp_", spl_nam, ".fastq.gz -z"), intern = TRUE)
                                                                    writeLines(c(log1,"________\n________",log2), con = paste0("/tmp/seqpac/", spl_nam, "_log.txt"))
                                                                    file.remove(paste0("/tmp/seqpac/temp_", spl_nam, ".fastq"))
                                                                    }

                                                            ## Tagging
                                                                if(tag==TRUE){
                                                                      if(grepl(paste0(do.call("c", target_tag), collapse="|"), spl_nam)){
                                                                                      parse_tag_logi <- do.call("c", lapply(target_tag, function(x){grepl(paste(x, collapse="|"), spl_nam)}))
                                                                                      parse_tag_nam <- names(parse_tag_logi)[parse_tag_logi==TRUE]
                                                                                      log2 <- system(paste0(parse_tag[parse_tag_nam]," -o /tmp/seqpac/temp_", spl_nam, "_tag.fastq --untrimmed-output /tmp/seqpac/temp_", spl_nam, "_notag.fastq /tmp/seqpac/temp_", spl_nam, ".fastq"), intern = TRUE)
                                                                                      log3 <- system(paste0("fastq_quality_filter -q 20 -p 80 -v -i /tmp/seqpac/temp_", spl_nam, "_tag.fastq -o /tmp/seqpac/temp_", spl_nam, "_tag.fastq.gz -z"), intern = TRUE)
                                                                                      log4 <- system(paste0("fastq_quality_filter -q 20 -p 80 -v -i /tmp/seqpac/temp_", spl_nam, "_notag.fastq -o /tmp/seqpac/temp_", spl_nam, "_notag.fastq.gz -z"), intern = TRUE)
                                                                                      writeLines(c(log1,"________\n________", log2, "________\n________", log3, "________\n________", log4), con = paste0("/tmp/seqpac/", spl_nam, "_log.txt"))
                                                                                      file.remove(paste0("/tmp/seqpac/temp_", spl_nam, ".fastq"))
                                                                                      file.remove(paste0("/tmp/seqpac/temp_", spl_nam, "_tag.fastq"))
                                                                                      file.remove(paste0("/tmp/seqpac/temp_", spl_nam, "_notag.fastq"))
                                                                      }else{
                                                                                      log2 <- system(paste0("fastq_quality_filter -q 20 -p 80 -v -i /tmp/seqpac/temp_", spl_nam, ".fastq -o /tmp/seqpac/temp_", spl_nam, ".fastq.gz -z"), intern = TRUE)
                                                                                      writeLines(c(log1,"________\n________",log2), con = paste0("/tmp/seqpac/", spl_nam, "_log.txt"))
                                                                                      file.remove(paste0("/tmp/seqpac/temp_", spl_nam, ".fastq"))
                                                                                      }
                                                                }

                                            }
                                            parallel::stopCluster(cl)
                                            gc(reset=TRUE)
                                            cat("\nFinished generating trimmed temporary files.")
                                          }
                                      ## Read trimmed files
                                      cat("\n\nIdentifying unique sequences in trimmed fastq files ...")
                                      if(cutadpt==FALSE){fls <- count_files}
                                      if(cutadpt==TRUE){fls <- list.files("/tmp/seqpac/", pattern=".fastq.gz\\>", full.names=TRUE, recursive=FALSE)}
                                      cl <- parallel::makeCluster(threads, type = par_type)
                                      doParallel::registerDoParallel(cl)
                                      seq_lst   <- foreach::foreach(i=1:length(fls), .packages=c("ShortRead"), .final = function(x){names(x) <- basename(fls); return(x)}) %dopar% {
                                                              fstq <- ShortRead::readFastq(fls[[i]])
                                                              return(unique(paste0(ShortRead::sread(fstq))))
                                                              }
                                      parallel::stopCluster(cl)
                                      gc(reset=TRUE)
                                      cat("\nCompiling unique sequences ...")
                                      seqs <- do.call("c", seq_lst)
                                      rm(seq_lst)
                                      seqs_dup <- unique(as.character(seqs[duplicated(seqs)]))
                                      rm(seqs)

                                      ## Make count table
                                      cat("\nNow making a count table with sequences appearing in at least 2 independent samples ...")
                                      cl <- parallel::makeCluster(threads, type = par_type)
                                      doParallel::registerDoParallel(cl)
                                      reads_lst <- foreach::foreach(i=1:length(fls), .packages=c("ShortRead"),.final = function(x){names(x) <- basename(fls); return(x)}) %dopar% {
                                                                fstq <- ShortRead::readFastq(fls[i])
                                                                reads <- paste0(ShortRead::sread(fstq))
                                                                rm(fstq)
                                                                reads_dup <- reads[reads %in% seqs_dup]
                                                                rm(reads)
                                                                n_reads <- as.data.frame(table(reads_dup))
                                                                n_reads_mtch <- n_reads[match(seqs_dup, n_reads$reads_dup),]
                                                                rm(n_reads)
                                                                rownames(n_reads_mtch) <- seqs_dup
                                                                n_reads_mtch$Freq[is.na(n_reads_mtch$Freq)] <- 0 
                                                                stopifnot(identical(as.character(n_reads_mtch$reads_dup[!is.na(n_reads_mtch$reads_dup)]), as.character(rownames(n_reads_mtch)[!is.na(n_reads_mtch$reads_dup)])))
                                                                dt <- data.frame(N=n_reads_mtch[,2])
                                                                rownames(dt) <- rownames(n_reads_mtch)
                                                                return(dt)
                                      }
                                      parallel::stopCluster(cl)
                                      gc(reset=TRUE)
                                      cat("\nFinalizing at ", paste0(Sys.time()), "\n")
                                      names(reads_lst) <- gsub("_merge|.fastq.gz|fastq.gz|temp_", "", names(reads_lst))
                                      names(reads_lst) <- gsub("-", "_", names(reads_lst))
                                      if(cutadpt==TRUE){
                                                        ## Gather logs
                                                        logs_path <- list.files("/tmp/seqpac", pattern="log.txt", full.names=TRUE, recursive=FALSE)
                                                        log_lst <- lapply(as.list(logs_path), function(x){data.frame(header=readLines(x))})
                                                        names(log_lst) <- gsub("_merge.fastq.gz_log.txt", "", basename(logs_path))
                                                        names(log_lst) <- gsub("-", "_", names(log_lst))
                                                        ## Clean up
                                                        ans <- readline("Would you like to delete temporary files in /tmp/seqpac [y/n]?")
                                                        if(ans %in% c("Y", "y")){ fn <- list.files("/tmp/seqpac", full.names=TRUE, recursive=FALSE)
                                                                                  if(any(file.exists(fn))){file.remove(fn)}
                                                              }
                                                          }
                                      ordCount_df <- as.data.frame(do.call("cbind", reads_lst))
                                      colnames(ordCount_df) <- names(reads_lst)
                                      stopifnot(!any(!do.call("c", lapply(reads_lst, function(x){identical(rownames(ordCount_df), rownames(x))}))))
                                      
                                    }
                          if(cutadpt==FALSE){log_lst<-"no_trimming_was_done"}
                          return(list(counts=ordCount_df, logs=log_lst))
                          }
