#' Plot two variables against one another on a scatter plot
#'
#' \code{PAC_scatterplot} Plotting counts against two conditions.
#'
#' Given a PAC object with a summary dimension generated by \emph{PAC_summary}
#' this function will attempt to plot counts/RPM from one condition
#' versus another.
#'
#' @family PAC analysis
#'   
#' @seealso \url{https://github.com/Danis102} for updates on the current
#'   package.
#'
#' @param PAC PAC-list object.
#'
#' @param pheno_target List with: 1st object being a character vector
#'   of target column in Pheno 2nd object being a character vector of the target
#'   group(s) in the target Pheno column (1st object).
#'
#* @param anno_target Character vector with the name of the target column in
#'   Anno or the name of the annotation column in case of input being a dataframe. 
#'   
#' @param colvec Character vector with color codes to be parsed to ggplot2.
#'
#' @param summary Character vector defining what type of summary to use in plot.
#' (default="means")
#'
#' @param labels A subset of original data in PAC$summary that will have its
#* rownames printed as labels by the point. 
#'   
#' @return Plot list with plots generated by ggplot2
#'
#' @examples
#' 
#' ### Load data ###
#' 
#' PAC <- PAC_filter(PAC, size=c(16,70), threshold=10, coverage=5, type="counts", stat=FALSE, pheno_target=NULL, anno_target=NULL)
#' PAC <- PAC_rpm(PAC)
#' PAC <- PAC_filter(PAC, size=c(16,70), threshold=10, coverage=5, type="rpm", stat=FALSE, pheno_target=NULL, anno_target=NULL)

#' ## Make summaries
#' PAC <- PAC_summary(PAC, norm = "rpm", type = "means", pheno_target=list("Groups", unique(PAC_filt$Pheno$Groups)))
#' scatter<-PAC_scatterplot(PAC, anno_target=list("Biotype", "tRNA) summary="Means")
#' 
#' #working on making a working replicable version of labels
#' @export

PAC_scatterplot<-function(PAC, pheno_target=NULL, anno_target=NULL, colvec=NULL, summary="Means", labels=NULL){
 
 #filter on anno_target
  if(!is.null(anno_target)){
    PAC<-PAC_filter(PAC, anno_target = anno_target)
  }
  
   if(is.null(colvec)){
    bio <- as.character(unique(data_long_perc$Biotype))
    n_extra  <- sum(bio %in% c("no_anno", "other"))
    colfunc <- grDevices::colorRampPalette(c("#094A6B", "#EBEBA6", "#9D0014"))
    if(n_extra==1){colvec <- c(colfunc(length(bio)-1), "#6E6E6E")}
    if(n_extra==2){colvec <- c(colfunc(length(bio)-2), "#6E6E6E", "#BCBCBD")}
    if(n_extra==0){colvec <- colfunc(length(bio))}
  }
  
  #pick correct summary data
  if(summary=="Means"){
  val<-summary
  colname<-grep(val, names(PAC$summary), value=T)
  df<-PAC$summary[colname]
  
  #anno_target?
  df<-as.data.frame(df)
  df$Biotype<-PAC$Anno$Biotype
  df$name<-rownames(df)
   
   #haven't worked that much with datasets with more than 2 groups,
   #but here maybe add pheno_target as a way to choose which two datasets to
   #present in graphs as df[,1] and [,2]
   
  p<-ggplot(df, aes(x=df[,1], y=df[,2], color=Biotype))+
    geom_point(size=5)+
    theme_classic()+
    geom_abline()+
    ylab((pheno_target[[2]][2]))+
    xlab(((pheno_target[[2]][1])))+
   scale_color_manual(values=colvec)+
    theme(axis.title.x =element_text(size=20), axis.title.y=element_text(size=20),
          axis.text.x = element_text(size=15), axis.text.y = element_text(size=15))
  
  if(!is.null(labels)){
    require(ggrepel)
    p<-ggplot(df, aes(x=df[,1], y=df[,2], color=Biotype, label=name))+
      geom_point(size=5)+
      theme_classic()+
      geom_abline()+
      ylab((pheno_target[[2]][2]))+
      xlab(((pheno_target[[2]][1])))+
      scale_color_manual(values=colvec)+
      theme(axis.title.x =element_text(size=20), axis.title.y=element_text(size=20),
            axis.text.x = element_text(size=15), axis.text.y = element_text(size=15)) +
    geom_text_repel(data= labels, color="black", size=8, nudge_y= 150, segment.alpha = 0)

        }
        
      }
      return(p)
}
