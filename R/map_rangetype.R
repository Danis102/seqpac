#' Interval classification. 
#'
#' \code{map_rangetype} Classifies sequences based on interval mapping against a reference.
#'
#' Given a PAC_map object (\code{PAC_mapping}) and an interval list this
#' function will attempt to classify mapped sequences based on where these
#' sequences starts and ends in reference. This function can for example be used
#' for 5' and 3' tRNA classification.
#' 
#' @family PAC analysis
#'   
#' @seealso \url{https://github.com/Danis102} for updates on the current
#'   package.
#'
#' @param map PAC_map object generated by \code{PAC_mapping}.
#'
#' @param intervals A named list with integer intervals.
#'
#' @param type Character indicating what type of intervals that is provided. 
#' 
#' If type="nucleotides", then the interval list is given as ranges of
#' nucleotide positions. For example, if interval=list(start=1:3, end=1:3) the
#' function will classify sequences starting within the first three nucleotides
#' of the reference as 'type_start_nuc' and sequences ending in within the last
#' three nucleotides of the reference as 'type_end_nuc'. 
#' 
#' If type="percent", then intervals needs to be provided as percent ranges. For
#' example, if intervals=list(start=1:5, mid=45:50, end=95:100) then the
#' function will classify sequences starting within the 5% first nucleotides in
#' the references as 'type_start_per', and sequences ending within the 5% last
#' nucleotides of the references as "type_end_nuc". It will also, classify
#' sequences starting in within 45-50% of the references as "type_mid_start_per"
#' and sequences ending within 45-50% of the references as 'type_mid_end_per'.
#' 
#' If type="ss", then intevals is obtain from an ss file/object.
#' 
#'   Important, the intervals list is name senstive. If type="nuclotides"
#'   intervals can only contain two intervals named 'start' and 'end', while if
#'   type="percent" then intervals needs to contain three intervals named
#'   'start', 'mid' and 'end'.
#'
#'   Hint, for classifying 5' and 3' half tsRNA you need to run the function
#'   twice. First, classify each sequence as 5'-start or 3'-end tsRNA using
#'   type="nucleotides", and then rerun the the map object using type="percent"
#'   specifying the 'mid' region as the half interval.
#' 
#' @param ss File path to ss file (character), readLines vector of ss file
#'   (character) or ss list. If character, the function will attempt to read a
#'   file from the path given in the character. If this fails, the function
#'   assumes that the ss file has already been read using \code{readLines}, and
#'   will attempt to split that character vector into a list of unique sequences
#'   by splitting that empty lines. Empty line normally delimits each sequence
#'   entery in the ss file. Such a list can also be parsed directly to the
#'   function, making it easy to change for example sequence names using
#'   \code{lapply} prior to running the function.
#'   
#'   
#' @return Map list object containing reference sequence (Ref_seq) as
#'   Biostrings::DNAStringSet and the new classifications embedded with the
#'   alignments (Alignments) in a dataframe.
#'   
#' @examples
#' 
#' @export

 
map_rangetype <- function(map, type="percent", intervals=list(start=1:5, mid=45:55, end=95:100), ss=NULL, min_loop_width=4){
  
  ## Interval mapping    
  if(type %in% c("nucleotides", "percent")){
    range_types <- lapply(map, function(x){ 
      ref_len <- nchar(paste0(x$Ref_seq))
      align   <- x$Alignments
      if(type=="percent"){
        if(align$n_hits[1] == "no_hits"){
          align$type_start_per <- "no_hits"
          align$type_mid_start_per <- "no_hits"
          align$type_mid_end_per <- "no_hits"
          align$type_end_per <- "no_hits"
          
        }else{
          inter_seq <- lapply(intervals, function(y){
            inter <- round(ref_len*(y*0.01), digits=0)
            return(seq(min(inter), max(inter)))
          })
          align$type_start_per <- ifelse(align$Align_start %in% inter_seq$start, "TRUE", "FALSE")
          align$type_mid_start_per <- ifelse(align$Align_start %in% inter_seq$mid, "TRUE", "FALSE")
          align$type_mid_end_per <- ifelse(align$Align_end %in% inter_seq$mid, "TRUE", "FALSE")
          align$type_end_per <- ifelse(align$Align_end %in% inter_seq$end, "TRUE", "FALSE")
        }
      }
      if(type=="nucleotides"){
        if(align$n_hits[1] == "no_hits"){
          align$type_start_nuc <- "no_hits"
          align$type_end_nuc <- "no_hits"
        }else{
          inter_seq <- list(start=intervals$start, end= seq(ref_len-max(intervals$end), (ref_len-min(intervals$end))+1))
          align$type_start_nuc <- ifelse(align$Align_start %in% inter_seq$start, "TRUE", "FALSE")
          align$type_end_nuc <- ifelse(align$Align_end %in% inter_seq$end, "TRUE", "FALSE")
        }
      }
      x$Alignments <- align
      return(x)        
    })
  }
  
  ## loop mapping   
  if(type=="ss"){
    
    ## Tyr to catch file path
    ss_anno <- tryCatch(readLines(ss), error=function(e){ss})
    
    ## First make a split function if not already a list  
    if(!class(ss_anno) == "list"){
      logi_breaks <- ss_anno == ""
      breaks <- 1
      fact <- NULL
      for (i in 1:length(logi_breaks)){if(logi_breaks[i] == TRUE){breaks <- breaks+1}
        fact <- c(fact, breaks)}
      ss_lst <- split(ss_anno, as.factor(fact))
    }
    ss_lst <- ss_lst[!unlist(lapply(ss_lst, function(x){length(x) <1}))] # Remove list objects
    ss_lst <- lapply(ss_lst, function(x){x <- x[!x == ""]}) # Remove empty lines
    
    ## Extract data from ss
    fin_ss <- lapply(ss_lst, function(x){
      seqs <- x[grepl("\\<Seq: ", x)]
      seqs <- gsub("Seq: ", "", seqs)
      seqs <- gsub("t", "T", seqs)  # Fix introduction of lower case letters by tRNA-scan-SE
      seqs <- gsub("g", "G", seqs)
      seqs <- gsub("a", "A", seqs)
      seqs <- gsub("c", "C", seqs)
      str <- x[grepl("\\<Str: ", x)]
      str <- gsub("Str: ", "", str)
      tpe <- x[grepl("\\<Type: ", x)]
      tpe <- gsub("Type: ", "", tpe)
      isodec_ss <- do.call("rbind", strsplit(tpe, "\t| at"))[,1]
      isoacc_ss <- gsub("Anticodon: ", "",  do.call("rbind", strsplit(tpe, "\t| at"))[,2])
      fin_ss <- data.frame(Ref_seqs=as.character(seqs), ss_anno=as.character(str), isodec_ss=as.character(isodec_ss),  isoacc_ss=as.character(isoacc_ss), stringsAsFactors=FALSE)
      return(fin_ss)
    })
    fin_ss_df <- do.call("rbind", fin_ss)
    names(fin_ss) <- fin_ss_df$Ref_seq
    
    ## Test if map is mature tRNA                          
    logi_map_mature <- any(!unlist(lapply(map, function(x){grepl("CCA\\>", x$Ref_seq)})))
    logi_ss_mature <- any(!unlist(lapply(fin_ss, function(x){grepl("CCA\\>", x$Ref_seqs)})))
    if(logi_map_mature == FALSE && logi_ss_mature == TRUE){
      cat("\nIt seems the map object, but not the ss object, contains only mature tRNA (CCA in the 3'end).\nWill attempt to add CCA to ss object and then match map with ss.\n")
      fin_ss_df$Ref_seqs <- as.character(paste0(fin_ss_df$Ref_seqs, "CCA"))
      fin_ss_df$ss_anno <- as.character(paste0(fin_ss_df$ss_anno, "..."))
    }
    if(any(!(unlist(lapply(map, function(x){paste0(x$Ref_seq)}))) %in% fin_ss_df$Ref_seqs)){stop("The ss object does not contain all references in the map object.\nPlease provide a matched ss file, like the ones generated by tRNAscan-SE.\n(http://lowelab.ucsc.edu/tRNAscan-SE/)")}
    
    ## Extract loop annotation 
    range_types <- lapply(map, function(x){ 
      
      ## Identify different loops map references using ss
      trgt <- fin_ss_df[paste0(x$Ref_seq) == fin_ss_df$Ref_seqs, ,drop=FALSE]
      stopifnot(nchar(trgt$ss_anno) == nchar(trgt$Ref_seqs))
      
      ## Check if there are speciel case character
      splt_char <- strsplit(paste0(trgt$ss_anno), "")[[1]]
      logi_char <- splt_char %in% c(">", ".", "<")
      if(any(!logi_char)){
        warning("Located special character in ss loop annoation (character else than: '>' '.' '<').\nWill attempt to translate that character to '.'") 
        splt_char[!logi_char] <- "."
        trgt$ss_anno <- as.character(paste0(splt_char, collapse=""))
      }
      
      ## Generate loop intervals
      code_split <-  as.data.frame(stringr::str_locate_all(as.character(trgt$ss_anno), paste0(">[\\.X]{", min_loop_width,",}<"))[[1]])  # Find ">" with only "." or "X" before "<" ./X must occur at least 5 times. Explanation: str_locate_all looks for < and > but they should not be counted.
      code_split$start <- code_split$start +1  ## Start and ends needs to be adjusted; +1 at starts and -1 at ends
      code_split$end <- code_split$end -1  
      
      ## Merge with map
      algn <- x$Alignments
      algn$n_ssloop <- nrow(code_split)
      code_split$loop_name <- rownames(code_split)
      code_split$range <-  paste(code_split$start, code_split$end, sep=":")
      df <- t(data.frame(matrix(code_split$range, nrow = nrow(code_split) , ncol =nrow(algn))))
      colnames(df) <- paste0("range_loop", code_split$loop_name)
      rownames(df) <- rownames(algn)
      algn_loop <- cbind(algn, df)
      
      ## Generate fragment classification
      ncl <- ncol(algn_loop)
      for (i in 1:nrow(code_split)){
        algn_loop[,ncl+i] <-  algn$Align_start %in% seq(code_split$start[i], code_split$end[i])
        colnames(algn_loop)[ncl+i] <- paste0("type_start_loop", i)
      }
      ncl <- ncol(algn_loop)
      for (i in 1:nrow(code_split)){
        algn_loop[,ncl+i] <-  algn$Align_end %in% seq(code_split$start[i], code_split$end[i])
        colnames(algn_loop)[ncl+i] <- paste0("type_end_loop", i)
      }
      x$Alignments <- algn_loop
      x$Loop <- c(paste0("Loops are located between '>>..<<'"), paste0(x$Ref_seq), unique(paste0(trgt$ss_anno))) 
      return(x)
    })
  }
  return(range_types)
}
   