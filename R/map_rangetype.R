#' Interval classification. 
#'
#' \code{map_rangetype} Classifies sequences based on interval mapping against a reference.
#'
#' Given a PAC_map object (\code{PAC_mapping}) and an interval list this
#' function will attempt to classify mapped sequences based on where these
#' sequences starts and ends in reference. This function can for example be used
#' for 5' and 3' tRNA classification.
#' 
#' @family PAC analysis
#'   
#' @seealso \url{https://github.com/Danis102} for updates on the current
#'   package.
#'
#' @param map PAC_map (generated by \code{PAC_mapping}) or a Reanno object
#'   (generated by \code{map_reanno}), containing mapping coordinates against a
#'   reference fasta file.
#'   
#' @param intervals A named list with integer intervals.
#'
#' @param type Character indicating what type of intervals that is provided. 
#' 
#' If type="nucleotides", then the interval list is given as ranges of
#' nucleotide positions. For example, if interval=list(start=1:3, end=1:3) the
#' function will classify sequences starting within the first three nucleotides
#' of the reference as 'type_start_nuc' and sequences ending in within the last
#' three nucleotides of the reference as 'type_end_nuc'. 
#' 
#' If type="percent", then intervals needs to be provided as percent ranges. For
#' example, if intervals=list(start=1:5, mid=45:50, end=95:100) then the
#' function will classify sequences starting within the 5% first nucleotides in
#' the references as 'type_start_per', and sequences ending within the 5% last
#' nucleotides of the references as "type_end_nuc". It will also, classify
#' sequences starting in within 45-50% of the references as "type_mid_start_per"
#' and sequences ending within 45-50% of the references as 'type_mid_end_per'.
#'
#' If type="ss", then intevals is obtain from an ss file, obtained for example
#' from tRNAscan-SE (\url{http://lowelab.ucsc.edu/tRNAscan-SE/}) or at GtRNAdb
#' \url{http://gtrnadb.ucsc.edu/}.
#' 
#'   Important, the intervals list is name senstive. If type="nuclotides"
#'   intervals can only contain two intervals named 'start' and 'end', while if
#'   type="percent" then intervals needs to contain three intervals named
#'   'start', 'mid' and 'end'.
#'
#'   Hint, for classifying 5' and 3' half tsRNA you need to run the function
#'   twice. First, classify each sequence as 5'-start or 3'-end tsRNA using
#'   type="nucleotides", and then rerun the the map object using type="percent"
#'   specifying the 'mid' region as the half interval.
#' 
#' @param ss File path to ss file (character), readLines vector of ss file
#'   (character) or ss list. If character, the function will attempt to read a
#'   file from the path given in the character string. If this fails, the function
#'   assumes that the ss file has already been read using \code{readLines}, and
#'   will attempt to split that character vector into a list of unique sequences
#'   by splitting at the empty lines. Empty line normally delimits each sequence
#'   entery in the ss file. Such a list can also be parsed directly to the
#'   function, making it easy to change for example sequence names using
#'   \code{lapply} prior to running the function.
#'   
#' @param N_include Logical whether or not N "wild card" nucleotides should be
#'   counted in the terminals. This conveniently controls the N_up and N_down
#'   arguments in the \code{PAC_mapper} function. If N_include=FALSE (default),
#'   start and end of tRNA will be measured the first and last canonical
#'   nucleotides (A, T, C, G). Thus if fragments align to an NNN-terminal, it
#'   will recieve a netagitve value. If N_include=TRUE, N wild-cards will be
#'   treated as any other nucleotide.
#'   
#' @return Map list object containing reference sequence (Ref_seq) as
#'   Biostrings::DNAStringSet and the new classifications embedded with the
#'   alignments (Alignments) in a dataframe.
#'   
#' @examples
#' 
#' @export

 
map_rangetype <- function(map, type="percent", intervals=list(start=1:5, mid=45:55, end=95:100), ss=NULL, min_loop_width=4, N_include=FALSE){
  
  ## Compensate for N up and down setup
  if(N_include==FALSE){
          N_counts <- lapply(map, function(x){
              Ns <- unlist(strsplit(paste0(x[[1]]), "A|T|C|G"))
              Ns <- Ns[c(1, length(Ns))]
              if(!identical(stringr::str_count(Ns, "N"), nchar(Ns))){
                stop("\nYou have other wild-cards than N in your terminals.\nThis function does not allow other nucleotides than N, A, T, C and G.")
              }
              nchar(Ns)
          })
        }else{
          N_counts <- NULL
        }
  
  ## Interval mapping    
      if(type %in% c("nucleotides", "percent")){

        range_types <- map
          for(i in 1:length(map)){
              ref_len <- nchar(paste0(map[[i]]$Ref_seq))
              align   <- map[[i]]$Alignments

              ## Compensate for N_include
              if(!is.null(N_counts[[i]])){
                ref_len <- ref_len - sum(unlist(N_counts[[i]]))
                align$Align_start   <- align$Align_start - N_counts[[i]][1]
                align$Align_end   <- align$Align_end - N_counts[[i]][2]
                substring(align$Align_string, 1, N_counts[[i]][1]) <- paste(rep("*", times=N_counts[[i]][1]), collapse="")
                substring(align$Align_string, nchar(align$Align_string) -  N_counts[[i]][2], nchar(ref_len)) <- paste(rep("*", times=N_counts[[i]][2]), collapse="")
              }
              
              ## Percent
              if(type=="percent"){
                if(align$n_hits[1] == "no_hits"){
                  align$type_start_per <- "no_hits"
                  align$type_mid_start_per <- "no_hits"
                  align$type_mid_end_per <- "no_hits"
                  align$type_end_per <- "no_hits"
                }else{
                  inter_seq <- lapply(intervals, function(y){
                    inter <- round(ref_len*(y*0.01), digits=0)
                    return(seq(min(inter), max(inter)))
                  })
                  align$type_start_per <- ifelse(align$Align_start %in% inter_seq$start, "TRUE", "FALSE")
                  align$type_mid_start_per <- ifelse(align$Align_start %in% inter_seq$mid, "TRUE", "FALSE")
                  align$type_mid_end_per <- ifelse(align$Align_end %in% inter_seq$mid, "TRUE", "FALSE")
                  align$type_end_per <- ifelse(align$Align_end %in% inter_seq$end, "TRUE", "FALSE")
                }
              }
              
              ## Nucleotides
              if(type=="nucleotides"){
                if(align$n_hits[1] == "no_hits"){
                  align$type_start_nuc <- "no_hits"
                  align$type_end_nuc <- "no_hits"
                }else{
                  inter_seq <- list(start=intervals$start, end= seq(ref_len-max(intervals$end), (ref_len-min(intervals$end))+1))
                  align$type_start_nuc <- ifelse(align$Align_start %in% inter_seq$start, "TRUE", "FALSE")
                  align$type_end_nuc <- ifelse(align$Align_end %in% inter_seq$end, "TRUE", "FALSE")
                }
              }
          range_types[[i]]$Alignments <- align
        }
      }
      
  ## loop mapping   
  if(type=="ss"){
    
    ## Try to catch file path
    ss_anno <- tryCatch(readLines(ss), error=function(e){ss})
    
    ## First make a split function if not already a list  
    if(!class(ss_anno) == "list"){
      logi_breaks <- ss_anno == ""
      breaks <- 1
      fact <- NULL
      for (i in 1:length(logi_breaks)){
        if(logi_breaks[i] == TRUE){
          breaks <- breaks+1
          }
        fact <- c(fact, breaks)
        }
      ss_lst <- split(ss_anno, as.factor(fact))
    }
    ss_lst <- ss_lst[!unlist(lapply(ss_lst, function(x){length(x) <1}))] # Remove list objects
    ss_lst <- lapply(ss_lst, function(x){x <- x[!x == ""]}) # Remove empty lines
    
    ## Extract data from ss
    fin_ss <- lapply(ss_lst, function(x){
      seqs <- x[grepl("\\<Seq: ", x)]
      seqs <- gsub("Seq: ", "", seqs)
      seqs <- gsub("t", "T", seqs)  # Fix introduction of lower case letters by tRNA-scan-SE
      seqs <- gsub("g", "G", seqs)
      seqs <- gsub("a", "A", seqs)
      seqs <- gsub("c", "C", seqs)
      str <- x[grepl("\\<Str: ", x)]
      str <- gsub("Str: ", "", str)
      tpe <- x[grepl("\\<Type: ", x)]
      tpe <- gsub("Type: ", "", tpe)
      isodec_ss <- do.call("rbind", strsplit(tpe, "\t| at"))[,1]
      isoacc_ss <- gsub("Anticodon: ", "",  do.call("rbind", strsplit(tpe, "\t| at"))[,2])
      fin_ss <- data.frame(Ref_seqs=as.character(seqs), ss_anno=as.character(str), isodec_ss=as.character(isodec_ss),  isoacc_ss=as.character(isoacc_ss), stringsAsFactors=FALSE)
      return(fin_ss)
    })
    fin_ss_df <- do.call("rbind", fin_ss)
    names(fin_ss) <- fin_ss_df$Ref_seq
    
    ## Test if map is mature tRNA                          
    logi_map_mature <- any(!unlist(lapply(map, function(x){grepl("CCA\\>", x$Ref_seq)})))
    logi_ss_mature <- any(!unlist(lapply(fin_ss, function(x){grepl("CCA\\>", x$Ref_seqs)})))
    if(logi_map_mature == FALSE && logi_ss_mature == TRUE){
      cat("\nIt seems the map object, but not the ss object, contains only mature tRNA (CCA in the 3'end).\nWill attempt to add CCA to ss object and then match map with ss.\n")
      fin_ss_df$Ref_seqs <- as.character(paste0(fin_ss_df$Ref_seqs, "CCA"))
      fin_ss_df$ss_anno <- as.character(paste0(fin_ss_df$ss_anno, "..."))
    }
        
    ## Test if all references are included
    original_refs <- unlist(lapply(map, function(x){gsub("N", "", paste0(x$Ref_seq))}))
    logi_all  <- original_refs  %in% fin_ss_df$Ref_seqs
    match_original  <- match(fin_ss_df$Ref_seqs, original_refs)
    # Remove the missing references
    if(any(!logi_all)){
      cat("\n")
      warning("The ss object does not contain all references in the map object.\nFor best result provide a matched ss file, generated by for example tRNAscan-SE.\n(http://lowelab.ucsc.edu/tRNAscan-SE/)", call. = FALSE, immediate.=TRUE)
      cat("\nThe following reference(s) will therefore be removed from the results:\n")  
      print(names(map)[!logi_all])
      map <- map[match_original]
      N_counts <- N_counts[match_original]
    }
    # Match the ss
    original_refs <- unlist(lapply(map, function(x){gsub("N", "", paste0(x$Ref_seq))}))
    match_ss  <- match(original_refs, fin_ss_df$Ref_seqs)
    fin_ss_df <- fin_ss_df[match_ss,]
    
    # Compensate for N_up and N_down
    stopifnot(identical(fin_ss_df$Ref_seqs, paste0(unlist(lapply(map, function(x){gsub("N", "", paste0(x$Ref_seq))})))))
    stopifnot(identical(names(N_counts), names(map)))
    range_types <- map
    for(i in 1:nrow(fin_ss_df)){
        if(!is.null(N_counts[[i]])){
                    fin_ss_df$Ref_seqs[i] <- paste0(paste(rep("N", times=N_counts[[i]][1]), collapse=""), fin_ss_df$Ref_seqs[i])
                    fin_ss_df$Ref_seqs[i] <- paste0(fin_ss_df$Ref_seqs[i], paste(rep("N", times=N_counts[[i]][1]), collapse=""))
                    fin_ss_df$ss_anno[i] <- paste0(paste(rep(".", times=N_counts[[i]][1]), collapse=""), fin_ss_df$ss_anno[i])
                    fin_ss_df$ss_anno[i] <- paste0(fin_ss_df$ss_anno[i], paste(rep(".", times=N_counts[[i]][1]), collapse=""))
                    if(!map[[i]][[2]]$Align_string[1] == "no_hits"){
                      substring(map[[i]][[2]]$Align_string, 1, N_counts[[i]][1]) <- paste(rep("*", times=N_counts[[i]][1]), collapse="")
                      substring(map[[i]][[2]]$Align_string, nchar(map[[i]][[2]]$Align_string) -  N_counts[[i]][2]+1, nchar(map[[i]][[2]]$Align_string)) <- paste(rep("*", times=N_counts[[i]][2]), collapse="")
                    }
        }

      ## Identify different loops map references using ss
      trgt <- fin_ss_df[i, ,drop=FALSE]
      stopifnot(nchar(trgt$ss_anno) == nchar(trgt$Ref_seqs))
      
      ## Check if there are special case character
      splt_char <- strsplit(paste0(trgt$ss_anno), "")[[1]]
      logi_char <- splt_char %in% c(">", ".", "<")
      if(any(!logi_char)){
        warning("Located special character in ss loop annoation (character else than: '>' '.' '<').\nWill attempt to translate that character to '.'") 
        splt_char[!logi_char] <- "."
        trgt$ss_anno <- as.character(paste0(splt_char, collapse=""))
      }
      
      ## Generate loop intervals
      code_split <-  as.data.frame(stringr::str_locate_all(as.character(trgt$ss_anno), paste0(">[\\.X]{", min_loop_width,",}<"))[[1]])  # Find ">" with only "." or "X" before "<" ./X must occur at least 5 times. Explanation: str_locate_all looks for < and > but they should not be counted.
      code_split$start <- code_split$start +1  ## Start and ends needs to be adjusted; +1 at starts and -1 at ends
      code_split$end <- code_split$end -1  
      
      ## Merge with map
      algn <- map[[i]][[2]]
      algn$n_ssloop <- nrow(code_split)
      code_split$loop_name <- rownames(code_split)
      code_split$range <-  paste(code_split$start, code_split$end, sep=":")
      df <- t(data.frame(matrix(code_split$range, nrow = nrow(code_split) , ncol =nrow(algn))))
      colnames(df) <- paste0("range_loop", code_split$loop_name)
      rownames(df) <- rownames(algn)
      algn_loop <- cbind(algn, df)
      
      ## Generate fragment classification
      ncl <- ncol(algn_loop)
      for (k in 1:nrow(code_split)){
        algn_loop[,ncl+k] <-  algn$Align_start %in% seq(code_split$start[k], code_split$end[k])
        colnames(algn_loop)[ncl+k] <- paste0("type_start_loop", k)
      }
      ncl <- ncol(algn_loop)
      for (k in 1:nrow(code_split)){
        algn_loop[,ncl+k] <-  algn$Align_end %in% seq(code_split$start[k], code_split$end[k])
        colnames(algn_loop)[ncl+k] <- paste0("type_end_loop", k)
      }
      algn_loop$decoder <-  trgt$isodec_ss
      algn_loop$acceptor <-  trgt$isoacc_ss
      range_types[[i]]$Alignments <- algn_loop
      range_types[[i]]$Loop <- c(paste0("Loops are located between '>>..<<'"), paste0(map[[i]]$Ref_seq), unique(paste0(trgt$ss_anno)))
    }
  }
  range_types <- range_types[!is.null(range_types)]
  return(range_types)
}
   