#'Generates biotype annotation from reannotation object
#'
#'\code{add_reanno} adds biotypes from reannotation to PAC.
#'
#'Given a reanno object generated by \code{make_reanno} this function will
#'either extract genome coordinates or classify biotypes using a list of search
#'terms list (see below). Information will be compiled into a dataframe with the
#'same sequence order as in the original PAC master file.
#'
#' @family PAC reannotation
#'
#' @seealso \url{https://github.com/junchaoshi/sports1.0} for download and
#'  documentation about running Sports.
#'  \url{http://bowtie-bio.sourceforge.net/index.shtml} for information about
#'  Bowtie \url{https://github.com/Danis102} for updates on the current package.
#'
#' @param reanno A reannotation list object generated by \code{make_reanno}, with
#'  an Overview dataframe and a Full_anno list.
#'  
#' @param mismatches Integer indicating the number of mismatches that should be
#'  reported. Can never have a higher number than was originally used in the
#'  reannotation workflow. While default=0, reporting the maximum number is
#'  recommended. The mismatch information is only added to the report, not
#'  exchanging annotation hits with fewer mismatches.
#'  
#' @param type Character indicating what type of classification. If
#'   type="genome", the reanno object is expected to have genome coordinates as
#'   controlled by \code{map_reanno} and the \code{import_reanno} functions.
#'   Here all hits will be reported. If type="biotype", then coordinates are not
#'   expected. Reference hits will instead be classified according to the biotype
#'   search terms in \code{bio_search}.
#'   
#' @param bio_search List of character vectors indicating search terms targeting
#'   feature names in the original reference fasta files. These search terms
#'   will be parsed to \code{grepl} as regular expressions. List names must
#'   match names of the references in the reanno object. Classifications will
#'   be reported with reference name + search term (e.g. "Ensembl_mt:trna").
#'   
#' @param bio_perfect Logical whether the function should allow that not all
#'   hits against the references must have a unique bio_search term. If
#'   perfect=FALSE (default) all references hits that was not caught by a search
#'   term will be annotated as references + other (e.g. "Ensembl_other"). If
#'   perfect=TRUE, if the search terms does not catch all reference hits the
#'   function will through an error. Can be used to ensure that all hits receive
#'   a classification.
#'
#' @param genome_max Integer indicating the number of maximum coordinates to be
#'   reported when type="genome". If the number of hits exceedes
#'   \code{genome_max} it will be indicated in the classification and only the
#'   first hits up to \code{max_hits} will be reported. Useful to handling
#'   seaquences that multimap.
#'   
#' @return Dataframe with mismatch and coordinate or biotype information (search
#'   term hits) that can directly be added to an Anno dataframe of a PAC object,
#'   given that the same PAC object was used in the reannotation workflow. It
#'   can also be further simplifide using the \code{symplify_reanno} function.
#'   
#' @examples
#' library(seqpac)
#' load(system.file("extdata", "drosophila_sRNA_pac.Rdata", package = "seqpac", mustWork = TRUE))
#' 
#' outpath_genome="/home/danis31/Desktop/Temp_docs/reanno_genome"
#' outpath_snc="/home/danis31/Desktop/Temp_docs/reanno_srna"
#' 
#' reanno <- make_reanno(outpath_genome, PAC=pac_master, mis_fasta_check = TRUE, threads=8)
#' reanno <- make_reanno(outpath_snc, PAC=pac_master, mis_fasta_check = TRUE, threads=8)
#' 
#' ls.str(reanno)
#' 
#' colnames(reanno$Full_anno$mis0$genome)
#' 
#' type = "genome"
#' type = "biotype"
#' 
#' # Search terms must target the same names as in reanno
#' # Double check:
#' lapply(reanno$Full_anno, names)
#' 
#' bio_search <- list(
#'                  Ensembl=c("lncRNA", "miRNA", "pre_miRNA", "rRNA", "snoRNA", "snRNA", "tRNA"),
#'                  miRNA="dme-",
#'                  tRNA =c("^tRNA", "mt:tRNA")      # ^= regular expression for start of string  
#'                  )
#'                  
#'  bio_search <- list(
#'                  Ensembl=c("lncRNA", "miRNA"),
#'                  miRNA="dme-",
#'                  tRNA =c("^tRNA", "mt:tRNA")      # ^= regular expression for start of string  
#'                  )                
#'                  
#'                  
#' anno <- add_reanno(reanno, bio_search=bio_search, type="biotype", bio_perfect=FALSE, mismatches = 3)
#' anno <- add_reanno(reanno, bio_search=bio_search, type="biotype", bio_perfect=TRUE, mismatches = 3)             
#' 
#' @export
add_reanno <- function(reanno, mismatches=0, type="genome", bio_search, bio_perfect=FALSE, genome_max=10){
  require(tidyverse)
  # Setup
  stopifnot(any(do.call("c", lapply(reanno$Full_anno, function(x){do.call("c", lapply(x, function(y){identical(reanno$Overview$seq, y$seq)}))}))))
  seq_nam <- reanno$Overview$seq

## Extract genome ###############################
  # if(type=="genome")
  # 
  #     for (i in 1:(mismatches+1)){
  # 
  # 

## Extract biotypes ###############################
  if(type=="biotype"){
    bio_nam <- names(bio_search)
    fin_lst <- list(NA)
    fin_strand_lst <- list(NA)
    cat("\nExtracting the biotypes ...")
    cat(paste0("\n  Sequences in total: ", length(seq_nam))) 
  
    ## Loop mismatch
    for (i in 1:(mismatches+1)){
      full_lst  <- reanno$Full_anno[[i]]
      bio_vec_lst <- list(NA)
      strand_lst <- list(NA)
      
      ## Loop biotype
      for (a in 1:length(bio_search)){
        extracted  <-  full_lst[bio_nam[a]]
        
        ## First annotate sense antisense 
        sns  <- grepl(":sense\\||:sense$", extracted[[1]]$ref_hits) 
        antisns  <- grepl(":antisense\\||:antisense$", extracted[[1]]$ref_hits)
        strand_lst[[a]] <- paste0(ifelse(sns, "s", ""), ifelse(antisns, "a", ""))
        
        ## Now classify with search terms
        if(!length(extracted) == 1){stop("\nThe names in bio_search did not match the names in the reanno tables.\nPlease modify your reference input names in bio_search.")}
        if(length(bio_search[[a]])==1){
          bio_df <- do.call("cbind", lapply(as.list(bio_search[[a]]), function(x){ return(ifelse(grepl(x, extracted[[1]]$ref_hits), paste0(bio_nam[a]), "<NA>"))}))
        }
        if(length(bio_search[[a]])>1){
          bio_df <- do.call("cbind", lapply(as.list(bio_search[[a]]), function(x){ return(ifelse(grepl(x, extracted[[1]]$ref_hits), paste0(bio_nam[a], "_", x, "|"), "<NA>"))}))
        }
        bio_vec <- gsub("<NA>", "", apply(bio_df, 1, function(x){return(paste(x, collapse=""))}))
        bio_hits <- as.numeric(grepl(".", bio_vec))
        over_hits <- as.numeric(grepl(names(reanno$Full_anno)[i], reanno$Overview %>% dplyr::pull(bio_nam[a])))
        
        # Check bio_perfect 
        if(bio_perfect == TRUE){
           if(!identical(bio_hits, over_hits)){
             cat("\n")
             stop("\n  Your search terms did not catch all\n  instances in Overview column: ",bio_nam[a], "\n  Please, modify bio_search or set bio_perfect=FALSE.", call. = FALSE)
           }
        }
        
        # Fix missing hits
        if(bio_perfect == FALSE){
            if(any(paste0(over_hits, bio_hits) == "01")){
                stop("\n  There were more bio_search hits than there were references hits in the Overview table.\n  This should not happen. Please, rerun make_reanno to generate an Overview table \n  that matches the Full annotation tables.")    
            }
            bio_vec[paste0(over_hits, bio_hits) == "10"] <- paste0(bio_nam[a], "_other")
        }
      
        # Print some stats and fix classifications
        cat_nam <- paste0(bio_nam[a], ":", paste0(rep(" ", times= max(nchar(bio_nam)+1)-nchar(bio_nam[a])), collapse=""))
        cat_over <- paste0(sum(over_hits), paste0(rep(" ", times= 8-nchar(sum(over_hits))), collapse=""))
        cat_bio <- paste0(sum(bio_hits), paste0(rep(" ", times= 8-nchar(sum(bio_hits))), collapse=""))
        cat_diff <- paste0(paste0(sum(over_hits)-sum(bio_hits)), paste0(rep(" ", times= 8-nchar(paste0(sum(over_hits)-sum(bio_hits)))), collapse=""))
        
        cat(paste0("\n\tmis", i-1, "\t",  cat_nam,"\tRef_hits=", cat_over, "\t|Search=", cat_bio, "\t|Other=", cat_diff)) 
        bio_vec_lst[[a]] <- gsub("\\|$", "", bio_vec)
        names(bio_vec_lst)[a] <- names(bio_search)[a]
      }
      fin_lst[[i]] <- bio_vec_lst
      names(fin_lst)[i] <- names(reanno$Full_anno)[i]
      fin_strand_lst[[i]] <- strand_lst
    }
    
    # Finish up
    cat("\nCompiling everything into one dataframe ...")
    shrt <- lapply(fin_lst, function(x){do.call("cbind", x)})
    fin <- lapply(shrt, function(x){apply(x, 1, function(y){
      y[y==""] <- "<NA>"
      bio_comb <- paste(y, collapse=";")
      bio_comb <- gsub(";<NA>|<NA>;", "", bio_comb)
      bio_comb <- gsub("<NA>", "_", bio_comb)
      return(bio_comb)
    })})
    
    fin <- as.data.frame(do.call("cbind", fin), stringsAsFactors =FALSE)
    rownames(fin) <- seq_nam
    logi_strand <- apply(do.call("cbind", lapply(fin_strand_lst, function(x){do.call("cbind", x)})), 1 , function(z){paste(z, collapse="")})
    fin_strand <- paste(ifelse(grepl("s", logi_strand), "+",""), ifelse(grepl("a", logi_strand), "-",""), sep="|")  

    detach(package:tidyverse)
    return(tibble::as_tibble(cbind(reanno$Overview, data.frame(strand=fin_strand, stringsAsFactors =FALSE), fin)))
  }
}
