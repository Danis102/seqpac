#' Aligning sequences against references using bowtie 
#'
#' Aligns sequences in a PAC list object against specified references generating
#' summarized report files in destination folder.
#' 
#' Given a PAC object this function will extract the sequences and align them
#' against single or multiple fasta reference files. Summarized output will be
#' saved as .Rdata files in the desitnation folder. In its default setting the
#' function will only report hit or no hit in up to 3 mismatches, but this can
#' easily be changed between 0-5 mismatches, to include alignment coordinates
#' and reference name extractions. Information from the .Rdata files
#' (Full_reanno_mis0/1/2/3/4/5.Rdata) can then be extracted and added to a PAC
#' object using \code{make_reanno} and \code{add_reanno} functions. For increase
#' compatability across platforms, the function provides both R internal bowtie
#' parsing (thorugh the Rbowtie package), as well as external parsing to a
#' locally installed version of bowtie.
#' 
#' 
#' @family PAC reannotation
#'
#' @seealso  \url{http://bowtie-bio.sourceforge.net/index.shtml} for information
#'   about Bowtie and for Rbowtie:
#'   \url{https://www.bioconductor.org/packages/release/bioc/html/Rbowtie.html}.
#'   \url{https://github.com/Danis102} for updates on the current package.
#'
#' @param PAC PAC-list object containing an Anno data.frame with sequences as
#'   row names.
#'   
#' @param type Character indicating if mapping should be performed by calling
#'   the internal bowtie function of the Rbowtie package (type="internal"), or
#'   if bowtie should be called externally through a system call for a locally
#'   installed bowtie (type="external").
#'   
#' @param mismatches Integer indicating the maximum number of mismatches allowed
#'   alignments. The function currently supports no more than 5 mismatches.
#'   
#' @param output_path Character indicating the path to the destination folder
#'   for the files generated by the script.
#'
#' @param ref_paths List of character file paths indicating the full paths to
#'   each fasta reference file. Importantly, carefully name each reference path
#'   as the names will appear as they are named in the final annotation table.
#'   Thus if \emph{ref_paths=list(tRNA="<path_tRNA_ref>",
#'   miRNA="<path_piRNA_ref>")} mapping to these fasta references will appear as
#'   "tRNA" and "miRNA", respectively. Note: All reference fasta files must have
#'   bowtie indexs using bowtie-build (e.g. Rbowtie::bowtie_build).
#'   
#' @param parse_internal One character string specifying the additional options
#'   parsed to the bowtie function in the Rbowtie package when type="internal".
#'   The string follows similar rules as '...' parsing. See ?Rbowtie::bowtie
#'   details on the format. As default: parse_internal= "a=TRUE, f=TRUE".
#'
#' @param parse_external One character string specifying the additional options
#'   parsed to externally installed bowtie when type="external". The string
#'   follows similar rules as '...' parsing. More information on the formating
#'   use: \code{system("bowtie --manual", intern=TRUE, ignore.stderr=FALSE)}. If this
#'   command fails you probably do not have bowtie correctly installed. As
#'   default parse_external= "-a -f".
#'
#' @param import List with exactly 3 objects, named "coord", "report" and
#'   "reduce" that specifies the options for bowtie import. This list will be
#'   parsed to the \code{import_reanno} function, where ?import_reanno will give
#'   more information. As default, \emph{import=list(coord=FALSE,
#'   report="minimum", reduce=NULL)}. This means that mapping coordinates
#'   (coord) will not be reported and only minimum information of each alignment
#'   will be reported (simply hit or no hit). This option increases the
#'   performance dramatically. Setting \emph{import=list(coord=TRUE,
#'   report="full", reduce=NULL)} will instead import both the mapping
#'   coordinates and the names of each entery in the fasta reference files
#'   listed in \emph{ref_path}. This option could be very slow and reasource
#'   heavy given that bowtie has been set to a=TRUE so that all alignments of
#'   extremely repetitive features are imported. With the reduce option,
#'   alignments against a specific reference can be exempted from a full report
#'   when report="full". For example, \emph{import=list(coord=TRUE,
#'   report="full", reduce=c("piRNA", "repeatMasker"))} will report the
#'   coordinates and long names of all reference alignments except for the
#'   references named "piRNA" and "repeatMasker" in the ref_path list, that
#'   instead will have a minimum report. This can be useful when millions of
#'   sequences are aligned. Remember, since seqpac maintain sequence integrety,
#'   generating full reports are easily done on a later stage, when fewer target
#'   sequences are mapped.
#'
#' @param threads Integer indicating the number of paralell workers to be used.
#'
#' @param par_type Character indicating what type of parallelization to be used.
#'   (Default = "PSOCK")
#'   
#' @param keep_temp Logical whether or not bowtie output files temporarly stored
#'   in the output path should be deleted. Note, this option is only used for
#'   troubleshooting. The bowtie output files are named as the reference files
#'   and are overwritten in each mismatch round. Thus for safe saving of
#'   mismatch 0 bowtie output make sure that \code{mismatches=0}. If not, the
#'   mismatch 1 round will overwrite the botwie files.
#'   
#' @return Will primarily generate .Rdata files in the destination folder
#'   (\emph{output_path}) containing summarized information about the reference
#'   alignments. One file is generated for every mismatch specified in
#'   \emph{mismatches}. The  \code{make_reanno} function can then be used to
#'   extract and generate an annotation table for a PAC list object. Large
#'   temporary bowtie input and output files will also be generated in the
#'   destination folder, but are removed unless \emph{temp_remove=FALSE}.
#'  
#' @examples
#' 
#'#### Example type = "internal" with genome alignment #### 
#'
#' library(seqpac)
#' load(system.file("extdata", "drosophila_sRNA_pac.Rdata", package = "seqpac", mustWork = TRUE))
#' 
#' ## Path to bowtie indexed reference genome fasta 
#' ref_paths <- list(genome="/data/Data_analysis/Genomes/Drosophila/dm6/Ensembl/dm6_ensembl_release_101/fasta/chr/fast_chr.fa")
#' ## Path to output folder:
#' output_path <- "/home/danis31/Desktop/Temp_docs/reanno_genome"
#' ## Import options (see ?import_reanno):
#' import <- list(coord=TRUE, report="full", reduce=NULL)
#'                               
#' map_reanno(PAC=pac_master, ref_paths=ref_paths, output_path=output_path, 
#'            type="internal", mismatches=3, import=import, threads=8, keep_temp=TRUE)
#' 
#' 
#' #### Example type= external #### 
#' library(seqpac)
#' load(system.file("extdata", "drosophila_sRNA_pac.Rdata", package = "seqpac", mustWork = TRUE))
#'
#' ## Path to bowtie indexed fasta references   
#' ref_paths <- list(miRNA="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/miRNA/miRBase_21-dme.fa",
#'                   Ensembl="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/Ensembl/Drosophila_melanogaster.BDGP6.ncrna.fa",
#'                   rRNA="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/rRNA_reanno/drosophila_rRNA_all.fa",
#'                   tRNA="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/tRNA_reanno/tRNA_mature.fa",
#'                   piRNA="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/piRNA_piRBase/piR_dme.fa")
#' 
#' ## Path to output folder:
#' output_path <- "/home/danis31/Desktop/Temp_docs/"
#' ## Import options (see ?import_reanno):
#' import <- list(coord=FALSE, report="full", reduce=c("piRNA","Ensembl"))
#'
#' map_reanno(pac_master, ref_paths=ref_paths, output_path=output_path, 
#'            type="external", mismatches=3,  import=import, threads=8)
#'
#'
#' # Do not run:
#' map_reanno(pac_master, ref_paths=ref_paths, output_path=output_path, 
#'            type="internal", mismatches=3,  import=import, threads=8, keep_temp=FALSE)
#'   
#' ref_paths <- list(miRNA="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/miRNA/miRBase_21-dme.fa",
#'                   Ensembl="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/Ensembl/Drosophila_melanogaster.BDGP6.ncrna.fa",
#'                   rRNA="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/rRNA_reanno/drosophila_rRNA_all.fa",
#'                   tRNA="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/tRNA_reanno/tRNA_mature.fa")
#'         
#'                 
#'                                 
#' @export
# 
map_reanno <- function(PAC, type="internal", output_path, ref_paths, 
                       mismatches=3, threads=1, par_type="PSOCK", 
                       parse_external= "-a -f", parse_internal = "a=TRUE, f=TRUE", 
                       import=list(coord=FALSE, report="minimum", reduce=NULL), keep_temp=FALSE){

  ## setup
  stopifnot(PAC_check(PAC))
  mis_lst <- as.list(0:mismatches)
  names(mis_lst) <- paste0("mis", 0:mismatches)
  ref_paths <- lapply(ref_paths, function(x){gsub("\\.fa$", "", x)})
  seq_fst <- Biostrings::DNAStringSet(rownames(PAC$Anno))
  names(seq_fst) <- paste(seq_fst)

  ## Look for files and folders in output path
  drs <- list.dirs(output_path, full.names = FALSE, recursive = FALSE) 
  fls <- list.files(output_path, recursive = FALSE)
  if(length(fls[!fls %in% drs])>0){
      warning(paste0("\n  There are files in the output folder:\n  ", output_path,  "\n  Is it ok to delete them? (y/n)"), immediate.=TRUE, call.=FALSE)
      response <- readline()
      if(!response %in% c("y", "Y")){stop(paste0("Please move or delete the files in the output folder."))}
  }
  if(!dir.exists(output_path)){suppressWarnings(dir.create(output_path))  
  }else{
      fls_full <- list.files(output_path, recursive = FALSE, full.names=TRUE)
      file.remove(fls_full[!fls %in% drs])}
  
  ## Save first input
  Biostrings::writeXStringSet(seq_fst, filepath=paste0(output_path, "/anno_mis0.fa"), format="fasta")

  ## Run bowtie over each reference
  if(type=="internal"){
    vrs <- capture.output(Rbowtie::bowtie_version())
    vrs <- gsub("  |bowtie version ", " ", basename(vrs[[1]]))
    vrs <- gsub(" ", "", basename(vrs[[1]]))
    vrs <- gsub("\"", "", basename(vrs[[1]]))
    cat("\nR internal mapping using the Rbowtie package was specified.\n")
    cat(paste0("This package uses bowtie version ", vrs, ".\n"))
    cat("If you need a newer version, please install Bowtie manually\n")
    cat("outside R and then use option type='external'.\n")}
  
  if(type=="external"){
    vrs <- stringr::str_split(basename(capture.output(system("bowtie --version", intern=TRUE))[[1]]), "version")
    cat("\nR external mapping depends on correct installation of bowtie.\n")
    cat("If you are having problem using external bowtie, try type='internal'.\n")
    cat(paste0("An external bowtie installation was found using version", vrs[[1]][2]))
  }

  for(i in 1:length(mis_lst)){
      cat(paste0("\n\n******************************************************"))
      cat(paste0("\n|--- Mismatch ", mis_lst[[i]], " started at ", format(Sys.time(), "%X")))
      cat("\n|--- Bowtie mapping:")
      input_file <- paste0(output_path, "/anno_mis", mis_lst[[i]], ".fa")
      
      for (j in 1:length(ref_paths)){
        cat("\n   |--->", paste0(names(ref_paths)[j], "..."))
        output_file <-  paste0(output_path, "/", names(ref_paths)[j], ".out")
      ## Internal bowtie
        if(type=="internal"){
            cat("\n\n")
            bwt_exp <- paste0("Rbowtie::bowtie(sequences=input_file, index=ref_paths[[j]], ",
                                                  paste0(parse_internal, ", v=", mis_lst[[i]], ", p=",threads),
                                                  ", type ='single', outfile='", output_file,
                                                  "', force = TRUE, strict = TRUE)")
            eval(parse(text=bwt_exp)) }
        
      ## External bowtie
        if(type=="external"){
            cat("\n\n")
            bwt_exp <- paste0("bowtie ", parse_external, " -v ", mis_lst[[i]], " -p ", threads, " ", 
                            ref_paths[[j]], " ", input_file, " ", output_file)
            system(bwt_exp, intern=FALSE, ignore.stderr=FALSE)}
        }
        
        reanno <- import_reanno(bowtie_path=output_path, threads=threads, coord=import$coord, report=import$report, reduce=import$reduce)
        
        ## Remove No_hits
        rm_no_hits <- unlist(lapply(reanno, function(x){x[1,1]=="No_hits"}))
        reanno <- reanno[!rm_no_hits]
        
        ## Compare with previous input to generate new input
        suffix <- paste0("mis", mis_lst[[i]])
        anno_path <- list.files(output_path, pattern = paste0("anno_", suffix, ".fa"), full.names=TRUE)
        reanno_df <- rbindlist(reanno, fill=FALSE)
        reanno_seqs <- unique(reanno_df$.id)
        anno <- Biostrings::readDNAStringSet(anno_path)
        new_input <- anno[!paste0(anno) %in% reanno_seqs,]           
        new_suffix <- paste0("mis", mis_lst[[i]]+1)
        
        ## Write files
        save(reanno, file= paste0(output_path, "/Full_reanno_", suffix, ".Rdata"))
        Biostrings::writeXStringSet(new_input, filepath=paste0(output_path, "/anno_", new_suffix, ".fa"), format="fasta")
        if(any(rm_no_hits)){cat(paste0("\n\n|--- All reference but ", names(rm_no_hits)[rm_no_hits], " generated hits"))
        }else{cat(paste0("\n|--- All reference but generated hits"))}
        cat(paste0("\n|--- Mismatch ", mis_lst[[i]], " finished -----|"))
  }
cat(paste0("\n\n******************************************************"))
cat(paste0("\n Cleaning up ... "))
if(keep_temp==FALSE){
  fls_temp <- list.files(output_path, full.names=TRUE, recursive = FALSE, patter=".out$")
  file.remove(fls_temp)}  
cat(paste0("\n Reanno mapping finished at: ", format(Sys.time(), "%X")))
cat(paste0("\n Output files are saved in:\n  ", paste0(output_path)))
  
}


  
 


