#' Aligning sequences against references using bowtie
#'
#' Aligns sequences in a PAC list object against specified references generating
#' summarized report files in the destination folder.
#'
#' Given a PAC object this function will extract the read sequences and align
#' them against single or multiple fasta reference file(s). Summarized output
#' will be saved as .Rdata files in the destination folder. In its default
#' setting the function will only report hit or no hit in up to 3 mismatches,
#' but this can easily be changed between 0-3 mismatches, to include alignment
#' coordinates and reference name extractions. Information from the .Rdata files
#' (Full_reanno_mis0/1/2/3.Rdata) can be extracted and added to a PAC object
#' using \code{make_reanno} and \code{add_reanno} functions. For increase
#' compatibility across platforms, the function provides both R internal bowtie
#' parsing (thorugh the Rbowtie package), as well as external parsing to a
#' locally installed version of bowtie.
#'
#'
#' @family PAC reannotation
#'
#' @seealso  \url{http://bowtie-bio.sourceforge.net/index.shtml} for information
#'   about Bowtie and for Rbowtie:
#'   \url{https://www.bioconductor.org/packages/release/bioc/html/Rbowtie.html}.
#'   \url{https://github.com/Danis102} for updates on the current package.
#'
#' @param PAC PAC-list object containing an Anno data.frame with sequences as
#'   row names.
#'
#' @param type Character indicating if mapping should be performed by calling
#'   the internal bowtie function of the Rbowtie package (type="internal"), or
#'   if bowtie should be called externally through a system call for a locally
#'   installed bowtie (type="external").
#'
#' @param mismatches Integer indicating the maximum number of mismatches allowed
#'   in the alignments. The function currently supports no more than 3
#'   mismatches (botwie max).
#'
#' @param output_path Character indicating the path to the destination folder
#'   for the files generated by the function.
#'
#' @param ref_paths List of file paths (character) indicating the full paths to
#'   each fasta reference file. Importantly, carefully name each reference path.
#'   The names will appear as they are named in the final annotation table.
#'   Thus, if \emph{ref_paths=list(tRNA="<path_tRNA_ref>",
#'   miRNA="<path_piRNA_ref>")} mapping to these fasta references will appear as
#'   "tRNA" and "miRNA", respectively. Note: All reference fasta files must have
#'   bowtie indexes using \code{\link[QuasR]{Rbowtie::bowtie_build}}.
#'
#' @param parse_internal One character string specifying the additional options
#'   parsed to the bowtie function in the Rbowtie package when type="internal".
#'   The string follows similar rules as '...' parsing. See
#'   \code{\link[QuasR]{Rbowtie::bowtie}} for details on the format. As default:
#'   parse_internal= "a=TRUE, f=TRUE".
#'
#' @param parse_external One character string specifying the additional options
#'   parsed to externally installed bowtie when type="external". The string
#'   follows similar rules as '...' parsing. More information on the formating
#'   use: \code{system("bowtie --manual", intern=TRUE, ignore.stderr=FALSE)}. If
#'   this command fails you probably do not have bowtie correctly installed. As
#'   default parse_external= "-a -f".
#'
#' @param import Character or a list. If \code{import="genome"} mapping is done
#'   against a reference genome and genomic coordinates are acquired. If
#'   import="biotype", mapping is done against a specialized fasta reference
#'   (e.g. Ensembl_ncrna, pirBase etc), where genomic coordinates is not
#'   required because classification will be performed on a match-or-no-match
#'   basis. A list of exactly 3 objects, named "coord", "report" and "reduce"
#'   can also be provided. This list will be parsed to the
#'   \code{\link{import_reanno}} function. When import="genome", the list
#'   \code{import=list(coord=TRUE, report="full", reduce=NULL)} is automatically
#'   parsed, while when import="biotype" the list parsed is
#'   \code{import=list(coord=FALSE, report="full", reduce=NULL)}. Performance
#'   increases by setting coord=FALSE. See \code{\link{import_reanno}} for more
#'   information on how to set \code{report} and \code{reduce} for increased
#'   performance when extremely large and repetitative references are used, such
#'   as pirBase and repeatMasker.
#'
#' @param threads Integer indicating the number of parallel processes to be
#'   used.
#'
#' @param keep_temp Logical whether or not bowtie output files temporarly stored
#'   in the output path should be deleted. Note, this option is only used for
#'   troubleshooting. The bowtie output files are named as the reference files
#'   and are overwritten in each mismatch cycle. Thus, for safe saving of
#'   mismatch 0 bowtie output make sure that \code{mismatches=0}. If not, the
#'   mismatch 1 cycle will overwrite the botwie files.
#'
#' @return Will primarily generate .Rdata files in the destination folder
#'   (\code{output_path}) containing summarized information about the reference
#'   alignments. One file is generated for every mismatch specified in
#'   \emph{mismatches}. The \code{\link{make_reanno}} function can then be used
#'   to extract and generate annotation tables for a PAC list object. Large
#'   temporary bowtie input and output files will also be generated in the
#'   destination folder, but are removed unless \code{temp_remove=FALSE}.
#'  
#' @examples
#' 
#' ######################################################### 
#' ##### Example type = "internal" for genome alignment #### 
#' #
#' # library(seqpac)
#' # load(system.file("extdata", "drosophila_sRNA_pac_filt.Rdata", package = "seqpac", mustWork = TRUE))
#' # pac <- pac_cpm_filt
#' # 
#' # ## Path to bowtie indexed reference genome fasta 
#' # ref_paths <- list(genome="/data/Data_analysis/Genomes/Drosophila/dm6/Ensembl/dm6_ensembl_release_101/fasta/chr/fast_chr.fa")
#' # 
#' # ## Path to output folder:
#' # output_genome <- "/home/danis31/Desktop/Temp_docs/reanno_genome"
#' # 
#' # ## Run map_reanno internally for genome mapping
#' # map_reanno(PAC=pac, ref_paths=ref_paths, output_path=output_genome, 
#' #            type="internal", mismatches=3, import="genome", threads=1, keep_temp=TRUE)
#' # 
#' # ## Subsequent reannotion workflow for genome
#' # reanno <- make_reanno(reanno_path=output_genome, PAC=pac, mis_fasta_check = TRUE)
#' # pac <- add_reanno(reanno=reanno, mismatches = 3,  merge_pac=pac, type = "genome", genome_max = 10)
#' #   
#' ############################################################################ 
#' ##### Example type= external for biotype classification with 0 mismatch #### 
#' #
#' # ## Path to bowtie indexed fasta references   
#' # ref_paths <- list(miRNA="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/miRNA/miRBase_21-dme.fa",
#' #                   Ensembl="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/Ensembl/Drosophila_melanogaster.BDGP6.ncrna.fa",
#' #                   rRNA="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/rRNA_reanno/drosophila_rRNA_all.fa",
#' #                   tRNA="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/tRNA_reanno/tRNA_mature.fa",
#' #                   piRNA="/data/Data_analysis/Genomes/Drosophila/dm6/sports/Drosophila_melanogaster/piRNA_piRBase/piR_dme.fa")
#' # 
#' # ## Path to output folder:
#' # output_bio <- "/home/danis31/Desktop/Temp_docs/reanno_biotype"
#' # 
#' # ## Run map_reanno for biotype classification
#' # map_reanno(pac, ref_paths=ref_paths, output_path=output_bio, 
#' #            type="external", mismatches=0,  import="biotype", threads=1)
#' #
#' # ## Subsequent reannotion workflow for sequence classification
#' # bio_search <- list(
#' #                 miRNA="dme-",
#' #                 Ensembl =c("lincRNA", "miRNA", "pre_miRNA", "rRNA", "snoRNA", 
#' #                           "snRNA", "tRNA", "Uhg", "7SLRNA", "asRNA", "hpRNA", 
#' #                           "RNaseMRP","RNaseP", "sbRNA", "scaRNA", "sisRNA", 
#' #                           "snmRNA", "snoRNA", "snRNA","Su\\(Ste\\)"),
#' #                 rRNA    =c("5.8S", "28S", "18S"),
#' #                 tRNA    =c("^tRNA", "MT"),
#' #                 piRNA   =c("piR-"))
#' #                 
#' # reanno <- make_reanno(reanno_path=output_bio, PAC=pac, mis_fasta_check = TRUE)
#' # pac <- add_reanno(reanno, merge_pac=pac, bio_search=bio_search, type="biotype", bio_perfect=FALSE, mismatches = 0)
#' # 
#' # head(pac$Anno)
#' #
#' # ## Merge with PAC object
#' # pac_master <- add_reanno(reanno, bio_search=bio_search, type="biotype", bio_perfect=FALSE, mismatches = 3, merge_pac=pac_master) 
#' # head(pac_master$Anno)
#' # 
#' # 
#' # 
#' # ####################################################
#' # #### The trick to succeed with bio_perfect=TRUE ####
#' # 
#' # ## Run add_reanno with bio_perfect="FALSE" (look where "Other=XX" occurs)
#' #
#' # bio_search <- list(
#' #                 miRNA="dme-",
#' #                 Ensembl =c("miRNA", "pre_miRNA", "rRNA", "snoRNA", 
#' #                           "snRNA", "tRNA", "Uhg", "7SLRNA", "asRNA", "hpRNA", 
#' #                           "RNaseMRP","RNaseP", "sbRNA", "scaRNA", "sisRNA", 
#' #                           "snmRNA", "snoRNA", "snRNA","Su\\(Ste\\)"),
#' #                 rRNA    =c("5.8S", "28S", "18S", "rRNA"),
#' #                 tRNA    =c("^tRNA"),
#' #                 piRNA   =c("piR-"))
#' # 
#' # anno <- add_reanno(reanno, bio_search=bio_search, type="biotype", bio_perfect=FALSE, mismatches = 0)
#' # 
#' # ## Find sequences that has been classified as other 
#' # other_seqs  <- anno[grepl("other", anno$mis0_bio),]$seq_bio
#' # tab <- reanno$Full_anno$mis0$Ensembl
#' # tab[tab$seq %in% other_seqs,]         # lincRNA don't have a search term
#' # 
#' # 
#' # ## Add a search terms that catches all lincRNA 
#' # 
#' # bio_search <- list(
#' #                 miRNA="dme-",
#' #                 Ensembl =c("lincRNA", "miRNA", "pre_miRNA", "rRNA", "snoRNA", 
#' #                           "snRNA", "tRNA", "Uhg", "7SLRNA", "asRNA", "hpRNA", 
#' #                           "RNaseMRP","RNaseP", "sbRNA", "scaRNA", "sisRNA", 
#' #                           "snmRNA", "snoRNA", "snRNA","Su\\(Ste\\)"),
#' #                 rRNA    =c("5.8S", "28S", "18S", "rRNA"),
#' #                 tRNA    =c("^tRNA"),
#' #                 piRNA   =c("piR-"))
#' #                 
#' # anno <- add_reanno(reanno, bio_search=bio_search, type="biotype", bio_perfect=FALSE, mismatches = 0)
#' # 
#' # ## Repeat search until no "Other" appear when running add_reanno, then run  bio_perfect=TRUE: 
#' # 
#' # anno <- add_reanno(reanno, bio_search=bio_search, type="biotype", bio_perfect=TRUE, mismatches = 0)
#' 
#' @export
# 
map_reanno <- function(PAC, type="internal", output_path, ref_paths, 
                       mismatches=3, threads=1, parse_external= "-a -f", 
                       parse_internal = "a=TRUE, f=TRUE", 
                       import="genome", keep_temp=FALSE){
  
  ## setup
  stopifnot(PAC_check(PAC))
  mis_lst <- as.list(0:mismatches)
  names(mis_lst) <- paste0("mis", 0:mismatches)
  ref_paths <- lapply(ref_paths, function(x){gsub("\\.fa$", "", x)})
  seq_fst <- Biostrings::DNAStringSet(rownames(PAC$Anno))
  names(seq_fst) <- paste(seq_fst)
  
  if(length(import)==1){
    if(import=="genome"){ 
      import <- list(coord=TRUE, report="full", reduce=NULL)
    }else{
      if(import=="biotype"){ 
        import <- list(coord=FALSE, report="full", reduce=NULL)
      }else{
        stop("\nPlease, provide correct import options.",
             "\nChose between 'genome', 'biotype' or list of options.",
             "\nSee ?map_reanno and ?import_reanno for more details.")
      }
    }
  }
  ## Look for files and folders in output path
  drs <- list.dirs(output_path, full.names = FALSE, recursive = FALSE) 
  fls <- list.files(output_path, recursive = FALSE)
  if(length(fls[!fls %in% drs])>0){
    cat("\n")
    warning(paste0("\n  There are files in the output folder:\n  ", 
                   output_path,  "\n  Is it ok to delete them? (y/n)"), 
            immediate.=TRUE, call.=FALSE)
    response <- readline()
    if(!response %in% c("y", "Y")){
      stop(paste0("Please move or delete the files in the output folder."))
    }
  }
  if(!dir.exists(output_path)){
    suppressWarnings(dir.create(output_path, recursive = TRUE))  
  }else{
    fls_full <- list.files(output_path, recursive = FALSE, full.names=TRUE)
    file.remove(fls_full[!fls %in% drs])
  }
  
  ## Save first input
  Biostrings::writeXStringSet(seq_fst, 
                              filepath=paste0(output_path, "/anno_mis0.fa"), 
                              format="fasta")
  
  ## Run bowtie over each reference
  if(type=="internal"){
    vrs <- capture.output(Rbowtie::bowtie_version())
    vrs <- gsub("  |bowtie version ", " ", basename(vrs[[1]]))
    vrs <- gsub(" ", "", basename(vrs[[1]]))
    vrs <- gsub("\"", "", basename(vrs[[1]]))
    cat("\nR internal mapping using the Rbowtie package was specified.\n")
    cat(paste0("This package uses bowtie version ", vrs, ".\n"))
    cat("If you need a newer version, please install Bowtie manually\n")
    cat("outside R and then use option type='external'.\n")
  }
  
  if(type=="external"){
    vrs <- stringr::str_split(
      basename(capture.output(system("bowtie --version", 
                                     intern=TRUE))[[1]]), "version")
    cat("\nR external mapping depends on correct installation of bowtie.")
    cat("\nIf thre are problems using external bowtie, try type='internal'.")
    cat(paste0("\nAn external bowtie installation was found using version", 
               vrs[[1]][2]))
  }
  
  for(i in 1:length(mis_lst)){
    cat(paste0("\n\n******************************************************"))
    cat(paste0("\n|--- Mismatch ", mis_lst[[i]], 
               " started at ", format(Sys.time(), "%X")))
    cat("\n|--- Bowtie mapping:")
    input_file <- paste0(output_path, "/anno_mis", mis_lst[[i]], ".fa")
    
    for (j in 1:length(ref_paths)){
      cat("\n   |--->", paste0(names(ref_paths)[j], "..."))
      output_file <-  file.path(paste0(output_path, "/", 
                                       names(ref_paths)[j], ".out"))
      # Fix windows path problem
      if(grepl("windows", .Platform$OS.type)){
        output_file <- gsub("\\\\", "/", output_file)
        input_file <- gsub("\\\\", "/", input_file)
      }
      ## Internal bowtie
      if(type=="internal"){
        cat("\n\n")
        
        bwt_exp <- paste0("Rbowtie::bowtie(sequences=input_file, 
                          index=ref_paths[[j]], ",
                          paste0(parse_internal, ", 
                                 v=", mis_lst[[i]], ", p=", threads),
                          ", type ='single', outfile='", output_file,
                          "', force = TRUE, strict = TRUE)")
        eval(parse(text=bwt_exp)) 
      }
      
      ## External bowtie
      if(type=="external"){
        cat("\n\n")
        bwt_exp <- paste0("bowtie ", parse_external, 
                          " -v ", mis_lst[[i]], " -p ", threads, " ", 
                          ref_paths[[j]], " ", input_file, " ", output_file)
        system(bwt_exp, intern=FALSE, ignore.stderr=FALSE)
      }
    }
    
    reanno <- import_reanno(bowtie_path=output_path, threads=threads, 
                            coord=import$coord, report=import$report, 
                            reduce=import$reduce)
    
    ## Remove No_hits
    rm_no_hits <- unlist(lapply(reanno, function(x){x[1,1]=="No_hits"}))
    reanno <- reanno[!rm_no_hits]
    
    ## Compare with previous input to generate new input
    suffix <- paste0("mis", mis_lst[[i]])
    anno_path <- list.files(output_path, 
                            pattern = paste0("anno_", suffix, ".fa"), 
                            full.names=TRUE)
    reanno_df <- data.table::rbindlist(reanno, fill=FALSE)
    reanno_seqs <- unique(reanno_df$.id)
    anno <- Biostrings::readDNAStringSet(anno_path)
    new_input <- anno[!paste0(anno) %in% reanno_seqs,]           
    new_suffix <- paste0("mis", mis_lst[[i]]+1)
    
    ## Write files
    save(reanno, file= paste0(output_path, "/Full_reanno_", suffix, ".Rdata"))
    Biostrings::writeXStringSet(new_input, 
                                filepath=paste0(output_path, 
                                                "/anno_", new_suffix, ".fa"), 
                                format="fasta")
    if(any(rm_no_hits)){cat(paste0("\n\n|--- All reference but ", 
                                   names(rm_no_hits)[rm_no_hits], 
                                   " generated hits"))
    }else{cat(paste0("\n|--- All reference generated hits"))}
    cat(paste0("\n|--- Mismatch ", mis_lst[[i]], " finished -----|"))
  }
  cat(paste0("\n\n******************************************************"))
  cat(paste0("\nCleaning up ... "))
  if(keep_temp==FALSE){
    fls_temp <- list.files(output_path, full.names=TRUE, 
                           recursive = FALSE, pattern=".out$")
    file.remove(fls_temp)}  
  cat(paste0("\nReanno mapping finished at: ", format(Sys.time(), "%X")))
  cat(paste0("\nOutput files are saved in:\n  ", paste0(output_path)))
  
}


  
 


