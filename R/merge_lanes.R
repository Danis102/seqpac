#' Merge fastq lane files 
#'
#' \code{merge_lanes} Identifies, reads and merges fastq lane files.
#'
#' Given an input path were flow cell lane files in fastq format (typically
#' generated by for example Illumina sequencers) this function will try to
#' identify unique samples among the lane files and merge all lane files for
#' each sample. The function uses md5 checks to control that each lane file is
#' unique (no accidental copies) and will compare expected outcomes given that
#' all samples should have the same number of lanes (comming from the same
#' experiment).
#' 
#' @family PAC generation
#'
#' @seealso \url{https://github.com/Danis102} for updates on the current
#'   package.
#'
#' @param in_path Character string with the path to lane files that should be
#'   merged. The names of the lane files should follow the convention:
#'   'sample1_lane1.fastq.gz, sample1_lane2.fastq.gz, sample2_lane1.fastq.gz,
#'   etc', where the first part of the name indicate the sample while the second
#'   part indicate lanes. The function will automatically identify samples by
#'   file names with idenitcal first parts. The function only takes fastq.gz
#'   compressed files.
#'   
#' @param out_path Character string with the path to destination folder for
#'   merged fastq.gz files.
#'   
#' @param threads Integer indicating the number of parallel processes that
#'   should be used.
#'
#' @return Merged fastq files in destination folder.
#'
#' @examples
#' 
#' ## The simple principle: 
#' # in_path <- "/some/path/to/lane/files/fastq.gz"
#' # out_path <- "/some/path/to/merged/files/"
#' # merge_lanes(in_path, out_path, threads=12)
#' 
#' 
#' ## Real example
#' # First generate some smallRNA fastq.
#' # Only one untrimmed fastq comes with seqpac
#' # Thus, we need to randomly sample that one using the ShortRead-package
#'  
#' sys_path = system.file("extdata", package = "seqpac", mustWork = TRUE)
#' fq <- list.files(path = sys_path, pattern = "fastq", all.files = FALSE,
#'                 full.names = TRUE)
#'
#' closeAllConnections()
#'
#' sampler <- ShortRead::FastqSampler(fq, 20000)
#' set.seed(123)
#' fqs <- list(fq1_lane1=ShortRead::yield(sampler),
#'            fq1_lane2=ShortRead::yield(sampler),
#'            fq1_lane3=ShortRead::yield(sampler),
#'            fq2_lane1=ShortRead::yield(sampler),
#'            fq2_lane2=ShortRead::yield(sampler),
#'            fq2_lane3=ShortRead::yield(sampler))
#'
#' # Now generate a temp folder were we can store the fastq files
#' # (for autonomous example, make sure it is empty and correct platform)
#' 
#' input <- paste0(tempdir(), "/seqpac_temp")
#' if(grepl("windows", .Platform$OS.type)){
#'  input <- gsub( "\\\\", "/", input)
#' }
#' fls  <- list.files(input, recursive=TRUE)
#' if(length(fls)>0){unlink(input, recursive=TRUE)}
#' dir.create(input, showWarnings=FALSE)
#' 
#' 
#'
#' # And then write the random fastq to the temp folder
#' for (i in 1:length(fqs)){
#'  input_file <- paste0(input, "/", names(fqs)[i], ".fastq.gz")
#'  ShortRead::writeFastq(fqs[[i]], input_file, mode="w", 
#'                        full=FALSE, compress=TRUE)
#' }
#' 
#' # Create an output folder
#' output <- paste0(input, "/merged")
#' dir.create(output, showWarnings=FALSE)
#' 
#' 
#' # Then merge the fastq files
#' merge_lanes(input, output, threads=4)
#' 
#' # You will find the files in:
#' input
#' output
#' 
#' # warning: clean up:
#' file.remove(list.files(input, full=TRUE, pattern=".fastq.gz"))
#' file.remove(list.files(output, full=TRUE, pattern=".fastq.gz"))
#' 
#' @export

merge_lanes <- function(in_path, out_path, threads=1){
  j <- NULL
  fls <- list.files(in_path, pattern=".fastq.gz")
  fls_full <- list.files(in_path, pattern=".fastq.gz", full.names = TRUE)

  # Error if no files are found
  if(length(fls) < 1){
    stop("\nNo fastq files were found. Double check the input folder", 
         "\nand make sure that fastq is in the correct format (.fastq.gz).") 
  }
  
  # Check md5
  test <- list(NULL)
  md5 <- lapply(as.list(fls_full), function(x){
    fstq <- data.table::fread(x, header=FALSE, nrows=1000)
    test <- digest::digest(fstq, algo="md5")
    return(test)
  })
  if(any(duplicated(unlist(md5)))){
    stop("\nTwo or more fastq files were identical (md5 check). Possible ", 
         "\nreason: you have mistakenly made two copies of the same file.")
  }
  
  # Fix name vy trimming in the end until shorter unique
  fls_nam <- fls
  length(fls_nam) <- length(fls)
  while(length(fls_nam) == length(fls)){
    fls_nam <- lapply(fls_nam, function(x){
             substring(x, 1, nchar(x)-1)
    })
   fls_nam <- unique(unlist(fls_nam))
  }

  # trim further and test if still valid
  test <- unique(gsub("_L00$|_L0$|_L$|_$", "", fls_nam))
  if(length(test) == length(fls_nam)){
    fls_nam <- test
  }
  
  # Identify and merge files of unique samples save in output
  doParallel::registerDoParallel(threads)
  `%dopar%` <- foreach::`%dopar%`
  done <- foreach::foreach(j=1:length(fls_nam)) %dopar% {
    fl_base<- fls_nam[j]
    lns  <- which(grepl(fl_base, fls_full))
    out_nam  <- paste0(out_path, "/", fl_base, ".fastq.gz")
    if(grepl("win|WIN|Win", Sys.info()["sysname"])){
        out_nam <- gsub("\\", "/", out_nam, fixed=TRUE)
        }
    for(i in 1:length(lns)){
        if(i == 1){
          file.copy(fls_full[lns[i]], out_nam)
        }else{
          file.append(out_nam, fls_full[lns[i]])
        }
    }
  }
  return("TRUE")
  doParallel::stopImplicitCluster()
}


    
    
    
    
    
    
  
 


 