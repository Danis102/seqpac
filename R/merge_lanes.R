#' Merge fastq lane files 
#'
#' \code{merge_lanes} Identifies, reads and merges fastq lane files.
#'
#' Given an input path were flow cell lane files in fastq format (typically
#' generated by for example Illumina sequencers) this function will try to
#' identify unique samples among the lane files and merge all lane files for
#' each sample. The function uses md5 checks to control that each lane file is
#' unique (no accidental copies) and will compare expected outcomes given that
#' all samples should have the same number of lanes (comming from the same
#' experiment).
#' 
#' @family PAC generation
#'
#' @seealso \url{https://github.com/Danis102} for updates on the current
#'   package.
#'
#' @param in_path Character string with the path to lane files that should be
#'   merged. The names of the lane files should follow the convention:
#'   'sample1_lane1.fastq.gz, sample1_lane2.fastq.gz, sample2_lane1.fastq.gz,
#'   etc', where the first part of the name indicate the sample while the second
#'   part indicate lanes. The function will automatically identify samples by
#'   file names with idenitcal first parts. The function only takes fastq.gz
#'   compressed files.
#'   
#' @param out_path Character string with the path to destination folder for
#'   merged fastq.gz files.
#'   
#' @param threads Integer indicating the number of parallel processes that
#'   should be used.
#'
#' @return Merged fastq files in destination folder.
#'
#' @examples
#' 
#' \dontrun{
#' in_path <- "/some/path/to/fastq.gz/lane/files"
#' out_path <- "/some/path/to/fastq.gz/merged/files"
#'
#' merge_lanes(in_path, out_path, threads=12)
#' 
#' }
#' @export

merge_lanes <- function(in_path, out_path, threads=1){
  fls <- list.files(in_path, pattern=".fastq.gz")
  fls_full <- list.files(in_path, pattern=".fastq.gz", full.names = TRUE)

  # Error if no files are found
  if(length(fls) < 1){
    stop("\nNo fastq files were found. Double check the input folder", 
         "\nand make sure that fastq is in the correct format (.fastq.gz).") 
  }
  
  # Check md5
  test <- list(NULL)
  md5 <- lapply(as.list(fls_full), function(x){
    fstq <- data.table::fread(x, header=FALSE, nrows=1000)
    test <- digest::digest(fstq, algo="md5")
    return(test)
  })
  if(any(duplicated(unlist(md5)))){
    stop("\nTwo or more fastq files were identical (md5 check). Possible ", 
         "\nreason: you have mistakenly made two copies of the same file.")
  }
  
  # Fix name vy trimming in the end until shorter unique
  fls_nam <- fls
  length(fls_nam) <- length(fls)
  while(length(fls_nam) == length(fls)){
    fls_nam <- lapply(fls_nam, function(x){
             substring(x, 1, nchar(x)-1)
    })
   fls_nam <- unique(unlist(fls_nam))
  }

  # trim further and test if still valid
  test <- unique(gsub("_L00$|_L0$|_L$|_$", "", fls_nam))
  if(length(test) == length(fls_nam)){
    fls_nam <- test
  }
  
  # Identify and merge files of unique samples save in output
  doParallel::registerDoParallel(threads)
  `%dopar%` <- foreach::`%dopar%`
  done <- foreach::foreach(j=1:length(fls_nam)) %dopar% {
    fl_base<- fls_nam[j]
    lns  <- which(grepl(fl_base, fls_full))
    out_nam  <- paste0(out_path, "/", fl_base, ".fastq.gz")
    if(grepl("win|WIN|Win", Sys.info()["sysname"])){
        out_nam <- gsub("\\", "/", out_nam, fixed=TRUE)
        }
    for(i in 1:length(lns)){
        if(i == 1){
          file.copy(fls_full[lns[i]], out_nam)
        }else{
          file.append(out_nam, fls_full[lns[i]])
        }
    }
  }
  return("TRUE")
  doParallel::stopImplicitCluster()
}


    
    
    
    
    
    
  
 


 