#' Plot sequence covarage over a reference
#'
#' \code{PAC_covplot} Plotting sequences in a PAC object using an PAC mapping object.
#'
#' Given a PAC object and a PAC_map object generated by \emph{PAC_mapping}
#' this function will attempt to plot the sequence coverage over long
#' references.
#'
#' @family PAC analysis
#'   
#' @seealso \url{https://github.com/Danis102} for updates on the current
#'   package.
#'
#' @param PAC PAC-list object.
#'
#' @param map map object generated by \code{PAC_mapper}.
#' 
#' @param type Character whether plots should be generated using "rpm" or as
#'   "percent" (default="percent").
#'
#' @param summary_target List with 2 character vectors: 
#'   1st object: Character indicating the name of the target PAC summary object
#'   which should be used as input data for the plots. If left empty the 1st
#'   summary object will be used.
#'   2nd object: Character vector indicating the names of the columns in the
#'   summary object from which individual graphs should be plotted. If left
#'   empty all summary columns are plotted in the same graph.
#'   Summaries are generated by the PAC_summary function or customly generated
#'   by the user and stored in the summary 'folder' of a PAC object.
#'   
#' @param map_target (optional) Character vector. Imporant: This is similar to
#'   an anno_target, but instead extracts target references in the PAC_mapping
#'   object. Should contain search terms that can find unique strings in the
#'   reference names . The search terms are parse to grepl("<search terms>,
#'   names(<PAC_mapping object>)). (default=NULL)
#'
#' @param xseq Logical indicating whether the nucleotides should be plotted on
#'   the x-axis. Plotting long references with xseq=FALSE will increase
#'   script performance. (default=TRUE).
#'
#' @param colors Character vector of length=5, indicating the rgb colors to be
#'   parsed to ggplot2 for plotting the stacked bars. Leave as NULL will
#'   generate function default colors (default = NULL).
#'   
#' @param threads Integer indicating number of parallel processes that should be
#'   registered and parsed to doeach (default=1).
#'   
#' @param par_type Character indicating if "PSOCK" or "FORK" should be parsed to
#'   parallel::makeCluster (default="PSOCK"). Windows only supports "PSOCK".
#'   
#' @return Plot list with plots generated by ggplot2
#'
#' @examples
#' 
#' 
#' ### Load data ###
#' library(seqpac)
#' 
#' load(file="/home/danis31/OneDrive/Programmering/Programmering/Pipelines/Drosophila/Pipeline_3.1/seqpac/dm_test_PAC.Rdata")
#' 
#' #PAC_filt <- PAC_filter(PAC_all, threshold=5, coverage=4, type="counts", stat=FALSE, pheno_target=NULL, anno_target=NULL)
#' PAC_filt <- PAC_rpm(PAC_filt)
#' PAC_filt <- PAC_summary(PAC_filt, norm = "rpm", type = "means", pheno_target=list("Method"))
#' PAC_check(PAC_filt)
#' 
#' 
#' ref_path <- "/data/Data_analysis/Genomes/Drosophila/dm6/tRNA/tRNA.fa"
#' full <- Biostrings::readDNAStringSet(ref_path)
#' ref <- full[grepl("Glu-CTC-3-1|Lys-CTT-1-1 ", names(full))]
#'
#' map_refs <- PAC_mapper(PAC_filt, ref=ref, threads=8, mismatches=3)
#' 
#' plot_lst <- PAC_mismap(PAC=PAC_filt, map=map_refs, type="percent", summary_target=list("means_[Method]"), map_target=NULL,  xseq=TRUE, colors=NULL, threads=8, par_type="PSOCK")
#'
#' cowplot::plot_grid(plot_lst[[1]][[1]][[1]], plot_lst[[1]][[1]][[2]], 
#'                    plot_lst[[1]][[2]][[1]], plot_lst[[1]][[2]][[2]],
#'                    labels="auto", nrow = 4, ncol = 1)
#'                    
#' plot_lst$Data
#'
#'        
#' ### Add coverage plots ###                  
#' 
#' cov_plots <- PAC_covplot(PAC=PAC_filt, map=map_refs, summary_target=list("means_[Method]"), xseq=TRUE, style="line", colour=c("red", "black"))                                   
#'  
#' cowplot::plot_grid(plot_lst[[1]][[1]][[1]], 
#'                    plot_lst[[1]][[1]][[2]], 
#'                    cov_plots[[1]],
#'                    labels="auto", nrow = 3, ncol = 1)
#'
#' cowplot::plot_grid(plot_lst[[1]][[2]][[1]], 
#'                    plot_lst[[1]][[2]][[2]], 
#'                    cov_plots[[2]],
#'                    labels="auto", nrow = 3, ncol = 1)
#'
#'      
#' @export



PAC_mismap <- function(PAC, map, type="percent", summary_target=NULL, map_target=NULL,  threads=1, par_type="PSOCK", xseq=TRUE, colors=NULL){
                            require("ggplot2")
                            require("foreach")
                            if(is.null(summary_target[[1]])){stop("Error: You need to specify a target list in PAC$summary using summary_target.")}
                            if(is.null(names(PAC$summary[[summary_target[[1]]]]))){stop("You need to specify a valid summary_target.\n(Hint: Double check correct object name in PAC$summary or rerun the 'PAC_summary' function.)")}
                            if(length(summary_target)==1){summary_target[[2]] <- names(PAC$summary[[summary_target[[1]]]])}
                            if(is.null(map_target)){map_target <- names(map)}
                            
                            #### Check and subset if necessary
                            map <- map[names(map) %in%  map_target]
                            uni_map <- unique(do.call("c", lapply(map, function(x){rownames(x$Alignments)})))
                            PAC <- PAC_filter(PAC, anno_target=uni_map, subset_only=TRUE)
                            map  <- lapply(map, function(x){x$Alignments <- x$Alignments[rownames(x$Alignments) %in% rownames(PAC$Anno),]; return(x)})
                            if(!nrow(PAC$Anno) == length(uni_map)){warning("Only ", nrow(PAC$Anno), " of ", length(uni_map), " mapped sequences were found in PAC.\n  Will proceede with the ones that were found.\n  (Hint: Did you subset the PAC object after you generated the map?)")}               
                              
                            cl <- parallel::makeCluster(threads, type = par_type)
                            doParallel::registerDoParallel(cl)
                            
                            #### Generate data ####
                            fin_lst <- list(NA)
                            for(i in 1:length(map)){
                                  start_lst <- as.list(summary_target[[2]])
                                  names(start_lst) <- summary_target[[2]]  
                                  res_lst <- lapply(start_lst, function(x){
                                                    seq_lst <- split(map[[i]][[2]], factor(row.names(map[[i]][[2]]), levels=row.names(map[[i]][[2]])))
                                                    res <- data.frame(position=1:nchar(paste0(map[[i]][[1]])), ref_nt=unlist(strsplit(paste0(map[[i]][[1]]), "")), A=0, T=0, G=0, C=0)
                                                    PAC=PAC
                                                    summary_target=summary_target
                                                    positions_lst <- foreach(j=1:length(seq_lst), .final=function(y){names(y) <- names(seq_lst);return(y)})  %dopar% {
                                                                        res_work  <- res
                                                                        seqs_pos <- data.frame(position=seq_lst[[j]]$Align_start:seq_lst[[j]]$Align_end, nt=unlist(strsplit(paste0(rownames(seq_lst[[j]])), "")))
                                                                        res_work$hits[res_work$position %in% seqs_pos$position] <- as.character(seqs_pos$nt)
                                                                        res_work$hits[is.na(res_work$hits)] <- "No_hit"
                                                                        data  <- PAC$summary[[summary_target[[1]]]][rownames(PAC$summary[[summary_target[[1]]]]) %in% rownames(seq_lst[[j]]),,drop=FALSE]
                                                                          
                                                                        res_work$A[res_work$hits=="A"] <- res_work$A[res_work$hits=="A"]+ data[, colnames(data) == x]
                                                                        res_work$T[res_work$hits=="T"] <- res_work$T[res_work$hits=="T"]+ data[, colnames(data) == x]
                                                                        res_work$C[res_work$hits=="C"] <- res_work$C[res_work$hits=="C"]+ data[, colnames(data) == x]
                                                                        res_work$G[res_work$hits=="G"] <- res_work$G[res_work$hits=="G"]+ data[, colnames(data) == x]
                                                                        return(res_work[, !colnames(res_work)=="hits"])
                                                    }
                                                    stopifnot(!any(!do.call("c",lapply(positions_lst, function(v){identical(v$ref_nt, positions_lst[[1]]$ref_nt)}))))
                                                    stopifnot(!any(!do.call("c",lapply(positions_lst, function(v){identical(v$position, positions_lst[[1]]$position)}))))
                                                    stopifnot(identical(names(positions_lst), rownames(map[[i]]$Alignments)))
                                                    A_vec <- rowSums(do.call("cbind", lapply(positions_lst, function(z){return(z[, "A", drop=FALSE])})))
                                                    T_vec <- rowSums(do.call("cbind", lapply(positions_lst, function(z){return(z[, "T", drop=FALSE])})))
                                                    C_vec <- rowSums(do.call("cbind", lapply(positions_lst, function(z){return(z[, "C", drop=FALSE])})))
                                                    G_vec <- rowSums(do.call("cbind", lapply(positions_lst, function(z){return(z[, "G", drop=FALSE])})))
                                                    fin_df <- data.frame(position=positions_lst[[1]]$position, ref_nt=positions_lst[[1]]$ref_nt, A=A_vec, T=T_vec, C=C_vec, G=G_vec)
                                                    return(fin_df)
                                        })
                                  fin_lst[[i]] <- res_lst
                                  names(fin_lst)[i] <- names(map)[i]
                                }
                                  
                              #### Make percent ####
                              perc_lst <- lapply(fin_lst, function(x){
                                                  lapply(x, function(y){
                                                      tot  <-  rowSums(y[,c("A","T", "C", "G")])
                                                      perc <- data.frame(A=y$A/tot*100, T=y$T/tot*100, C=y$C/tot*100, G=y$G/tot*100)
                                                      perc[is.na(perc)] <- 0
                                                      perc[perc==100] <- 0
                                                      perc$ref <- ifelse(rowSums(perc) == 0, 100, 0)
                                                      return(cbind(y[,c("position", "ref_nt")], perc))
         
                                          })
                                        })

                              #### Plot data ####
                              if(is.null(colors)){
                                                    colors <- c(A="#094A6B", T="#e6a700", C="#9D0014", G="#52793d", ref="#B9B9B9")
                                                    #scales::show_col(colors)
                                                    }
                              
                              if(type=="percent"){plt_data <- perc_lst; ylb <- "Mean percent"}
                              if(type=="rpm"){plt_data <- fin_lst; ylb <- "Mean rpm"}
                            
                              plot_lst <- lapply(seq_along(plt_data), function(z){ # Use seq_along to grab names
                                                  lst <- plt_data[[z]]
                                                  nam1 <- names(plt_data)[z]
                                                  
                                                  ## Add sequence x labels
                                                  if(xseq==TRUE){
                                                         x_lab <- unlist(strsplit(as.character(lst[[1]]$ref_nt), ""))
                                                         tcks <- element_line()
                                                  }else{x_lab<-NULL; tcks <- element_blank()}
                                            
                                                  plts <- lapply(seq_along(lst), function(q){ # Use seq_along to grab names
                                                          df <- lst[[q]]
                                                          nam2 <- names(lst)[q]
                                                          
                                                          data_long <- reshape2::melt(df, id.vars=c("position", "ref_nt"))
                                                          data_long$position <- factor(data_long$position, levels=unique(data_long$position))
                                                          
                                                          p <-  ggplot(data_long, aes(x=position, y=value, fill=variable)) +
                                                        								geom_bar(stat="identity", width=0.9, size=1.0) +
                                                                        #geom_hline(yintercept=0, col="#707177", cex=0.6) +
                                                        								scale_fill_manual(values=rev(colors))+
                                                          							ylab(ylb) +
                                                                        ggtitle(nam2) +
                                                                        xlab(nam1) +
                                                        							  scale_x_discrete(labels=c(as.character(df$ref_nt)))+
                                                                        theme_classic()+
                                                        							  theme(axis.ticks.x=tcks, axis.text.x = element_text(size=8), plot.title = element_text(size=10))
                                                          })
                                                  names(plts) <- names(lst)
                                                  return(plts)
                                                      })
                              names(plot_lst) <-names(plt_data)
                              parallel::stopCluster(cl)
                              return(list(Plots=plot_lst, Data=fin_lst))                                    
                            }
                                                                 

