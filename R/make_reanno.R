#' Makes annotation from R imported reannotation mapping
#'
#' \code{make_reanno} makes a reannotation list.
#'
#' Given the path to the R reannotation files (reanno_mis0/1/2/3/4/5.Rdata)
#' generated by \code{\link{map_reanno}}, this function will summarize the
#' reannotation files into one output that matches the order of sequences in a
#' PAC object.
#'
#' @family PAC reannotation
#'
#' @seealso 
#'   \url{http://bowtie-bio.sourceforge.net/index.shtml} for information about
#'   Bowtie \url{https://github.com/Danis102} for updates on the current
#'   package.
#'
#' @param reanno_path Path to a directory where reannotation .Rdata files can be
#'   found.
#' @param PAC PAC-list object containing an Anno data.frame with sequences as
#'   row names.
#' @param mis_fasta_check Logical TRUE/FALSE if checking against anno_misX.fa
#'   should be done. The anno_misX.fa is the fasta file generated by the
#'   map_reanno function after completing the last mismatch cycle. This file
#'   contains all PAC sequences that failed to receive an alignment in any of
#'   fasta references and after all mismatch cycles. This file should by
#'   availble in the same folder as the output files generated in the
#'   map_reanno function (=reanno_path).
#'   
#' @return List of dataframes with additional information from reannotation
#'   using bowtie. If \emph{mis_fasta_check} is specified the function will look
#'   for a \emph{anno_misX.fa} (X = the file with the highest number) previoulsy
#'   generated by the reannotation workflow. This file is used to double check
#'   so that no sequences are missing before and after reannotation.
#'
#' @examples
#' 
#' 
#' \dontrun{
#' 
#' ######################################################### 
#' ##### Example type = "internal" for genome alignment #### 
#' #
#' library(seqpac)
#' load(system.file("extdata", "drosophila_sRNA_pac_filt.Rdata", 
#'                  package = "seqpac", mustWork = TRUE))
#' pac <- pac_cpm_filt
#' 
#' ## Path to bowtie indexed reference genome fasta 
#' 
#' ref_paths <- list(genome="/some/path/to/genome.fa")
#' 
#' ## Path to output folder:
#' output_genome <- "/some/path/to/output_folder/"
#' 
#' ## Run map_reanno internally for genome mapping
#' map_reanno(PAC=pac, ref_paths=ref_paths, output_path=output_genome, 
#'            type="internal", mismatches=3, import="genome", 
#'            threads=1, keep_temp=TRUE)
#' 
#' ## Subsequent reannotion workflow for genome
#' reanno <- make_reanno(reanno_path=output_genome, PAC=pac, 
#'                       mis_fasta_check = TRUE)
#' pac <- add_reanno(reanno=reanno, mismatches = 3,  merge_pac=pac, 
#'                   type = "genome", genome_max = 10)
#'   
#' ############################################################################ 
#' ##### Example type= external for biotype classification with 0 mismatch #### 
#' #
#' ## Path to bowtie indexed fasta references   
#' ref_paths <- list(miRNA="/some/path/to//miRNA.fa",
#'                   Ensembl="/some/path/to/ensembl.ncrna.fa",
#'                   rRNA="/some/path/to/rRNA.fa",
#'                   tRNA="/some/path/to/tRNA.fa",
#'                   piRNA="/some/path/to/piRNA.fa")
#' 
#' ## Path to output folder:
#' output_bio <- "/some/path/to/output_folder/"
#' 
#' ## Run map_reanno for biotype classification
#' map_reanno(pac, ref_paths=ref_paths, output_path=output_bio, 
#'            type="external", mismatches=0,  import="biotype", threads=1)
#' #
#' ## Subsequent reannotion workflow for sequence classification
#' bio_search <- list(
#'                 miRNA="dme-",
#'                 Ensembl =c("lincRNA", "miRNA", "pre_miRNA", "rRNA", "snoRNA", 
#'                           "snRNA", "tRNA", "Uhg", "7SLRNA", "asRNA", "hpRNA", 
#'                           "RNaseMRP","RNaseP", "sbRNA", "scaRNA", "sisRNA", 
#'                           "snmRNA", "snoRNA", "snRNA","Su\\(Ste\\)"),
#'                 rRNA    =c("5.8S", "28S", "18S"),
#'                 tRNA    =c("^tRNA", "MT"),
#'                 piRNA   =c("piR-"))
#'                 
#' reanno <- make_reanno(reanno_path=output_bio, PAC=pac, mis_fasta_check = TRUE)
#' pac <- add_reanno(reanno, merge_pac=pac, bio_search=bio_search, 
#'                   type="biotype", bio_perfect=FALSE, mismatches = 0)
#' 
#' head(pac$Anno)
#' #
#' ## Merge with PAC object
#' pac_master <- add_reanno(reanno, bio_search=bio_search, type="biotype", 
#'                          bio_perfect=FALSE, mismatches = 3, 
#'                          merge_pac=pac_master) 
#' head(pac_master$Anno)
#' 
#' 
#' 
#' ####################################################
#' #### The trick to succeed with bio_perfect=TRUE ####
#' 
#' ## Run add_reanno with bio_perfect="FALSE" (look where "Other=XX" occurs)
#' #
#' bio_search <- list(
#'                 miRNA="dme-",
#'                 Ensembl =c("miRNA", "pre_miRNA", "rRNA", "snoRNA", 
#'                           "snRNA", "tRNA", "Uhg", "7SLRNA", "asRNA", "hpRNA", 
#'                           "RNaseMRP","RNaseP", "sbRNA", "scaRNA", "sisRNA", 
#'                           "snmRNA", "snoRNA", "snRNA","Su\\(Ste\\)"),
#'                 rRNA    =c("5.8S", "28S", "18S", "rRNA"),
#'                 tRNA    =c("^tRNA"),
#'                 piRNA   =c("piR-"))
#' 
#' anno <- add_reanno(reanno, bio_search=bio_search, type="biotype", 
#'                    bio_perfect=FALSE, mismatches = 0)
#' 
#' ## Find sequences that has been classified as other 
#' other_seqs  <- anno[grepl("other", anno$mis0_bio),]$seq_bio
#' tab <- reanno$Full_anno$mis0$Ensembl
#' tab[tab$seq %in% other_seqs,]         # lincRNA don't have a search term
#' 
#' 
#' ## Add a search terms that catches all lincRNA 
#' 
#' bio_search <- list(
#'                 miRNA="dme-",
#'                 Ensembl =c("lincRNA", "miRNA", "pre_miRNA", "rRNA", "snoRNA", 
#'                           "snRNA", "tRNA", "Uhg", "7SLRNA", "asRNA", "hpRNA", 
#'                           "RNaseMRP","RNaseP", "sbRNA", "scaRNA", "sisRNA", 
#'                           "snmRNA", "snoRNA", "snRNA","Su\\(Ste\\)"),
#'                 rRNA    =c("5.8S", "28S", "18S", "rRNA"),
#'                 tRNA    =c("^tRNA"),
#'                 piRNA   =c("piR-"))
#'                 
#' anno <- add_reanno(reanno, bio_search=bio_search, type="biotype", 
#'                    bio_perfect=FALSE, mismatches = 0)
#' 
#' ## Repeat search until no "Other" appear, then run  bio_perfect=TRUE: 
#' 
#' anno <- add_reanno(reanno, bio_search=bio_search, type="biotype", 
#'                    bio_perfect=TRUE, mismatches = 0)
#' 
#' }
#'
#' @export

make_reanno <- function(reanno_path, PAC, mis_fasta_check=FALSE){
  
  reanno <- NULL
  
  files <- list.files(reanno_path, 
                      pattern=paste0(
                               "Full_reanno_mis0|",
                               "Full_reanno_mis1|",
                               "Full_reanno_mis2|",
                               "Full_reanno_mis3"), 
                      full.names = TRUE)
  seqs <- (seq(1:length(files)))-1
  reanno_lst <- list(NA)
  for(i in 1:length(files)){
    load(files[i])
    reanno_lst[[i]] <- reanno
    names(reanno_lst)[i] <- paste0("mis", seqs[i])
  }
  
  # Identify mismatch cycles with no hits in any reference 
  test_miss <- unlist(lapply(reanno_lst, length))
  complete_nam <- names(reanno_lst)[which(test_miss == max(test_miss))][1]
  complete_nam <- names(reanno_lst[[complete_nam]])

  cat("\n\nReorganizing and matching reannotation files with PAC ...\n")
  PAC_seq <- rownames(PAC$Anno)
  reanno_lst_match <- lapply(reanno_lst, function(x){
    ## Fix if all references has no hits in 
    if(length(x)==0){
      chr_na<- as.character(NA)
      na_tibb <- tibble::tibble(seq=PAC_seq, mis_n=chr_na, 
                                  mis_where=chr_na, ref_hits=chr_na)
      match_lst <- as.list(rep(NA, length(complete_nam)))
      
      match_lst <- lapply(match_lst, function(x){na_tibb}) 
      names(match_lst) <- complete_nam
    }else{
      match_lst  <- lapply(x,  function(y){
        y$.id <- as.character(y$.id)
        y$ref_hits <- as.character(y$ref_hits)
        anno_match <- y[match(PAC_seq, y$.id), ]
        anno_match$.id[is.na(anno_match$.id)] <- PAC_seq[is.na(anno_match$.id)]
        stopifnot(identical(PAC_seq, anno_match$.id))
        names(anno_match)[names(anno_match)==".id"] <- "seq"
        return(anno_match)
      })
    }
    return(match_lst)
  })    
  
  ## Check and fix missing references
  NA_check <- unlist(lapply(reanno_lst_match, function(x){
    identical(names(reanno_lst_match[[1]]),  names(x))
    }))
  if(any(!NA_check)){
    NA_which <- lapply(reanno_lst, function(x){
      which(!names(reanno_lst[[1]]) %in% names(x))
      })
    warning(paste( "Missing references in Reanno file(s):\n", 
                   paste(basename(files)[!NA_check], collapse="\n "), 
                   "\nMissing ref(s): ",  
                   paste(names(reanno_lst[[1]])[unlist(NA_which)], 
                         collapse=" "), 
                   "\nProbable reason: No sequences mapped to reference(s)."))
    
    for(j in 1:length(NA_which)){
      if(length(NA_which[[j]]) >0){
        empt <- reanno_lst_match[[1]][[1]]
        empt[,2:4] <- NA
        stopifnot(!any(!is.na(empt[,2:4])))
        for(g in 1:length(NA_which[[j]])){
          ps <- length(reanno_lst_match[[j]]) + g
          reanno_lst_match[[j]][[ps]] <- empt
          names(reanno_lst_match[[j]])[ps] <- names(
            reanno_lst_match[[1]])[NA_which[[j]]]
        }
        reanno_lst_match[[j]] <- reanno_lst_match[[j]][match(
          names(reanno_lst_match[[1]]), names(reanno_lst_match[[j]]))]
      }
    }
  }
  
  ## Generate overview file
  cat("\nGenerating the overview file ...\n")
  stopifnot(any(do.call("c", lapply(reanno_lst_match, function(t){
    identical(names(reanno_lst_match[[1]]), names(t))
    }))))
  stopifnot(any(do.call("c", lapply(reanno_lst_match, function(t){
    do.call("c", lapply(t, function(g){
      identical(reanno_lst_match[[1]][[1]]$seq, g$seq)
      }))
    }))))
  bio_cat <- length(reanno_lst_match[[1]])
  df_fin <- matrix(NA, ncol=bio_cat, nrow=length(PAC_seq))
  colnames(df_fin) <- names(reanno_lst_match[[1]]) 
  df_fin <- tibble::as_tibble(df_fin)
  
  for (bio in 1:bio_cat){
    df <- do.call("cbind", lapply(reanno_lst_match, function(x){
      return(x[[bio]]$mis_n)
      }))
    vect <- apply(df, 1, function(x){ 
      return(gsub("NA", "", paste(x, collapse="")))
      })
    df_fin[, bio] <- vect 
  }
  
  df_fin[df_fin == ""] <- "_"
  vect_mis <- do.call("paste", as.list(df_fin))
  df_fin$Any <- ifelse(vect_mis == paste0(
    rep("_", times=bio_cat), collapse=" ") , "No_anno", "Hit") 
  df_fin$Mis0 <- ifelse(grepl("mis0", vect_mis) , "Hit", "No_hit")
  df_fin <- dplyr::bind_cols(tibble::tibble(seq=PAC_seq), df_fin) 
  
  ## Check leftover fasta file
  if(mis_fasta_check==TRUE){
    cat("\nChecking the last anno_mis fasta file.\n")
    anno_mis_fls <- list.files(reanno_path, pattern = "anno_mis\\d.fa")
    outfile_fls <- list.files(reanno_path, pattern = "Full_reanno_mis\\d.Rdata")
    ns_fa <- max(as.integer(gsub("anno_mis|.fa", "", anno_mis_fls)))
    ns_rdata <- max(as.integer(gsub("Full_reanno_mis|.Rdata", "", outfile_fls)))
    file_nam <- paste0("anno_mis", ns_fa, ".fa")
    if(!ns_fa == ns_rdata+1){
      stop(paste0(
        "\nThe last anno_mis fasta ('leftover') file, named ",
        file_nam,
        ", was not found in reanno path.",
        "\nIf it was deleted, set mis_fasta_check=FALSE."))
    }                
    noAnno_fasta <- Biostrings::readDNAStringSet(paste0(reanno_path,"/", 
                                                        file_nam))
    logi_no_anno <- df_fin$Any=="No_anno"
    logi_olap <- df_fin$seq[df_fin$Any=="No_anno"] %in% gsub("NO_Annotation_", 
                                                            "", 
                                                            names(noAnno_fasta))
    if(length(noAnno_fasta) + sum(logi_no_anno)==0){
      cat("Congratulation, all sequences recieved an annotation.\n")
      perc<-100
    }else{
      perc <-  round(sum(logi_olap)  / sum(logi_no_anno)*100, digits=2)
      cat("Of the ",  sum(logi_no_anno), 
          "missing sequences in the reannotation\n")
      cat(paste0("files ", perc, "% were found in ", file_nam, ".\n"))
    }
    if(!perc==100){
      warning(paste0(" Not all missing annotations were found in ", 
                     file_nam, 
                     ".\n This indicates that something has went wrong in the",
                     "\n reannotation workflow.\n"))
    }else{
      cat("Passed fasta check!\n")
    }
  }
  reanno <- list(Overview=df_fin, Full_anno=reanno_lst_match)
  class(reanno) <- c("list", "reanno")
  return(reanno)
}

